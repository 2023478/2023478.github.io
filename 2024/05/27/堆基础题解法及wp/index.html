
<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="utf-8" />
    <title>堆基础题解法及wp | 纲的blog</title>
    <meta name="author" content="wgiegie" />
    <meta name="description" content="" />
    <meta name="keywords" content="Wgiegie" />
    <meta
        name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"
    />
    <link rel="icon" href="/images/avatar.jpg" />
    <link rel="preconnect" href="https://s4.zstatic.net" />
<script src="https://s4.zstatic.net/ajax/libs/vue/3.3.7/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/font-awesome/6.4.2/css/all.min.css" />
<link rel="preconnect" href="https://fonts.googleapis.cn" />
<link rel="preconnect" href="https://fonts.gstatic.cn" crossorigin />
<link
    rel="stylesheet"
    href="https://fonts.googleapis.cn/css2?family=Fira+Code:wght@400;500;600;700&family=Lexend:wght@400;500;600;700;800;900&family=Noto+Sans+SC:wght@400;500;600;700;800;900&display=swap"
/>
<script> const mixins = {}; </script>

<script src="https://polyfill.alicdn.com/v3/polyfill.min.js?features=default"></script>


<script src="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://s4.zstatic.net/ajax/libs/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script>
<link
    rel="stylesheet"
    href="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/styles/github.min.css"
/>
<script src="/js/lib/highlight.js"></script>



<script src="/js/lib/preview.js"></script>









<link rel="stylesheet" href="/css/main.css" />

<meta name="generator" content="Hexo 7.1.1"></head>
<body>
    <div id="layout">
        <transition name="fade">
            <div id="loading" v-show="loading">
                <div id="loading-circle">
                    <h2>LOADING</h2>
                    <p>加载过慢请开启缓存 浏览器默认开启</p>
                    <img src="/images/loading.gif" />
                </div>
            </div>
        </transition>
        <div id="menu" :class="{ hidden: hiddenMenu, 'menu-color': menuColor}">
    <nav id="desktop-menu">
        <a class="title" href="/">
            <span>纲的BLOG</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;Home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;About</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;Archives</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;Categories</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;Tags</span>
        </a>
        
    </nav>
    <nav id="mobile-menu">
        <div class="title" @click="showMenuItems = !showMenuItems">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;纲的BLOG</span>
        </div>
        <transition name="slide">
            <div class="items" v-show="showMenuItems">
                
                <a href="/">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-house fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Home</div>
                    </div>
                </a>
                
                <a href="/about">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-id-card fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">About</div>
                    </div>
                </a>
                
                <a href="/archives">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-box-archive fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Archives</div>
                    </div>
                </a>
                
                <a href="/categories">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-bookmark fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Categories</div>
                    </div>
                </a>
                
                <a href="/tags">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-tags fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Tags</div>
                    </div>
                </a>
                
            </div>
        </transition>
    </nav>
</div>
<transition name="fade">
    <div id="menu-curtain" @click="showMenuItems = !showMenuItems" v-show="showMenuItems"></div>
</transition>

        <div id="main" :class="loading ? 'into-enter-from': 'into-enter-active'">
            <div class="article">
    <div>
        <h1>堆基础题解法及wp</h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/5/27
        </span>
        
        <span class="category">
            <a href="/categories/CTF/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                CTF
            </a>
        </span>
        
        
        <span class="tags">
            <span class="icon">
                <i class="fa-solid fa-tags fa-fw"></i>
            </span>
            
            
            <span class="tag">
                
                <a href="/tags/%E5%A0%86/" style="color: #ff7d73">
                    堆
                </a>
            </span>
            
        </span>
        
    </div>
    
    <div class="content" v-pre>
        <p><strong>UAF漏洞</strong></p>
<p>这类漏洞的基础与原理就是在申请堆块后没有在使用free函数释放这个堆块的同时将在申请是用于指向这个堆块的指针一并清0，使得在后面的程序中还能使用这个指针对程序中的数据造成泄露或执行的操作。</p>
<p>(想自己写一个例子，发现能力不足，还是从网上抄一下算了)</p>
<p><img src="/2024/05/27/%E5%A0%86%E5%9F%BA%E7%A1%80%E9%A2%98%E8%A7%A3%E6%B3%95%E5%8F%8Awp/772091-20151028173133357-937820954.png" alt="img"></p>
<p>如上代码所示，指针p1申请内存，打印其地址，值</p>
<p>然后释放p1</p>
<p>指针p2申请同样大小的内存，打印p2的地址，p1指针指向的值</p>
<p>Gcc编译，运行结果如下：</p>
<p> <img src="/2024/05/27/%E5%A0%86%E5%9F%BA%E7%A1%80%E9%A2%98%E8%A7%A3%E6%B3%95%E5%8F%8Awp/772091-20151028173152185-843248270.png" alt="img"></p>
<p>p1与p2地址相同，p1指针释放后，p2申请相同的大小的内存，操作系统会将之前给p1的地址分配给p2，修改p2的值，p1也被修改了。</p>
<p>由此我们可以知道：</p>
<p>1.在free一块内存后，接着申请大小相同的一块内存，操作系统会将刚刚free掉的内存再次分配。</p>
<p>根本原因是dllmalloc：</p>
<p>参考资料：<a target="_blank" rel="noopener" href="http://blog.csdn.net/ycnian/article/details/12971863">http://blog.csdn.net/ycnian/article/details/12971863</a></p>
<p>当应用程序调用free()释放内存时，如果内存块小于256kb，dlmalloc并不马上将内存块释放回内存，而是将内存块标记为空闲状态。这么做的原因有两个：一是内存块不一定能马上释放会内核（比如内存块不是位于堆顶端），二是供应用程序下次申请内存使用（这是主要原因）。当dlmalloc中空闲内存量达到一定值时dlmalloc才将空闲内存释放会内核。如果应用程序申请的内存大于256kb，dlmalloc调用mmap()向内核申请一块内存，返回返还给应用程序使用。如果应用程序释放的内存大于256kb，dlmalloc马上调用munmap()释放内存。dlmalloc不会缓存大于256kb的内存块，因为这样的内存块太大了，最好不要长期占用这么大的内存资源。</p>
<p>2.通过p2能够操作p1，如果之后p1继续被使用（use after free），则可以达到通过p2修改程序功能等目的。</p>
<p>大致便是如此，现在我们便来整一道题来练一练。</p>
<p><a target="_blank" rel="noopener" href="https://buuoj.cn/challenges#actf_2019_babyheap">BUUCTF在线评测 (buuoj.cn)</a></p>
<p>来自buuctf上的actf_2019_babyheap一道基础的uaf堆的题。</p>
<p>老规矩先checksec一下，只差pie没开了。</p>
<p><img src="/2024/05/27/%E5%A0%86%E5%9F%BA%E7%A1%80%E9%A2%98%E8%A7%A3%E6%B3%95%E5%8F%8Awp/image-20240527212608852.png" alt="image-20240527212608852"></p>
<p>执行一下，经典的菜单题</p>
<p><img src="/2024/05/27/%E5%A0%86%E5%9F%BA%E7%A1%80%E9%A2%98%E8%A7%A3%E6%B3%95%E5%8F%8Awp/image-20240527212706983.png" alt="image-20240527212706983"></p>
<p>那便放入ida中看一看。</p>
<p>main函数，稍微修改了一下，没什么意义。</p>
<p><img src="/2024/05/27/%E5%A0%86%E5%9F%BA%E7%A1%80%E9%A2%98%E8%A7%A3%E6%B3%95%E5%8F%8Awp/image-20240527212905977.png" alt="image-20240527212905977"></p>
<p>有4个选项，1是创建日志，2是清除日志，3是打印日志，4是结束程序。那边一个一个来看</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 <span class="title function_">sub_400A78</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">void</span> **v0; <span class="comment">// rbx</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+8h] [rbp-38h]</span></span><br><span class="line">  <span class="type">int</span> v3; <span class="comment">// [rsp+Ch] [rbp-34h]</span></span><br><span class="line">  <span class="type">char</span> buf[<span class="number">24</span>]; <span class="comment">// [rsp+10h] [rbp-30h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v5; <span class="comment">// [rsp+28h] [rbp-18h]</span></span><br><span class="line"></span><br><span class="line">  v5 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="keyword">if</span> ( dword_60204C &lt;= <span class="number">5</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">4</span>; ++i )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( !*(&amp;ptr + i) )</span><br><span class="line">      &#123;</span><br><span class="line">        *(&amp;ptr + i) = <span class="built_in">malloc</span>(<span class="number">0x10</span>uLL);</span><br><span class="line">        *(*(&amp;ptr + i) + <span class="number">1</span>) = sub_40098A;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Please input size: &quot;</span>);</span><br><span class="line">        read(<span class="number">0</span>, buf, <span class="number">8uLL</span>);</span><br><span class="line">        v3 = atoi(buf);</span><br><span class="line">        v0 = *(&amp;ptr + i);</span><br><span class="line">        *v0 = <span class="built_in">malloc</span>(v3);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Please input content: &quot;</span>);</span><br><span class="line">        read(<span class="number">0</span>, **(&amp;ptr + i), v3);</span><br><span class="line">        ++dword_60204C;</span><br><span class="line">        <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v5;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;The list is full&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于这个创建日志的函数便有很多值得注意的地方，这里面ptr是个bss段的空地址，程序以这里作为申请堆的指针处，在一开始程序通过<code>*(&amp;ptr + i) = malloc(0x10uLL);</code>申请0x10大小的堆，这句话简单来说就是，在ptr+i的地方放这申请的0x10堆的数据段的地址，也通过*(&amp;ptr + i)作为指针指向这个堆。</p>
<p>下一句<code>*(*(&amp;ptr + i) + 1) = sub_40098A;</code>,这里我们知道<code>*(&amp;ptr + i)</code>指向的是0x10堆的数据区的起始地址，因此<code>*(&amp;ptr + i) + 1</code>指的就是堆的数据区中的下一个字节（大小为0x10，实际就是两个字节），这句的本意是将<code>*(*(&amp;ptr + i) + 1)</code>这个作为指针指向sub_40098A函数，起始就是在一开始申请的堆的数据段的第二个字节处放入sub_40098A函数的起始地址。关于sub_40098A函数这个函数（在后文会有答案，用于打印内容）<img src="/2024/05/27/%E5%A0%86%E5%9F%BA%E7%A1%80%E9%A2%98%E8%A7%A3%E6%B3%95%E5%8F%8Awp/image-20240527215650885.png" alt="image-20240527215650885"></p>
<p>接下来的几句大致意思也就是将输入的数作为数值去申请相应大小的堆，并输入数据进去。这理要注意的是这里用<code>*v0</code>作为指针指向新申请堆块，在之前用<code>v0 = *(&amp;ptr + i)</code>将最开始申请的堆块的数据区的第一个字节的地址赋给v0，这里的真正含义便是以最开始申请的堆块的数据区的第一个字节作为指针指向后面申请的堆，便是在第一个堆的数据区中放上第二个堆的数据区的起始地址。入图所示（虚线等多余的地方先不用管）。</p>
<p><img src="/2024/05/27/%E5%A0%86%E5%9F%BA%E7%A1%80%E9%A2%98%E8%A7%A3%E6%B3%95%E5%8F%8Awp/image-20240527221557186.png" alt="image-20240527221557186"></p>
<p>于此便完成了程序中日志创建的堆管理。在来看第二个选项，清理堆</p>
<p><img src="/2024/05/27/%E5%A0%86%E5%9F%BA%E7%A1%80%E9%A2%98%E8%A7%A3%E6%B3%95%E5%8F%8Awp/image-20240527221918220.png" alt="image-20240527221918220"></p>
<p>这里会更具我们输入的数字从而清理第几个堆块，需要注意的是由于之前我们在创建堆的时候程序用来统计堆的个数的数据的起始是从0开始的，所以这里要清理第一个堆要输入的数，应该是0，后面的也要相应减一。</p>
<p>在知道要清理的堆块后，程序便会开始使用free函数清理堆块，这里的<code>**(&amp;ptr + v1))</code>这个其实就是指<code>*v0</code>用来指向由我们自己创建的堆的指针，而第二个<code>*(&amp;ptr + v1)</code>则是用来指向在上一个函数中一开始就创建用来存放第二个堆块的指针的大小为0x10得堆块，这里一次性清理两个堆块，把我们使用创建日志的函数中创建的两个堆一次性清理，<strong>但是我们可以注意到在清理了这个堆块的同时，并没有把指向这两个堆的指针同时清零</strong>，我们可能还有再次调用这两个指针的可能，这里便出现的uaf漏洞的可能，至于能不能使用还要继续往下看。</p>
<p>突然想起来在这里差了一步，忘记查找程序中有没有后门函数。</p>
<p><img src="/2024/05/27/%E5%A0%86%E5%9F%BA%E7%A1%80%E9%A2%98%E8%A7%A3%E6%B3%95%E5%8F%8Awp/image-20240528200516466.png" alt="image-20240528200516466"></p>
<p><img src="/2024/05/27/%E5%A0%86%E5%9F%BA%E7%A1%80%E9%A2%98%E8%A7%A3%E6%B3%95%E5%8F%8Awp/image-20240528200528826.png" alt="image-20240528200528826"></p>
<p>那好，system函数和&#x2F;bin&#x2F;sh都有了，那我们只要能在后面使程序执行system(&#x2F;bin&#x2F;sh)便可以满足程序的需求。现在的问题就在与我们要如何才能使程序执行这个命令的问题了。</p>
<p>现在我们的选项函数还有两个函数没有看，第4个不用管，就是简单的退出函数。</p>
<p><img src="/2024/05/27/%E5%A0%86%E5%9F%BA%E7%A1%80%E9%A2%98%E8%A7%A3%E6%B3%95%E5%8F%8Awp/image-20240528200913954.png" alt="image-20240528200913954"></p>
<p>现在来重点看最后一个打印内容选项的函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 <span class="title function_">sub_400C66</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v1; <span class="comment">// [rsp+Ch] [rbp-24h]</span></span><br><span class="line">  <span class="type">char</span> buf[<span class="number">24</span>]; <span class="comment">// [rsp+10h] [rbp-20h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v3; <span class="comment">// [rsp+28h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v3 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Please input list index: &quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">4uLL</span>);</span><br><span class="line">  v1 = atoi(buf);</span><br><span class="line">  <span class="keyword">if</span> ( v1 &gt;= <span class="number">0</span> &amp;&amp; v1 &lt; dword_60204C )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( *(&amp;ptr + v1) )</span><br><span class="line">      (*(*(&amp;ptr + v1) + <span class="number">1</span>))(**(&amp;ptr + v1));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Out of bound!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据用户输入的数判断要打印的堆块，然后重点来了。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(*(*(&amp;ptr + v1) + <span class="number">1</span>))(**(&amp;ptr + v1));</span><br></pre></td></tr></table></figure>

<p>使用的打印函数并不是直接使用某个函数，而是使用两个指针从而完成函数调用的功能</p>
<p><code>*(*(&amp;ptr + v1) + 1)</code>这里我们前文提过，<code>*(&amp;ptr + v1)</code>是程序自己申请的0x10大小的堆块的指针，而+1则代表他的下一字节。根据前文我们知道这里被放入了一个函数的起始地址（<code> *(*(&amp;ptr + i) + 1) = sub_40098A;</code>），而这个sub_40098A函数的内容</p>
<p><img src="/2024/05/27/%E5%A0%86%E5%9F%BA%E7%A1%80%E9%A2%98%E8%A7%A3%E6%B3%95%E5%8F%8Awp/image-20240528202538129.png" alt="image-20240528202538129"></p>
<p>其实就是完成一个打印的功能的函数，不过这里在程序中使用了一个指针指向他，并通过指针调用。而<code>**(&amp;ptr + v1)</code>这个就是指向在之前根据我们自己输入的大小申请的相应大小的堆块。</p>
<p>所以这里就用这两个指针完成了对堆内容的打印。并且这里的这两个指针是存放在同一个堆块之中，那我们便可以想是否能够修改这个堆块中的这两个指针的内容从而执行我们的后门函数，从而达到目的。</p>
<p>在这里结合之前发现的uaf漏洞，会发现这里会出现一个致命的问题，在理论上我们之前申请堆块用的指针被存放在ptr及其后面的位置中，程序为了方便管理会依次使用ptr后的空间，并不是覆盖。然后在我们使用清理堆块的选项时，并没有将指针一同清零，因此，在ptr的地址中依然有指向堆块的指针存在，并没有被清理，然后我们在调用打印的函数时，依然能调用已经被free掉的堆块，并执行其中的内容，于是我们对本题的攻击便基本成型。</p>
<img src="/2024/05/27/%E5%A0%86%E5%9F%BA%E7%A1%80%E9%A2%98%E8%A7%A3%E6%B3%95%E5%8F%8Awp/image-20240528205137589.png" alt="image-20240528205137589" style="zoom:200%;">

<p>大致的思路如图，根据这个来描述针对本题的攻击。</p>
<p>在程序中先使用创建日志的函数，申请一个大小&gt;0x18的堆（这里必须要让程序配一个与0x10大小不同的堆块，多的8可以输入到下一个chunk中的prev size字段，一旦超过8便只能从新申请更大的堆块），随便填一点内容就行，这样程序便会像上面的ptr指向的两个堆块一样出现这样的结构，然后在执行同样的操作，再申请一个大于0x18的堆，这样程序的ptr和ptr+1地段都会出现上文中的结构。</p>
<p>在之后我们通过程序中的清理函数的选项将我们刚刚申请的这4个堆块都free掉。于是程序中的fast bin中便会出现上面左边的结构，这4个堆依次连接，便于程序的下次快速调用，这里我们虽然将我们之前申请的堆块free掉了，但是ptr中的指针这些都没有被清零。</p>
<p>然后我们在使用这个选项向程序在申请大小为0x10的堆块，这里程序为了快速分配会先从而fast bin中寻找有没有满足要求的chunk，于是之前最后进入fast bin中的原本ptr +1指向的chunk便会被分配出去，然后由于我们还需要一个大小为0x10的chunk，于是之前ptr指向的chunk，便会被分配出去（这里就是为了避免我们自己申请的堆被分配出去所以申请的必须要大于0x18），用于作为我们自己申请的堆存储我们填入的数据，于是程序便构成ptr+2中由虚线指向的结构。此时如果我们向我们自己申请的堆中填入system和&#x2F;bin&#x2F;sh的地址那么，便覆盖ptr指向的堆中的数据，</p>
<p>此时由于ptr中的指针并没用清零，于是我们再次使用打印的选项并想要打印第一个堆块中的内容时程序会开始执行ptr指向的堆块中的命令来用于打印（理论上来说，如果我们应该将ptr中的指针清零，从而使程序不能完成我们这个打印已经被free掉的堆的操作，但是由于ptr中指针没有被清零于是程序就认为那个堆依然存在从而去执行堆中的指针，从而打印内容），但是我们此时修改了这个堆的内容导致程序直接执行了system(&#x2F;bin&#x2F;sh)这个后门函数从而满足了我们的要求。</p>
<p>exp如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">io=process(<span class="string">&#x27;./babyheap&#x27;</span>)</span><br><span class="line"><span class="meta">#io = remote(<span class="string">&quot;node5.buuoj.cn&quot;</span>,28382)</span></span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"><span class="meta">#gdb.attach(io,<span class="string">&#x27;b *0x400D6E&#x27;</span>)ls</span></span><br><span class="line"><span class="meta">#pause()</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def create_1(size,content):</span><br><span class="line">    io.sendafter(<span class="string">&#x27;Your choice: &#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    io.sendafter(<span class="string">&#x27;size: \n&#x27;</span>,str(size))</span><br><span class="line">    io.sendafter(<span class="string">&#x27;content: \n&#x27;</span>,content)</span><br><span class="line"></span><br><span class="line">def delete_2(index):</span><br><span class="line">    io.sendafter(<span class="string">&#x27;Your choice: &#x27;</span>,b<span class="number">&#x27;2&#x27;</span>)</span><br><span class="line">    io.sendafter(<span class="string">&#x27;index: \n&#x27;</span>,str(index))</span><br><span class="line"></span><br><span class="line">def print_3(index):</span><br><span class="line">    io.sendafter(<span class="string">&#x27;Your choice: &#x27;</span>,b<span class="number">&#x27;3&#x27;</span>)</span><br><span class="line">    io.sendafter(<span class="string">&#x27;index: \n&#x27;</span>,str(index))    </span><br><span class="line"></span><br><span class="line">binsh=<span class="number">0x602010</span></span><br><span class="line">system=<span class="number">0x4007A0</span></span><br><span class="line"></span><br><span class="line">create_1(<span class="number">0x19</span>,b<span class="number">&#x27;</span>AAA<span class="number">&#x27;</span>)</span><br><span class="line">create_1(<span class="number">0x19</span>,b<span class="number">&#x27;B</span>BB<span class="number">&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">delete_2(<span class="number">0</span>)</span><br><span class="line">delete_2(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">create_1(<span class="number">0x10</span>,p64(binsh)+p64(system))</span><br><span class="line"></span><br><span class="line">print_3(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<p>这道题就是一个最基础的uaf漏洞的题，写的比较详细，往对以后的这种漏洞有所启迪。</p>
<p>在libc版本为2.27的题目中，这种uaf漏洞，能使用tcachebins这样一种结构</p>
<p><img src="/2024/05/27/%E5%A0%86%E5%9F%BA%E7%A1%80%E9%A2%98%E8%A7%A3%E6%B3%95%E5%8F%8Awp/image-20240606150233631.png" alt="image-20240606150233631"></p>
<p>这种结构出现在大小小于0x400的chunk在被free后链接而成（大于0x400的在free后会成为unsortedbin），在这种结构中，chunk的fd指针由于指向下一个chunk的原本的的数据段，现在的fd段（如果下面没有chunk了，这个fd指针将会指向0）。这里面的chunk在再次使用时遵循的是先进先出的规律，当再次malloc时，先吧上面一个满足大小的chunk拿出来使用，然后在将下面一个满足大小的chunk拿出来使用。</p>
<p>这里如果我们便可以通过uaf漏洞，将chunk中fd指针的值修改为我们需要的地址空间然后，malloc到这块空间，便可以对其进行修改。</p>
<p>（这里好像不用在意要修改的地址空间上两位的值能不能构成chunk的prev size和size都可以，malloc到那里直接修改，但是在其他版本可能要满足条件）</p>
<p><strong>unlink</strong></p>
<p>现简单说一下这一类题的大致问题在哪里，与一般的解决办法。</p>
<p>要能使用这种解决办法的题，会以下的几种重要的东西是我们能够使用的，才能使用这种办法。</p>
<ol>
<li>能连续申请几个连续的堆，</li>
<li>对于指向申请的堆的指针，会在bss段上有一个固定且已知的地点存放，并且存放的方式是连续的。</li>
<li>必须在申请的堆中有堆溢出，用于修改下一个堆的prev size段空间</li>
</ol>
<p>对于这一类的题，最重要的就是在我们申请的堆中间，通过我们自己伪造一个fake chunk与bss段的存放对指针的地址，构成一个含有3个chunk的双向链表，然后在申请的宁外一个堆中使用堆溢出，从而修改下一个堆中的prev size段，并使大小为从要修改这个chunk的prev size一直到，我们伪造的fake chunk的prev size这两个地址的距离差大小，这样使得我们在后面free掉我们修改了prev size 的chunk时，程序会将从这个chunk一直到我们伪造的fake chunk的这一段地址都认为是之前已经free的chunk（prev size中记录的是上一个free chunk的大小），从而使这一个刚刚释放的free chunk，直接就把上面的一整段被识变为free chunk的地址合并了（连续的两个free chunk会被程序合并），但是我们在之前伪造的fake chunk已经与存放指针的地址，构成了一个双向链表，所以在这里fake chunk被下面的free chunk合并时，原本与之构成双项链表的那两个空间，由于与之相连的chunk被拿走了，使得那两个空间，会有一定的改变，而改变的结果就会使原本存放指针的地方存放其他地址空间，从而使用这个地址修改函数地址。</p>
<p><img src="/2024/05/27/%E5%A0%86%E5%9F%BA%E7%A1%80%E9%A2%98%E8%A7%A3%E6%B3%95%E5%8F%8Awp/image-20240601102616025.png" alt="image-20240601102616025"></p>
<p><img src="/2024/05/27/%E5%A0%86%E5%9F%BA%E7%A1%80%E9%A2%98%E8%A7%A3%E6%B3%95%E5%8F%8Awp/image-20240602084358411.png" alt="image-20240602084358411"></p>
<p><img src="/2024/05/27/%E5%A0%86%E5%9F%BA%E7%A1%80%E9%A2%98%E8%A7%A3%E6%B3%95%E5%8F%8Awp/image-20240602085046748.png" alt="image-20240602085046748"></p>
<p><img src="/2024/05/27/%E5%A0%86%E5%9F%BA%E7%A1%80%E9%A2%98%E8%A7%A3%E6%B3%95%E5%8F%8Awp/image-20240602085110947.png" alt="image-20240602085110947"></p>
<p><strong>Off-By-One</strong></p>
<p>这个漏洞在很多的地方都算是比较常见的吧，不过在之前的栈的时候属于不太好利用的一种，不过在堆中由于堆的特殊性导致，这个漏洞难够在很多地方发挥出意想不到的作用。</p>
<p>这个漏洞的具体就是使用read等函数向某块地址写入数据时，如果使用了循环的方式，而循环的次数的大小与那块地址的大小相同，如我们有的是大小为16的数组，我们通过循环向这里写入数字，而我们的循环的次数是由我们数组的大小决定，这里简单的说就是对循环的次数没有进行严格的检查，像循环的次数由变量x决定，并且循环的此时就等于这个x的值，这里x&#x3D;16，看起来好像没什么问题但是会发现，由于程序中的这些数组的起始都是从0开始，包括循环的+</p>
<p><img src="/2024/05/27/%E5%A0%86%E5%9F%BA%E7%A1%80%E9%A2%98%E8%A7%A3%E6%B3%95%E5%8F%8Awp/image-20240604222351621.png" alt="image-20240604222351621"></p>
<p><strong>unsortedbin泄露libc地址</strong></p>
<p>关于这种bin的具体结构等之后学会了在细讲，这里先讨论如何利用这种bin将libc的地址泄露。</p>
<p>由于在不同的libc版本中unsortedbin的产生不同，这里将针对不同libc版本进行分别讲解。</p>
<p><em>一，libc-2.27</em></p>
<p>在2.27的libc版本中又一种tcachebins的存在，这会导致数据区小于0x400，整体小于0x410的chunk在free后被放入tcachebins这里面，供下次使用，因此我们这里首先要先malloc一块大小大于0x400的chunk，同时这个chunk还不能与top chunk相邻，否则在free后会被top chunk直接合并，因此我们必须保证这个大于0x400的chunk与top chunk中间还有一个chunk用于隔离这两个chunk。就像满足这样的条件</p>
<p><img src="/2024/05/27/%E5%A0%86%E5%9F%BA%E7%A1%80%E9%A2%98%E8%A7%A3%E6%B3%95%E5%8F%8Awp/image-20240606153035259.png" alt="image-20240606153035259"></p>
<p>然后我们将大于0x400的这块chunk，free掉，就会得到一块被放置在unsortedbin中，且满足条件的free</p>
<p><img src="/2024/05/27/%E5%A0%86%E5%9F%BA%E7%A1%80%E9%A2%98%E8%A7%A3%E6%B3%95%E5%8F%8Awp/image-20240606153330482.png" alt="image-20240606153330482"></p>
<p>而此时这个free掉的chunk中的fd和bk指针由于只有这一个chunk在unsortedbin中，所以他们同时指向的都是main_arena+96的地址</p>
<p><img src="/2024/05/27/%E5%A0%86%E5%9F%BA%E7%A1%80%E9%A2%98%E8%A7%A3%E6%B3%95%E5%8F%8Awp/image-20240606153458981.png" alt="image-20240606153458981"></p>
<p>并且这个地址在程序中与libc的基地址的距离是始终保持相同的，只要能泄露这个便可以知道程序中的libc的基地址，在其他版本中其实也如此，不过在有的地方也有不同。</p>
<p><strong>house of orange</strong></p>
<p>今天做题的时候刚好遇到这个知识点，那就现在把他写一下。</p>
<p>这个的作用并不能直接作用于程序上实现shell，这个漏洞的作用只是在于特殊情况下泄露libc的地址，其实这里用到也就是创造unsortedbin，从而泄露libc的地址，我们知道在上面的使用unsortedbin泄露libc地址的方法前提是要能创造一个大小满足free后进入unsortedbin的大小的chunk并且这个chunk还不能与top chunk相邻的的条件的chunk，并且还要能将这个chunk，free掉使得它进入到unsortedbin中，然后在将fd指针的值打印出来，这样才能泄露libc的值，而这里我们就是在面对没有free函数的情况下，依然能产生unsortedbin从而泄露libc的值。</p>
<p>具体的不细将，直接将做法。</p>
<p>关于这种做法目前我之在libc-2.23上做过，关于其他的libc可能有所不同，请注意。这里也是按在libc-2.23上来讲。</p>
<p><em>一，第一步堆溢出，修改top chunk的size值</em></p>
<p>这里必须有一个靠近top chunk的chunk能被我们写入数据进去，同时这个chunk要能进行溢出，溢出的大小要能刚好修改到top chunk的size段。</p>
<p>关于修改的这个top chunk的size的大小并不是随意的，也是有要求的，</p>
<p><img src="/2024/05/27/%E5%A0%86%E5%9F%BA%E7%A1%80%E9%A2%98%E8%A7%A3%E6%B3%95%E5%8F%8Awp/image-20240607144743668.png" alt="image-20240607144743668"></p>
<p>这是未修改的top chunk的大小，size段的大小为0x20fe0，这里我们要修改成0xfe1，如下图，从而使程序能将top chunk的大小识别为0xfe0（那一个字节用于放数据，不计入总大小）</p>
<p><img src="/2024/05/27/%E5%A0%86%E5%9F%BA%E7%A1%80%E9%A2%98%E8%A7%A3%E6%B3%95%E5%8F%8Awp/image-20240607145205512.png" alt="image-20240607145205512"></p>
<p>关于为什么要修改top  chunk的大小为这个数据，我解释不好，有兴致的可以参考一下这篇文章<a target="_blank" rel="noopener" href="https://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/house-of-orange/?h=of+orange">House of Orange - CTF Wiki (ctf-wiki.org)</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.伪造的size必须要对齐到内存页</span><br></pre></td></tr></table></figure>

<p>什么是对齐到内存页呢？我们知道现代操作系统都是以内存页为单位进行内存管理的，一般内存页的大小是 4kb。那么我们伪造的 size 就必须要对齐到这个尺寸。在覆盖之前 top chunk 的 size 大小是 20fe1，通过计算得知 0x602020+0x20fe0&#x3D;0x623000 是对于 0x1000（4kb）对齐的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0x602000:   0x0000000000000000  0x0000000000000021</span><br><span class="line">0x602010:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602020:   0x0000000000000000  0x0000000000020fe1 &lt;== top chunk</span><br><span class="line">0x602030:   0x0000000000000000  0x0000000000000000</span><br></pre></td></tr></table></figure>

<p>因此我们伪造的 fake_size 可以是 0x0fe1、0x1fe1、0x2fe1、0x3fe1 等对 4kb 对齐的 size。</p>
<p>以上便是引用那里面的话，这里关于修改的大小我目前使用0x0fe1是成功的，使用了0x1fe1不能成功，原因未知。有时间研究一下。</p>
<p><em>二，申请一个大小大于这个top chunk的堆块</em></p>
<p>这里我申请的大小为0xff0，这是申请后的样子</p>
<p><img src="/2024/05/27/%E5%A0%86%E5%9F%BA%E7%A1%80%E9%A2%98%E8%A7%A3%E6%B3%95%E5%8F%8Awp/image-20240607150811073.png" alt="image-20240607150811073"></p>
<p>就是这样我们便能够在没有使用free函数的情况下也能产生一个unsortedbin,并且其中fd和bk指针都指向main_arena+88的地址空间。</p>
<p><img src="/2024/05/27/%E5%A0%86%E5%9F%BA%E7%A1%80%E9%A2%98%E8%A7%A3%E6%B3%95%E5%8F%8Awp/image-20240607151041083.png" alt="image-20240607151041083"></p>
<p>现在虽然产生了unsortedbin但是我们会发现，此时我们如果只有一个用于存放最近的指针的空间，会发现这个指针指向的chunk时是下面的的那个chunk，所以这个没有用。</p>
<p><img src="/2024/05/27/%E5%A0%86%E5%9F%BA%E7%A1%80%E9%A2%98%E8%A7%A3%E6%B3%95%E5%8F%8Awp/image-20240607151506598.png" alt="image-20240607151506598"></p>
<p><em>三，再申请一个chunk</em></p>
<p>这个新申请的chunk的大小，没什么限制，别太大太小就行，这里我申请的大小为0x40</p>
<p><img src="/2024/05/27/%E5%A0%86%E5%9F%BA%E7%A1%80%E9%A2%98%E8%A7%A3%E6%B3%95%E5%8F%8Awp/image-20240607152043072.png" alt="image-20240607152043072"></p>
<p>申请之后会发现存放指针的地址空间，存放的新的chunk指针为unsortedbin上面的新chunk，并且这个新chunk的内容也大有搞头，这里按理论来说这个新chunk的数据段前两个字节存放的都是<strong>0x00007614787c4188</strong>这个数据，（这里因为这道题在申请chunk时，必须要输入数据，所以这里的数据段第一个字节，不能使用，只能使用第二个字节的数据），这个地址指向的为main_arena+1640，这个地址与libc基地址的距离是固定的。</p>
<p><img src="/2024/05/27/%E5%A0%86%E5%9F%BA%E7%A1%80%E9%A2%98%E8%A7%A3%E6%B3%95%E5%8F%8Awp/image-20240607152729734.png" alt="image-20240607152729734"></p>
<p>同时这个chunk的第3，第4字节存放的数据时这个chunk的头地址。</p>
<p>就这样只要我们能将这个新chunk的内容打印出来，接收第2字节的main_arena+1640的地址，第3字节的chunk的头地址，那就可以跟具这个地址与libc基地址的差得到基地址的大小（这个差值是固定不变的），还有chunk的地址也能拿到</p>
<ul>
<li>修改top chunk的size大小为0xfe1</li>
<li>申请一个大小大于0xfe0的chunk</li>
<li>在申请一个0x20的chunk</li>
<li>打印并接收新chunk的内容（注意如果一定要输入数据，注意不要过多，影响第二字节的内容）</li>
<li>减去相应的差值得到libc基地址。</li>
</ul>
<p><strong>Fastbin Attack</strong></p>
<p>这一类有四种小类，这里将分批讲解。</p>
<p><em>Fastbin Double Free</em></p>
<p>这是一种利用比较多的漏洞，这种漏洞的实现的条件比较苛刻，但其攻击的效果也属于比较明显的便于利用的一种，这种的攻击的手段需要的有uaf漏洞，只有在有uaf漏洞的基础上以及比较早的比如libc2.23这些比较早期的版本下才能实现这种攻击的手段，具体的现在来讲。</p>
<p>既然是Double Free，那就必须要进行双重释放，对同一个堆块进行两次free，中间必须要free得有一个或多个chunk这样才能实现对同一个chunk进行两次释放，<img src="/2024/05/27/%E5%A0%86%E5%9F%BA%E7%A1%80%E9%A2%98%E8%A7%A3%E6%B3%95%E5%8F%8Awp/image-20240418143002441.png" alt="image-20240418143002441"></p>
<p>这里借用一下之前文章中的图片讲解一下，在fastbin中的结构是用chunk中的fd指针指向之前一个free的指针的头地址，然后bin的指针指向最近free的chunk的头地址，对于最后一个chunk中的fd指针则为0，就这样可以再fastbin中构成由最开始的bin中的指针开始依次由fd指针相连的chunk链，就这样在malloc相同的大小的chunk时便可以在直接从这个fastbin中依次取出来用就行。</p>
<p><img src="/2024/05/27/%E5%A0%86%E5%9F%BA%E7%A1%80%E9%A2%98%E8%A7%A3%E6%B3%95%E5%8F%8Awp/image-20240611213009652.png" alt="image-20240611213009652"></p>
<p>就这样我们先free两个chunk这时bin指向第二个free的malloc，这个malloc的fd指针指向第一个chunk的头地址，第一个chunk的fd指针为0。</p>
<p>这时我们就对第一个free的chunk进行二次free，于是bin中的指针就会回到第一个chunk的头地址，同时这个chunk的fd指针也会因为在之前有已经free掉的chunk，从而指向第二个chunk的头地址，</p>
<p><img src="/2024/05/27/%E5%A0%86%E5%9F%BA%E7%A1%80%E9%A2%98%E8%A7%A3%E6%B3%95%E5%8F%8Awp/image-20240611213952236.png" alt="image-20240611213952236"></p>
<p>就这样原本的fastbin中的结构，由<code>bin--&gt;第二个chunk--&gt;第一个chunk</code>，变成</p>
<p><code>bin--&gt;第一个chunk--&gt;第二个chunk--&gt;第一个chunk</code>这样的双重free结构，</p>
<p>这样当我们向程序再申请一个相同大小的chunk时，程序会先从bin的指向中取出第一个chunk以供使用，但是由于之前的双重释放从而使得bin中的结构即使取出第一个chunk后依然有第一个chunk的存在，</p>
<p><code>bin--&gt;第二个chunk--&gt;第一个chunk</code></p>
<p>是这样的结构，虽然第一个chunk被我们取了出来但是在bin中依然有他的存在，并且此时第一个chunk中的fd指针在fastbin中由于是有用的指向了第二个chunk的头地址。</p>
<p>这里如果我们在程序的其他地方构造一个fake_chunk（这个地方可以是bss段上，甚至可以是栈上的地址）,并使得第一个chunk中fd指针就指向这个fake_chunk的头地址，而这个fake_chunk的构造很简单，就是确保size段的大小和前两个chunk的size一样，同时其他的保持为0就行，然后在修改了chunk中的fd段后bin中的结构就会改变为如下的结构。</p>
<p><img src="/2024/05/27/%E5%A0%86%E5%9F%BA%E7%A1%80%E9%A2%98%E8%A7%A3%E6%B3%95%E5%8F%8Awp/image-20240611220613433.png" alt="image-20240611220613433"></p>
<p>这样之后，我们再向程序连续申请两个大小相同的chunk后bin就会指向我们fake_chunkde1,然后在申请一个就会使我们刚刚伪造的fake_chunk,被我们申请为一个新的chunk，从而可以修改这个地址的内容。</p>
<p><strong>House Of Spirit</strong></p>
<p>这个方法我个人感觉很奇妙，虽然这种方法有种脱裤子放屁的感觉（在更多的地方感觉使用fd修改可能更多，不过这种方法的思想还很值得学习的）。</p>
<p>这种方法的主要过程就是在使用free函数释放某一个chunk，我们通过在bss段或其他的地址伪造一段chunk，在使用于释放的那个指针指向的就是我们伪造的这个chunk，通过这样使得我们这伪造的这个chunk被挂入进fastbin中的单项链表中，被程序识别为一个free掉的chunk，在后期我们在向程序申请相同大小的chunk时，能直接将那块地址作为chunk以供我们要使用，从而是我们能修改那块区域和使用其中的数据段。</p>
<p>我之前说的脱裤子放屁的感觉就是在这里，我们本可以直接修改fastbin中的bk段直接指向伪造的chunk，但我们却要将那块伪造的chunk释放来挂入fastbin中，这不是脱裤子放屁，这是什么。不过并不是所有题都能直接修改free chunk的，所以这种方法的出现以可以理解。</p>
<p>关于这种方法在伪造chunk时有几个需要注意的点，这里我直接吵ctfwiki上了，原文在这里</p>
<p><a target="_blank" rel="noopener" href="https://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/fastbin-attack/#house-of-spirit">Fastbin Attack - CTF Wiki (ctf-wiki.org)</a></p>
<p>要想构造 fastbin fake chunk，并且将其释放时，可以将其放入到对应的 fastbin 链表中，需要绕过一些必要的检测，即</p>
<ul>
<li>fake chunk 的 ISMMAP 位不能为 1，因为 free 时，如果是 mmap 的 chunk，会单独处理。</li>
<li>fake chunk 地址需要对齐， MALLOC_ALIGN_MASK</li>
<li>fake chunk 的 size 大小需要满足对应的 fastbin 的需求，同时也得对齐。</li>
<li>fake chunk 的 next chunk 的大小不能小于 <code>2 * SIZE_SZ</code>，同时也不能大于<code>av-&gt;system_mem</code> 。</li>
<li>fake chunk 对应的 fastbin 链表头部不能是该 fake chunk，即不能构成 double free 的情况。</li>
</ul>
<p>在借用一篇大佬写的解释<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41202237/article/details/109284167">好好说话之Fastbin Attack（2）：House Of Spirit_fastbin attack house of spirit-CSDN博客</a>（这个是真的nb大佬，写的文章都太好了）</p>
<h5 id="1、fake-chunk-的-ISMMAP-位不能为-1，因为-free-时，如果是-mmap-的-chunk，会单独处理"><a href="#1、fake-chunk-的-ISMMAP-位不能为-1，因为-free-时，如果是-mmap-的-chunk，会单独处理" class="headerlink" title="1、fake chunk 的 ISMMAP 位不能为 1，因为 free 时，如果是 mmap 的 chunk，会单独处理"></a>1、fake chunk 的 ISMMAP 位不能为 1，因为 free 时，如果是 mmap 的 chunk，会单独处理</h5><p>IS_MAPPED，记录当前 chunk 是否是由 mmap 分配的，这个标志位位于size低二比特位</p>
<h5 id="2、fake-chunk-地址需要对齐，-MALLOC-ALIGN-MASK"><a href="#2、fake-chunk-地址需要对齐，-MALLOC-ALIGN-MASK" class="headerlink" title="2、fake chunk 地址需要对齐， MALLOC_ALIGN_MASK"></a>2、fake chunk 地址需要对齐， MALLOC_ALIGN_MASK</h5><p>因为fake_chunk可以在任意可写位置构造，这里对齐指的是地址上的对齐而不仅仅是内存对齐，比如32位程序的话fake_chunk的prev_size所在地址就应该位<code>0xXXXX0</code>或<code>0xXXXX4</code>。64位的话地址就应该在<code>0xXXXX0</code>或<code>0xXXXX8</code></p>
<h5 id="3、fake-chunk-的-size-大小需要满足对应的-fastbin-的需求，同时也得对齐"><a href="#3、fake-chunk-的-size-大小需要满足对应的-fastbin-的需求，同时也得对齐" class="headerlink" title="3、fake chunk 的 size 大小需要满足对应的 fastbin 的需求，同时也得对齐"></a>3、fake chunk 的 size 大小需要满足对应的 fastbin 的需求，同时也得对齐</h5><p>fake_chunk如果想挂进fastbin的话构造的大小就不能大于<code>0x80</code>，关于对齐和上面一样，并且在确定prev_size的位置后size所在位置要满足堆块结构的摆放位置</p>
<h5 id="4、fake-chunk-的-next-chunk-的大小不能小于-2-SIZE-SZ，同时也不能大于av-system-mem"><a href="#4、fake-chunk-的-next-chunk-的大小不能小于-2-SIZE-SZ，同时也不能大于av-system-mem" class="headerlink" title="4、fake chunk 的 next chunk 的大小不能小于 2 * SIZE_SZ，同时也不能大于av-&gt;system_mem"></a>4、fake chunk 的 next chunk 的大小不能小于 2 * SIZE_SZ，同时也不能大于av-&gt;system_mem</h5><p>fake_chunk 的大小，大小必须是 2 * SIZE_SZ 的整数倍。如果申请的内存大小不是 2 * SIZE_SZ 的整数倍，会被转换满足大小的最小的 2 * SIZE_SZ 的倍数。32 位系统中，SIZE_SZ 是 4；64 位系统中，SIZE_SZ 是 8。最大不能超过av-&gt;system_mem，即128kb。next_chunk的大小一般我们会设置成为一个超过fastbin最大的范围的一个数，但要小雨128kb，这样做的目的是在chunk连续释放的时候，能够保证伪造的chunk在释放后能够挂在fastbin中main_arena的前面，这样以来我们再一次申请伪造chunk大小的块时可以直接重启伪造chunk</p>
<h5 id="5、fake-chunk-对应的-fastbin-链表头部不能是该-fake-chunk，即不能构成-double-free-的情况"><a href="#5、fake-chunk-对应的-fastbin-链表头部不能是该-fake-chunk，即不能构成-double-free-的情况" class="headerlink" title="5、fake chunk 对应的 fastbin 链表头部不能是该 fake chunk，即不能构成 double free 的情况"></a>5、fake chunk 对应的 fastbin 链表头部不能是该 fake chunk，即不能构成 double free 的情况</h5><p>这个检查就是fake_chunk前一个释放块不能是fake_chunk本身，如果是的话_int_free函数就会检查出来并且中断。可以参考篇文章<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41202237/article/details/109199077">好好说话之Fastbin Attack（1）：Fastbin Double Free</a></p>
<p>这里在讲讲我的自己的简单补充，伪造的chunk最好如下，fake_prev_size的值为0，fake_size可以根据自己的需求来调整，但不能超过fastbin的要求，还有这里填的是0x几0不用加1。在整个fake_chunk结束的下一行便要是宁一个fake chunk，这个只要整prev_szie 和size段就好，这个的prev szie是之前伪造的那个chunk的整体大小，然后size这个的大小在32位系统我使用了0x100是可行的，不知道在64位的系统中可以不，到时候在仔细研究一下。</p>
<p><img src="/2024/05/27/%E5%A0%86%E5%9F%BA%E7%A1%80%E9%A2%98%E8%A7%A3%E6%B3%95%E5%8F%8Awp/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjAyMjM3,size_16,color_FFFFFF,t_70#pic_center.png" alt="在这里插入图片描述"></p>
<p>就这样我们伪造一个chunk然后把这个chunk的数据段起始地址，当做这个chunk的指针放入free函数中，这样这个chunk变回被程序当做free chunk挂入fastbin中，然后我们在申请这个大小的chunk，便可以把这个地址当做新被chunk，被我们使用。</p>
<p><strong>Alloc to Stack</strong></p>
<p><strong>Arbitrary Alloc</strong></p>
<p>这还有两种方法，这两种方法的大致差别不大，都是在程序中寻找一块可用的地址然后修改fastbin的bk指针使其指向这个地址，在fastbin中增加这块地址，在之后将这块地址申请出来作为一个新chunk使用。</p>
<p>关于这块这地址的检查，不需要多的就一个对size段的大小检查，因此我们这可以在malloc_hook的地址上面通过偏移地址使得size只有0x7几，这样只要我们申请的chunk大小为0x70，程序就会直接把那块区域分配给我们使用。</p>
<h2 id="2017-0ctf-babyheap"><a href="#2017-0ctf-babyheap" class="headerlink" title="2017 0ctf babyheap"></a><a target="_blank" rel="noopener" href="https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/heap/fastbin-attack/2017_0ctf_babyheap">2017 0ctf babyheap</a></h2><p>这里讲一个泄露libc手法，是在做这道题时遇到的，这个手还是比较可以的。</p>
<p>关于这种手法的使用条件，为</p>
<ul>
<li>可以申请多个chunk大小不一</li>
<li>每一个chunk都可以进行堆溢出</li>
<li>可以打印chunk中的内容</li>
</ul>
<p>其实有这些条件这道题就可以用这种泄露的办法将libc地址泄露。</p>
<p>这里就拿这道题的条件分析，（这里面的图我从大佬的博客里面偷的，写的太好的这个大佬，强推！！！原文在这里<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41202237/article/details/112320919">好好说话之Fastbin Attack（4）：Arbitrary Alloc_好好说话 ctf-CSDN博客</a>，和上面的那篇是同一个作者，膜拜大佬。）</p>
<p>这道题我们不知道堆的指针在哪，同时也没有uaf漏洞给我们使用，那我们要泄露libc的地址，虽然这里我们能创造unsortbin，但我们并不知道这个chunk的地址故不能直接泄露他，这里便可以用这个方法泄露libc的地址</p>
<p>这里我们先申请5个chunk前4个大小为0x20，最后一个0x90，申请后的样子如下</p>
<h4 id><a href="#" class="headerlink" title></a><img src="/2024/05/27/%E5%A0%86%E5%9F%BA%E7%A1%80%E9%A2%98%E8%A7%A3%E6%B3%95%E5%8F%8Awp/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjAyMjM3,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述"></h4><p>形成这样的结构后，我们在依次free掉chunk3和chunk2这两个chunk，使得在fastbin中能形成一个链表，为什么要先free chunk3在chunk2，这里是为了在chunk2中出现bk指针执向chunk3头地址（fastbin的结构使后free的chunk中的bk指向前一个free的chunk的头地址），然后我们在利用chunk1的堆溢出，从而直接修改chunk2中的bk指针，使其指向chunk5的头地址。</p>
<p>这里虽然我们并不知道chunk5的准确头地址，但这里因为堆的对齐导致堆块的地址即使在每一次程序的加载都会有变化，但末尾的后3位是固定，这里我们只需要将chunk2的bk指针的后两位数字覆盖为chunk5的头地址的后两位，这样就可以改变fastbin中的结构使得chunk2后直接是chunk5的地址</p>
<p><img src="/2024/05/27/%E5%A0%86%E5%9F%BA%E7%A1%80%E9%A2%98%E8%A7%A3%E6%B3%95%E5%8F%8Awp/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjAyMjM3,size_16,color_FFFFFF,t_70-17182860203185.png" alt="在这里插入图片描述"></p>
<p>这里我们还需要做的就是再利用chunk4中的堆溢出将chunk5的size段改为0x21，这里修改是为使chunk5的大小与chunk2的大小保持一致，这样我们能在之后的申请中将chunk再一次申请出来被程序再次记录下，<img src="/2024/05/27/%E5%A0%86%E5%9F%BA%E7%A1%80%E9%A2%98%E8%A7%A3%E6%B3%95%E5%8F%8Awp/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjAyMjM3,size_16,color_FFFFFF,t_70-17182863339718.png" alt="在这里插入图片描述"></p>
<p>修改后的结构如上，这样chunk2和chunk5的大小一致，我们可以直接向程序申请这个大小的堆块从而使得程序中的第3个指针的位置存放的也是第5个chunk的指针，也就是chunk5的重启</p>
<p><img src="/2024/05/27/%E5%A0%86%E5%9F%BA%E7%A1%80%E9%A2%98%E8%A7%A3%E6%B3%95%E5%8F%8Awp/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjAyMjM3,size_16,color_FFFFFF,t_70-171828680334711.png" alt="在这里插入图片描述"></p>
<p>再这样之后再程序中就有两个地址同时记录则chunk5的地址，分别为地址空间为3和5的指针，不过由于这个地址我们并不知道但并不影响我们对其的引用。其实到这里剩下的就很简单了，我们再一次利用chunk4的堆溢出修改chunk5的size段的数据恢复为0x91，然后我们在申请一个chunk块，这个会从top chunk分出来，用以避免chunk5 free时直接与top chunk合并，之后我们直接free掉chunk5这样，chunk5就回进入unsortbin中，产生指向main_arena的fd指针，这里我们知道程序在free掉后会同时清楚相应位置存放的指针，但是这里由于我们之前的操作导致在程序中不只有记录chunk5的位置有指向chunk5的指针，还有记录chunk3的位置有指向chunk5的指针，这样就到导致我们可以通过打印chunk3的方法从而打印出chunk5中的内容，这样就可以通过unsortbin的bk指针得知libc的地址。</p>
<p>补充一下图，恢复chunk5的大小<img src="/2024/05/27/%E5%A0%86%E5%9F%BA%E7%A1%80%E9%A2%98%E8%A7%A3%E6%B3%95%E5%8F%8Awp/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjAyMjM3,size_16,color_FFFFFF,t_70-171828773725714.png" alt="在这里插入图片描述"></p>
<p>free chunk5，产生unsortbin</p>
<p><img src="/2024/05/27/%E5%A0%86%E5%9F%BA%E7%A1%80%E9%A2%98%E8%A7%A3%E6%B3%95%E5%8F%8Awp/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjAyMjM3,size_16,color_FFFFFF,t_70-171828778885817.png" alt="在这里插入图片描述"></p>
<p>在次感谢holk大佬的博客，跪谢！</p>
<p>其实这种方法的主要目的就在与使用堆溢出修改fastbin中fd的指向，在申请相同chunk区域，使得程序中两个地址同时记录着同一块chunk的指针，然后利用这块chunk产生unsortbin，在利用后面存放这块chunk的指针打印chunk中的内容，从而实现libc地址的泄露。</p>
<p>巧妙的方法，感觉要长脑子了。</p>
<p><strong>Unsorted Bin Attack</strong></p>
<p>这个手法咋说呢，感觉有点鸡肋，单独使用的作用并不是那么的大，可能在大部分时候要配和着其他的手法来使用才算可以发挥作用，或许可以用来在有的时候用于泄露libc的地址，但条件感觉要的有点多，在没有在实际的题目的使用过。并且这种攻击的手法之前好像看见有人说从libc2.28开始就不能再使用，在系统中多了对Unsorted Bin 的大小检测的函数，这种攻击的方式便不能再使用所以对题目的要求也较高，就有点鸡肋。不过既然有种手法就还是学一下，至少知道这种漏洞的存在。</p>
<p>前话到此为止，现在开始讲有关这种手法的操作。</p>
<p>关于Unsorted Bin这是一个神奇的bin，我们知道有的chunk由于大小限制所以在释放后会被放入的Unsorted Bin中作为其中的一部分free chunk以供下次申请时快速使用，但是其实在没有chunk进入到unsorted bin的时候他自己本身就是一个单独的chunk结构，不过不参与到chunk的分配只作用来作为unsorted bin的基础机构，如下图</p>
<p><img src="/2024/05/27/%E5%A0%86%E5%9F%BA%E7%A1%80%E9%A2%98%E8%A7%A3%E6%B3%95%E5%8F%8Awp/image-20240615220108814.png" alt="image-20240615220108814"></p>
<p>（这个图还是偷的csdn的大佬holk，再次跪谢大佬，跪谢大佬无私，原文链接<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41202237/article/details/112589899">好好说话之Unsorted Bin Attack_unsortedbin attack-CSDN博客</a>）</p>
<p>这个就是unsorted bin结构，而当有free chunk进入到unsorted bin中时这两个的结构变回发生新的变化，</p>
<p><img src="/2024/05/27/%E5%A0%86%E5%9F%BA%E7%A1%80%E9%A2%98%E8%A7%A3%E6%B3%95%E5%8F%8Awp/image-20240615220500217.png" alt="image-20240615220500217"></p>
<p>此时chunk_400是我们程序中由free从而进入到unsorted bin中chunk，这个chunk的fd和bk指针都会指向unsorted bin的结构chunk的头地址，而我们知道unsorted bin的结构在程序中的位置在main_arena+88的地方，这就是为什么我们能通过泄露unsorted bin的fd和bk指针从而获取到程序的libc地址。</p>
<p>我们关于这个漏洞的手法就正式从这里开始，这里我们如果修改了我们free进unsorted bin中的这个chunk的bk指针，使其指向宁一个地址那么程序便会直接将那个地址默认为一个新free进unsorted bin中的chunk，从而形成一个新的结构。</p>
<p><img src="/2024/05/27/%E5%A0%86%E5%9F%BA%E7%A1%80%E9%A2%98%E8%A7%A3%E6%B3%95%E5%8F%8Awp/image-20240615221509136.png" alt="image-20240615221509136"></p>
<p>这里的bk指向的chunk中对任何一个的数值没有要求只要修改bk的指向，程序就会默认这个地址为一个新的chunk被收录进unsorted bin（这个在libc2.23中是如此其他版本还不知道），但是这里在个填入的地址后期并不会被申请出来。这里还有一个重要的点，就是在我们堆溢出修改chunk_400时我们不必保存fd指针的指向一直指向unsorted bin的头地址，我们可以直接覆盖为0。这样也不影响后面的操作。</p>
<p>现在便是这种方法的最后一步，由于在unsorted bin中对free chunk的申请保持的是一种<code>FIFO</code>（先进先出）的利用手法，所以即使在这里我们将一个新的地址作为新的free chunk挂入unsorted bin中，只要我们能在申请到与chunk_400同样大小的chunk那程序依然会先从unsorted bin中将chunk_400拿出给我们使用，而在这里一旦将chunk_400拿出来unsorted bin中变回对结构有新的变化，变化的结果如下</p>
<p><img src="/2024/05/27/%E5%A0%86%E5%9F%BA%E7%A1%80%E9%A2%98%E8%A7%A3%E6%B3%95%E5%8F%8Awp/image-20240615223112353.png" alt="image-20240615223112353"></p>
<p>变化之后unsorted bin的fd指针指向chunk_400的头地址，bk指针指向我们创造的fake chunk的头地址，而对我们来说最终要的便是我们的fake chunk的bk指针被修改为指向unsorted bin的头地址。</p>
<p>就这样我们成功做到将我们写入chunk_400中的地址的下两位修改为unsorted bin的头地址，但是由于这个地址在程序中随机化的，所以我们并不能保证这个数值的大小。虽然这个地址是main_arena+88，与libc的距离是固定不变的，但我们并不知道具体的大小，所以这里是有一点鸡肋的存在，但或许可以通过打印修改的这里的地址获取到libc的地址，但这并不好用。</p>
<p>好，到这里这种手法就差不多结束了，总结一下，这种手法能做的就是将程序中的某一块地址的内容修改为main_arena+88的地址， 是一个比较大的数。</p>
<ol>
<li>产生unsorted bin</li>
<li>修改这个unsorted bin的bk指针指向我们要修改的地址-0x10的地址</li>
<li>重新通过malloc启用unsorted bin中的那个chunk</li>
</ol>

    </div>
    
    
    
    
    
    
    
</div>

            <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2022 - 2024 纲的blog
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;wgiegie
        </div>
        <div>
            Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp;
            <a target="_blank" rel="noopener" href="https://github.com/theme-particlex/hexo-theme-particlex">ParticleX Theme</a>
        </div>
        
    </div>
</footer>

        </div>
        
        <transition name="fade">
            <div id="preview" ref="preview" v-show="previewShow">
                <img id="preview-content" ref="previewContent" />
            </div>
        </transition>
        
    </div>
    <script src="/js/main.js"></script>
    
    




    
</body>
</html>
